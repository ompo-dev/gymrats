
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model StudentProgress
 * 
 */
export type StudentProgress = $Result.DefaultSelection<Prisma.$StudentProgressPayload>
/**
 * Model StudentProfile
 * 
 */
export type StudentProfile = $Result.DefaultSelection<Prisma.$StudentProfilePayload>
/**
 * Model WeightHistory
 * 
 */
export type WeightHistory = $Result.DefaultSelection<Prisma.$WeightHistoryPayload>
/**
 * Model Gym
 * 
 */
export type Gym = $Result.DefaultSelection<Prisma.$GymPayload>
/**
 * Model GymProfile
 * 
 */
export type GymProfile = $Result.DefaultSelection<Prisma.$GymProfilePayload>
/**
 * Model GymStats
 * 
 */
export type GymStats = $Result.DefaultSelection<Prisma.$GymStatsPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Workout
 * 
 */
export type Workout = $Result.DefaultSelection<Prisma.$WorkoutPayload>
/**
 * Model WorkoutExercise
 * 
 */
export type WorkoutExercise = $Result.DefaultSelection<Prisma.$WorkoutExercisePayload>
/**
 * Model AlternativeExercise
 * 
 */
export type AlternativeExercise = $Result.DefaultSelection<Prisma.$AlternativeExercisePayload>
/**
 * Model WorkoutProgress
 * 
 */
export type WorkoutProgress = $Result.DefaultSelection<Prisma.$WorkoutProgressPayload>
/**
 * Model WorkoutHistory
 * 
 */
export type WorkoutHistory = $Result.DefaultSelection<Prisma.$WorkoutHistoryPayload>
/**
 * Model ExerciseLog
 * 
 */
export type ExerciseLog = $Result.DefaultSelection<Prisma.$ExerciseLogPayload>
/**
 * Model PersonalRecord
 * 
 */
export type PersonalRecord = $Result.DefaultSelection<Prisma.$PersonalRecordPayload>
/**
 * Model DietPlan
 * 
 */
export type DietPlan = $Result.DefaultSelection<Prisma.$DietPlanPayload>
/**
 * Model Meal
 * 
 */
export type Meal = $Result.DefaultSelection<Prisma.$MealPayload>
/**
 * Model DietPlanCompletion
 * 
 */
export type DietPlanCompletion = $Result.DefaultSelection<Prisma.$DietPlanCompletionPayload>
/**
 * Model DailyNutrition
 * 
 */
export type DailyNutrition = $Result.DefaultSelection<Prisma.$DailyNutritionPayload>
/**
 * Model NutritionMeal
 * 
 */
export type NutritionMeal = $Result.DefaultSelection<Prisma.$NutritionMealPayload>
/**
 * Model NutritionFoodItem
 * 
 */
export type NutritionFoodItem = $Result.DefaultSelection<Prisma.$NutritionFoodItemPayload>
/**
 * Model NutritionChatUsage
 * 
 */
export type NutritionChatUsage = $Result.DefaultSelection<Prisma.$NutritionChatUsagePayload>
/**
 * Model FoodItem
 * 
 */
export type FoodItem = $Result.DefaultSelection<Prisma.$FoodItemPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model AchievementUnlock
 * 
 */
export type AchievementUnlock = $Result.DefaultSelection<Prisma.$AchievementUnlockPayload>
/**
 * Model GymUserPreference
 * 
 */
export type GymUserPreference = $Result.DefaultSelection<Prisma.$GymUserPreferencePayload>
/**
 * Model GymMembership
 * 
 */
export type GymMembership = $Result.DefaultSelection<Prisma.$GymMembershipPayload>
/**
 * Model MembershipPlan
 * 
 */
export type MembershipPlan = $Result.DefaultSelection<Prisma.$MembershipPlanPayload>
/**
 * Model DayPass
 * 
 */
export type DayPass = $Result.DefaultSelection<Prisma.$DayPassPayload>
/**
 * Model CheckIn
 * 
 */
export type CheckIn = $Result.DefaultSelection<Prisma.$CheckInPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model MaintenanceRecord
 * 
 */
export type MaintenanceRecord = $Result.DefaultSelection<Prisma.$MaintenanceRecordPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model GymSubscription
 * 
 */
export type GymSubscription = $Result.DefaultSelection<Prisma.$GymSubscriptionPayload>
/**
 * Model SubscriptionFeature
 * 
 */
export type SubscriptionFeature = $Result.DefaultSelection<Prisma.$SubscriptionFeaturePayload>
/**
 * Model SubscriptionPayment
 * 
 */
export type SubscriptionPayment = $Result.DefaultSelection<Prisma.$SubscriptionPaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  STUDENT: 'STUDENT',
  GYM: 'GYM',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentProgress`: Exposes CRUD operations for the **StudentProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentProgresses
    * const studentProgresses = await prisma.studentProgress.findMany()
    * ```
    */
  get studentProgress(): Prisma.StudentProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentProfile`: Exposes CRUD operations for the **StudentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentProfiles
    * const studentProfiles = await prisma.studentProfile.findMany()
    * ```
    */
  get studentProfile(): Prisma.StudentProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weightHistory`: Exposes CRUD operations for the **WeightHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeightHistories
    * const weightHistories = await prisma.weightHistory.findMany()
    * ```
    */
  get weightHistory(): Prisma.WeightHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gym`: Exposes CRUD operations for the **Gym** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gyms
    * const gyms = await prisma.gym.findMany()
    * ```
    */
  get gym(): Prisma.GymDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymProfile`: Exposes CRUD operations for the **GymProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymProfiles
    * const gymProfiles = await prisma.gymProfile.findMany()
    * ```
    */
  get gymProfile(): Prisma.GymProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymStats`: Exposes CRUD operations for the **GymStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymStats
    * const gymStats = await prisma.gymStats.findMany()
    * ```
    */
  get gymStats(): Prisma.GymStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workout`: Exposes CRUD operations for the **Workout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workouts
    * const workouts = await prisma.workout.findMany()
    * ```
    */
  get workout(): Prisma.WorkoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutExercise`: Exposes CRUD operations for the **WorkoutExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutExercises
    * const workoutExercises = await prisma.workoutExercise.findMany()
    * ```
    */
  get workoutExercise(): Prisma.WorkoutExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alternativeExercise`: Exposes CRUD operations for the **AlternativeExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlternativeExercises
    * const alternativeExercises = await prisma.alternativeExercise.findMany()
    * ```
    */
  get alternativeExercise(): Prisma.AlternativeExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutProgress`: Exposes CRUD operations for the **WorkoutProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutProgresses
    * const workoutProgresses = await prisma.workoutProgress.findMany()
    * ```
    */
  get workoutProgress(): Prisma.WorkoutProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutHistory`: Exposes CRUD operations for the **WorkoutHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutHistories
    * const workoutHistories = await prisma.workoutHistory.findMany()
    * ```
    */
  get workoutHistory(): Prisma.WorkoutHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseLog`: Exposes CRUD operations for the **ExerciseLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseLogs
    * const exerciseLogs = await prisma.exerciseLog.findMany()
    * ```
    */
  get exerciseLog(): Prisma.ExerciseLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalRecord`: Exposes CRUD operations for the **PersonalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalRecords
    * const personalRecords = await prisma.personalRecord.findMany()
    * ```
    */
  get personalRecord(): Prisma.PersonalRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dietPlan`: Exposes CRUD operations for the **DietPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DietPlans
    * const dietPlans = await prisma.dietPlan.findMany()
    * ```
    */
  get dietPlan(): Prisma.DietPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meal`: Exposes CRUD operations for the **Meal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meals
    * const meals = await prisma.meal.findMany()
    * ```
    */
  get meal(): Prisma.MealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dietPlanCompletion`: Exposes CRUD operations for the **DietPlanCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DietPlanCompletions
    * const dietPlanCompletions = await prisma.dietPlanCompletion.findMany()
    * ```
    */
  get dietPlanCompletion(): Prisma.DietPlanCompletionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyNutrition`: Exposes CRUD operations for the **DailyNutrition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyNutritions
    * const dailyNutritions = await prisma.dailyNutrition.findMany()
    * ```
    */
  get dailyNutrition(): Prisma.DailyNutritionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionMeal`: Exposes CRUD operations for the **NutritionMeal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionMeals
    * const nutritionMeals = await prisma.nutritionMeal.findMany()
    * ```
    */
  get nutritionMeal(): Prisma.NutritionMealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionFoodItem`: Exposes CRUD operations for the **NutritionFoodItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionFoodItems
    * const nutritionFoodItems = await prisma.nutritionFoodItem.findMany()
    * ```
    */
  get nutritionFoodItem(): Prisma.NutritionFoodItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionChatUsage`: Exposes CRUD operations for the **NutritionChatUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionChatUsages
    * const nutritionChatUsages = await prisma.nutritionChatUsage.findMany()
    * ```
    */
  get nutritionChatUsage(): Prisma.NutritionChatUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodItem`: Exposes CRUD operations for the **FoodItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodItems
    * const foodItems = await prisma.foodItem.findMany()
    * ```
    */
  get foodItem(): Prisma.FoodItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievementUnlock`: Exposes CRUD operations for the **AchievementUnlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AchievementUnlocks
    * const achievementUnlocks = await prisma.achievementUnlock.findMany()
    * ```
    */
  get achievementUnlock(): Prisma.AchievementUnlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymUserPreference`: Exposes CRUD operations for the **GymUserPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymUserPreferences
    * const gymUserPreferences = await prisma.gymUserPreference.findMany()
    * ```
    */
  get gymUserPreference(): Prisma.GymUserPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymMembership`: Exposes CRUD operations for the **GymMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymMemberships
    * const gymMemberships = await prisma.gymMembership.findMany()
    * ```
    */
  get gymMembership(): Prisma.GymMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membershipPlan`: Exposes CRUD operations for the **MembershipPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipPlans
    * const membershipPlans = await prisma.membershipPlan.findMany()
    * ```
    */
  get membershipPlan(): Prisma.MembershipPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dayPass`: Exposes CRUD operations for the **DayPass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DayPasses
    * const dayPasses = await prisma.dayPass.findMany()
    * ```
    */
  get dayPass(): Prisma.DayPassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkIn`: Exposes CRUD operations for the **CheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckIns
    * const checkIns = await prisma.checkIn.findMany()
    * ```
    */
  get checkIn(): Prisma.CheckInDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceRecord`: Exposes CRUD operations for the **MaintenanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceRecords
    * const maintenanceRecords = await prisma.maintenanceRecord.findMany()
    * ```
    */
  get maintenanceRecord(): Prisma.MaintenanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymSubscription`: Exposes CRUD operations for the **GymSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymSubscriptions
    * const gymSubscriptions = await prisma.gymSubscription.findMany()
    * ```
    */
  get gymSubscription(): Prisma.GymSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionFeature`: Exposes CRUD operations for the **SubscriptionFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionFeatures
    * const subscriptionFeatures = await prisma.subscriptionFeature.findMany()
    * ```
    */
  get subscriptionFeature(): Prisma.SubscriptionFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPayment`: Exposes CRUD operations for the **SubscriptionPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPayments
    * const subscriptionPayments = await prisma.subscriptionPayment.findMany()
    * ```
    */
  get subscriptionPayment(): Prisma.SubscriptionPaymentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Verification: 'Verification',
    Student: 'Student',
    StudentProgress: 'StudentProgress',
    StudentProfile: 'StudentProfile',
    WeightHistory: 'WeightHistory',
    Gym: 'Gym',
    GymProfile: 'GymProfile',
    GymStats: 'GymStats',
    Unit: 'Unit',
    Workout: 'Workout',
    WorkoutExercise: 'WorkoutExercise',
    AlternativeExercise: 'AlternativeExercise',
    WorkoutProgress: 'WorkoutProgress',
    WorkoutHistory: 'WorkoutHistory',
    ExerciseLog: 'ExerciseLog',
    PersonalRecord: 'PersonalRecord',
    DietPlan: 'DietPlan',
    Meal: 'Meal',
    DietPlanCompletion: 'DietPlanCompletion',
    DailyNutrition: 'DailyNutrition',
    NutritionMeal: 'NutritionMeal',
    NutritionFoodItem: 'NutritionFoodItem',
    NutritionChatUsage: 'NutritionChatUsage',
    FoodItem: 'FoodItem',
    Achievement: 'Achievement',
    AchievementUnlock: 'AchievementUnlock',
    GymUserPreference: 'GymUserPreference',
    GymMembership: 'GymMembership',
    MembershipPlan: 'MembershipPlan',
    DayPass: 'DayPass',
    CheckIn: 'CheckIn',
    Equipment: 'Equipment',
    MaintenanceRecord: 'MaintenanceRecord',
    Payment: 'Payment',
    Expense: 'Expense',
    PaymentMethod: 'PaymentMethod',
    Friendship: 'Friendship',
    Subscription: 'Subscription',
    GymSubscription: 'GymSubscription',
    SubscriptionFeature: 'SubscriptionFeature',
    SubscriptionPayment: 'SubscriptionPayment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "verification" | "student" | "studentProgress" | "studentProfile" | "weightHistory" | "gym" | "gymProfile" | "gymStats" | "unit" | "workout" | "workoutExercise" | "alternativeExercise" | "workoutProgress" | "workoutHistory" | "exerciseLog" | "personalRecord" | "dietPlan" | "meal" | "dietPlanCompletion" | "dailyNutrition" | "nutritionMeal" | "nutritionFoodItem" | "nutritionChatUsage" | "foodItem" | "achievement" | "achievementUnlock" | "gymUserPreference" | "gymMembership" | "membershipPlan" | "dayPass" | "checkIn" | "equipment" | "maintenanceRecord" | "payment" | "expense" | "paymentMethod" | "friendship" | "subscription" | "gymSubscription" | "subscriptionFeature" | "subscriptionPayment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      StudentProgress: {
        payload: Prisma.$StudentProgressPayload<ExtArgs>
        fields: Prisma.StudentProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          findFirst: {
            args: Prisma.StudentProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          findMany: {
            args: Prisma.StudentProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>[]
          }
          create: {
            args: Prisma.StudentProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          createMany: {
            args: Prisma.StudentProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>[]
          }
          delete: {
            args: Prisma.StudentProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          update: {
            args: Prisma.StudentProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          deleteMany: {
            args: Prisma.StudentProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>[]
          }
          upsert: {
            args: Prisma.StudentProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          aggregate: {
            args: Prisma.StudentProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentProgress>
          }
          groupBy: {
            args: Prisma.StudentProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentProgressCountArgs<ExtArgs>
            result: $Utils.Optional<StudentProgressCountAggregateOutputType> | number
          }
        }
      }
      StudentProfile: {
        payload: Prisma.$StudentProfilePayload<ExtArgs>
        fields: Prisma.StudentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findFirst: {
            args: Prisma.StudentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findMany: {
            args: Prisma.StudentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          create: {
            args: Prisma.StudentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          createMany: {
            args: Prisma.StudentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          delete: {
            args: Prisma.StudentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          update: {
            args: Prisma.StudentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          deleteMany: {
            args: Prisma.StudentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          upsert: {
            args: Prisma.StudentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          aggregate: {
            args: Prisma.StudentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentProfile>
          }
          groupBy: {
            args: Prisma.StudentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileCountAggregateOutputType> | number
          }
        }
      }
      WeightHistory: {
        payload: Prisma.$WeightHistoryPayload<ExtArgs>
        fields: Prisma.WeightHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeightHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeightHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>
          }
          findFirst: {
            args: Prisma.WeightHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeightHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>
          }
          findMany: {
            args: Prisma.WeightHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>[]
          }
          create: {
            args: Prisma.WeightHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>
          }
          createMany: {
            args: Prisma.WeightHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeightHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>[]
          }
          delete: {
            args: Prisma.WeightHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>
          }
          update: {
            args: Prisma.WeightHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>
          }
          deleteMany: {
            args: Prisma.WeightHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeightHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeightHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>[]
          }
          upsert: {
            args: Prisma.WeightHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightHistoryPayload>
          }
          aggregate: {
            args: Prisma.WeightHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeightHistory>
          }
          groupBy: {
            args: Prisma.WeightHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeightHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeightHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<WeightHistoryCountAggregateOutputType> | number
          }
        }
      }
      Gym: {
        payload: Prisma.$GymPayload<ExtArgs>
        fields: Prisma.GymFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          findFirst: {
            args: Prisma.GymFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          findMany: {
            args: Prisma.GymFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>[]
          }
          create: {
            args: Prisma.GymCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          createMany: {
            args: Prisma.GymCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>[]
          }
          delete: {
            args: Prisma.GymDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          update: {
            args: Prisma.GymUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          deleteMany: {
            args: Prisma.GymDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>[]
          }
          upsert: {
            args: Prisma.GymUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          aggregate: {
            args: Prisma.GymAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGym>
          }
          groupBy: {
            args: Prisma.GymGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymCountArgs<ExtArgs>
            result: $Utils.Optional<GymCountAggregateOutputType> | number
          }
        }
      }
      GymProfile: {
        payload: Prisma.$GymProfilePayload<ExtArgs>
        fields: Prisma.GymProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>
          }
          findFirst: {
            args: Prisma.GymProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>
          }
          findMany: {
            args: Prisma.GymProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>[]
          }
          create: {
            args: Prisma.GymProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>
          }
          createMany: {
            args: Prisma.GymProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>[]
          }
          delete: {
            args: Prisma.GymProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>
          }
          update: {
            args: Prisma.GymProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>
          }
          deleteMany: {
            args: Prisma.GymProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>[]
          }
          upsert: {
            args: Prisma.GymProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymProfilePayload>
          }
          aggregate: {
            args: Prisma.GymProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymProfile>
          }
          groupBy: {
            args: Prisma.GymProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymProfileCountArgs<ExtArgs>
            result: $Utils.Optional<GymProfileCountAggregateOutputType> | number
          }
        }
      }
      GymStats: {
        payload: Prisma.$GymStatsPayload<ExtArgs>
        fields: Prisma.GymStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>
          }
          findFirst: {
            args: Prisma.GymStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>
          }
          findMany: {
            args: Prisma.GymStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>[]
          }
          create: {
            args: Prisma.GymStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>
          }
          createMany: {
            args: Prisma.GymStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>[]
          }
          delete: {
            args: Prisma.GymStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>
          }
          update: {
            args: Prisma.GymStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>
          }
          deleteMany: {
            args: Prisma.GymStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>[]
          }
          upsert: {
            args: Prisma.GymStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymStatsPayload>
          }
          aggregate: {
            args: Prisma.GymStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymStats>
          }
          groupBy: {
            args: Prisma.GymStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymStatsCountArgs<ExtArgs>
            result: $Utils.Optional<GymStatsCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Workout: {
        payload: Prisma.$WorkoutPayload<ExtArgs>
        fields: Prisma.WorkoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          findFirst: {
            args: Prisma.WorkoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          findMany: {
            args: Prisma.WorkoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          create: {
            args: Prisma.WorkoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          createMany: {
            args: Prisma.WorkoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          delete: {
            args: Prisma.WorkoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          update: {
            args: Prisma.WorkoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          aggregate: {
            args: Prisma.WorkoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkout>
          }
          groupBy: {
            args: Prisma.WorkoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutCountAggregateOutputType> | number
          }
        }
      }
      WorkoutExercise: {
        payload: Prisma.$WorkoutExercisePayload<ExtArgs>
        fields: Prisma.WorkoutExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          findFirst: {
            args: Prisma.WorkoutExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          findMany: {
            args: Prisma.WorkoutExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>[]
          }
          create: {
            args: Prisma.WorkoutExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          createMany: {
            args: Prisma.WorkoutExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>[]
          }
          delete: {
            args: Prisma.WorkoutExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          update: {
            args: Prisma.WorkoutExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          deleteMany: {
            args: Prisma.WorkoutExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>[]
          }
          upsert: {
            args: Prisma.WorkoutExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          aggregate: {
            args: Prisma.WorkoutExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutExercise>
          }
          groupBy: {
            args: Prisma.WorkoutExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutExerciseCountAggregateOutputType> | number
          }
        }
      }
      AlternativeExercise: {
        payload: Prisma.$AlternativeExercisePayload<ExtArgs>
        fields: Prisma.AlternativeExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlternativeExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlternativeExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>
          }
          findFirst: {
            args: Prisma.AlternativeExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlternativeExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>
          }
          findMany: {
            args: Prisma.AlternativeExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>[]
          }
          create: {
            args: Prisma.AlternativeExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>
          }
          createMany: {
            args: Prisma.AlternativeExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlternativeExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>[]
          }
          delete: {
            args: Prisma.AlternativeExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>
          }
          update: {
            args: Prisma.AlternativeExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>
          }
          deleteMany: {
            args: Prisma.AlternativeExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlternativeExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlternativeExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>[]
          }
          upsert: {
            args: Prisma.AlternativeExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativeExercisePayload>
          }
          aggregate: {
            args: Prisma.AlternativeExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlternativeExercise>
          }
          groupBy: {
            args: Prisma.AlternativeExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlternativeExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlternativeExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<AlternativeExerciseCountAggregateOutputType> | number
          }
        }
      }
      WorkoutProgress: {
        payload: Prisma.$WorkoutProgressPayload<ExtArgs>
        fields: Prisma.WorkoutProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>
          }
          findFirst: {
            args: Prisma.WorkoutProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>
          }
          findMany: {
            args: Prisma.WorkoutProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>[]
          }
          create: {
            args: Prisma.WorkoutProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>
          }
          createMany: {
            args: Prisma.WorkoutProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>[]
          }
          delete: {
            args: Prisma.WorkoutProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>
          }
          update: {
            args: Prisma.WorkoutProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutProgressPayload>
          }
          aggregate: {
            args: Prisma.WorkoutProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutProgress>
          }
          groupBy: {
            args: Prisma.WorkoutProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutProgressCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutProgressCountAggregateOutputType> | number
          }
        }
      }
      WorkoutHistory: {
        payload: Prisma.$WorkoutHistoryPayload<ExtArgs>
        fields: Prisma.WorkoutHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>
          }
          findFirst: {
            args: Prisma.WorkoutHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>
          }
          findMany: {
            args: Prisma.WorkoutHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>[]
          }
          create: {
            args: Prisma.WorkoutHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>
          }
          createMany: {
            args: Prisma.WorkoutHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>[]
          }
          delete: {
            args: Prisma.WorkoutHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>
          }
          update: {
            args: Prisma.WorkoutHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>[]
          }
          upsert: {
            args: Prisma.WorkoutHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutHistoryPayload>
          }
          aggregate: {
            args: Prisma.WorkoutHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutHistory>
          }
          groupBy: {
            args: Prisma.WorkoutHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutHistoryCountAggregateOutputType> | number
          }
        }
      }
      ExerciseLog: {
        payload: Prisma.$ExerciseLogPayload<ExtArgs>
        fields: Prisma.ExerciseLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          findFirst: {
            args: Prisma.ExerciseLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          findMany: {
            args: Prisma.ExerciseLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>[]
          }
          create: {
            args: Prisma.ExerciseLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          createMany: {
            args: Prisma.ExerciseLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>[]
          }
          delete: {
            args: Prisma.ExerciseLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          update: {
            args: Prisma.ExerciseLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>[]
          }
          upsert: {
            args: Prisma.ExerciseLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseLogPayload>
          }
          aggregate: {
            args: Prisma.ExerciseLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseLog>
          }
          groupBy: {
            args: Prisma.ExerciseLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseLogCountAggregateOutputType> | number
          }
        }
      }
      PersonalRecord: {
        payload: Prisma.$PersonalRecordPayload<ExtArgs>
        fields: Prisma.PersonalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          findFirst: {
            args: Prisma.PersonalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          findMany: {
            args: Prisma.PersonalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>[]
          }
          create: {
            args: Prisma.PersonalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          createMany: {
            args: Prisma.PersonalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>[]
          }
          delete: {
            args: Prisma.PersonalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          update: {
            args: Prisma.PersonalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          deleteMany: {
            args: Prisma.PersonalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>[]
          }
          upsert: {
            args: Prisma.PersonalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          aggregate: {
            args: Prisma.PersonalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalRecord>
          }
          groupBy: {
            args: Prisma.PersonalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalRecordCountAggregateOutputType> | number
          }
        }
      }
      DietPlan: {
        payload: Prisma.$DietPlanPayload<ExtArgs>
        fields: Prisma.DietPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>
          }
          findFirst: {
            args: Prisma.DietPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>
          }
          findMany: {
            args: Prisma.DietPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>[]
          }
          create: {
            args: Prisma.DietPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>
          }
          createMany: {
            args: Prisma.DietPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>[]
          }
          delete: {
            args: Prisma.DietPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>
          }
          update: {
            args: Prisma.DietPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>
          }
          deleteMany: {
            args: Prisma.DietPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DietPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>[]
          }
          upsert: {
            args: Prisma.DietPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanPayload>
          }
          aggregate: {
            args: Prisma.DietPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDietPlan>
          }
          groupBy: {
            args: Prisma.DietPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietPlanCountArgs<ExtArgs>
            result: $Utils.Optional<DietPlanCountAggregateOutputType> | number
          }
        }
      }
      Meal: {
        payload: Prisma.$MealPayload<ExtArgs>
        fields: Prisma.MealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          findFirst: {
            args: Prisma.MealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          findMany: {
            args: Prisma.MealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          create: {
            args: Prisma.MealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          createMany: {
            args: Prisma.MealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          delete: {
            args: Prisma.MealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          update: {
            args: Prisma.MealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          deleteMany: {
            args: Prisma.MealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MealUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          upsert: {
            args: Prisma.MealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          aggregate: {
            args: Prisma.MealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeal>
          }
          groupBy: {
            args: Prisma.MealGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealCountArgs<ExtArgs>
            result: $Utils.Optional<MealCountAggregateOutputType> | number
          }
        }
      }
      DietPlanCompletion: {
        payload: Prisma.$DietPlanCompletionPayload<ExtArgs>
        fields: Prisma.DietPlanCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietPlanCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietPlanCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>
          }
          findFirst: {
            args: Prisma.DietPlanCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietPlanCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>
          }
          findMany: {
            args: Prisma.DietPlanCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>[]
          }
          create: {
            args: Prisma.DietPlanCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>
          }
          createMany: {
            args: Prisma.DietPlanCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietPlanCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>[]
          }
          delete: {
            args: Prisma.DietPlanCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>
          }
          update: {
            args: Prisma.DietPlanCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>
          }
          deleteMany: {
            args: Prisma.DietPlanCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietPlanCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DietPlanCompletionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>[]
          }
          upsert: {
            args: Prisma.DietPlanCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietPlanCompletionPayload>
          }
          aggregate: {
            args: Prisma.DietPlanCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDietPlanCompletion>
          }
          groupBy: {
            args: Prisma.DietPlanCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietPlanCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietPlanCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<DietPlanCompletionCountAggregateOutputType> | number
          }
        }
      }
      DailyNutrition: {
        payload: Prisma.$DailyNutritionPayload<ExtArgs>
        fields: Prisma.DailyNutritionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyNutritionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyNutritionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>
          }
          findFirst: {
            args: Prisma.DailyNutritionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyNutritionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>
          }
          findMany: {
            args: Prisma.DailyNutritionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>[]
          }
          create: {
            args: Prisma.DailyNutritionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>
          }
          createMany: {
            args: Prisma.DailyNutritionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyNutritionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>[]
          }
          delete: {
            args: Prisma.DailyNutritionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>
          }
          update: {
            args: Prisma.DailyNutritionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>
          }
          deleteMany: {
            args: Prisma.DailyNutritionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyNutritionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyNutritionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>[]
          }
          upsert: {
            args: Prisma.DailyNutritionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyNutritionPayload>
          }
          aggregate: {
            args: Prisma.DailyNutritionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyNutrition>
          }
          groupBy: {
            args: Prisma.DailyNutritionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyNutritionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyNutritionCountArgs<ExtArgs>
            result: $Utils.Optional<DailyNutritionCountAggregateOutputType> | number
          }
        }
      }
      NutritionMeal: {
        payload: Prisma.$NutritionMealPayload<ExtArgs>
        fields: Prisma.NutritionMealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionMealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionMealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>
          }
          findFirst: {
            args: Prisma.NutritionMealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionMealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>
          }
          findMany: {
            args: Prisma.NutritionMealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>[]
          }
          create: {
            args: Prisma.NutritionMealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>
          }
          createMany: {
            args: Prisma.NutritionMealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionMealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>[]
          }
          delete: {
            args: Prisma.NutritionMealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>
          }
          update: {
            args: Prisma.NutritionMealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>
          }
          deleteMany: {
            args: Prisma.NutritionMealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionMealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutritionMealUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>[]
          }
          upsert: {
            args: Prisma.NutritionMealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionMealPayload>
          }
          aggregate: {
            args: Prisma.NutritionMealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionMeal>
          }
          groupBy: {
            args: Prisma.NutritionMealGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionMealGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionMealCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionMealCountAggregateOutputType> | number
          }
        }
      }
      NutritionFoodItem: {
        payload: Prisma.$NutritionFoodItemPayload<ExtArgs>
        fields: Prisma.NutritionFoodItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionFoodItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionFoodItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>
          }
          findFirst: {
            args: Prisma.NutritionFoodItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionFoodItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>
          }
          findMany: {
            args: Prisma.NutritionFoodItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>[]
          }
          create: {
            args: Prisma.NutritionFoodItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>
          }
          createMany: {
            args: Prisma.NutritionFoodItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionFoodItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>[]
          }
          delete: {
            args: Prisma.NutritionFoodItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>
          }
          update: {
            args: Prisma.NutritionFoodItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>
          }
          deleteMany: {
            args: Prisma.NutritionFoodItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionFoodItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutritionFoodItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>[]
          }
          upsert: {
            args: Prisma.NutritionFoodItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionFoodItemPayload>
          }
          aggregate: {
            args: Prisma.NutritionFoodItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionFoodItem>
          }
          groupBy: {
            args: Prisma.NutritionFoodItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionFoodItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionFoodItemCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionFoodItemCountAggregateOutputType> | number
          }
        }
      }
      NutritionChatUsage: {
        payload: Prisma.$NutritionChatUsagePayload<ExtArgs>
        fields: Prisma.NutritionChatUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionChatUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionChatUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>
          }
          findFirst: {
            args: Prisma.NutritionChatUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionChatUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>
          }
          findMany: {
            args: Prisma.NutritionChatUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>[]
          }
          create: {
            args: Prisma.NutritionChatUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>
          }
          createMany: {
            args: Prisma.NutritionChatUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionChatUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>[]
          }
          delete: {
            args: Prisma.NutritionChatUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>
          }
          update: {
            args: Prisma.NutritionChatUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>
          }
          deleteMany: {
            args: Prisma.NutritionChatUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionChatUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutritionChatUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>[]
          }
          upsert: {
            args: Prisma.NutritionChatUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionChatUsagePayload>
          }
          aggregate: {
            args: Prisma.NutritionChatUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionChatUsage>
          }
          groupBy: {
            args: Prisma.NutritionChatUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionChatUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionChatUsageCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionChatUsageCountAggregateOutputType> | number
          }
        }
      }
      FoodItem: {
        payload: Prisma.$FoodItemPayload<ExtArgs>
        fields: Prisma.FoodItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          findFirst: {
            args: Prisma.FoodItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          findMany: {
            args: Prisma.FoodItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>[]
          }
          create: {
            args: Prisma.FoodItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          createMany: {
            args: Prisma.FoodItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>[]
          }
          delete: {
            args: Prisma.FoodItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          update: {
            args: Prisma.FoodItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          deleteMany: {
            args: Prisma.FoodItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>[]
          }
          upsert: {
            args: Prisma.FoodItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          aggregate: {
            args: Prisma.FoodItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodItem>
          }
          groupBy: {
            args: Prisma.FoodItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodItemCountArgs<ExtArgs>
            result: $Utils.Optional<FoodItemCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      AchievementUnlock: {
        payload: Prisma.$AchievementUnlockPayload<ExtArgs>
        fields: Prisma.AchievementUnlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementUnlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementUnlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          findFirst: {
            args: Prisma.AchievementUnlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementUnlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          findMany: {
            args: Prisma.AchievementUnlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>[]
          }
          create: {
            args: Prisma.AchievementUnlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          createMany: {
            args: Prisma.AchievementUnlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementUnlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>[]
          }
          delete: {
            args: Prisma.AchievementUnlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          update: {
            args: Prisma.AchievementUnlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          deleteMany: {
            args: Prisma.AchievementUnlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUnlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUnlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUnlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementUnlockPayload>
          }
          aggregate: {
            args: Prisma.AchievementUnlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievementUnlock>
          }
          groupBy: {
            args: Prisma.AchievementUnlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementUnlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementUnlockCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementUnlockCountAggregateOutputType> | number
          }
        }
      }
      GymUserPreference: {
        payload: Prisma.$GymUserPreferencePayload<ExtArgs>
        fields: Prisma.GymUserPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymUserPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymUserPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>
          }
          findFirst: {
            args: Prisma.GymUserPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymUserPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>
          }
          findMany: {
            args: Prisma.GymUserPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>[]
          }
          create: {
            args: Prisma.GymUserPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>
          }
          createMany: {
            args: Prisma.GymUserPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymUserPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>[]
          }
          delete: {
            args: Prisma.GymUserPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>
          }
          update: {
            args: Prisma.GymUserPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>
          }
          deleteMany: {
            args: Prisma.GymUserPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymUserPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymUserPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>[]
          }
          upsert: {
            args: Prisma.GymUserPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymUserPreferencePayload>
          }
          aggregate: {
            args: Prisma.GymUserPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymUserPreference>
          }
          groupBy: {
            args: Prisma.GymUserPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymUserPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymUserPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<GymUserPreferenceCountAggregateOutputType> | number
          }
        }
      }
      GymMembership: {
        payload: Prisma.$GymMembershipPayload<ExtArgs>
        fields: Prisma.GymMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          findFirst: {
            args: Prisma.GymMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          findMany: {
            args: Prisma.GymMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>[]
          }
          create: {
            args: Prisma.GymMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          createMany: {
            args: Prisma.GymMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>[]
          }
          delete: {
            args: Prisma.GymMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          update: {
            args: Prisma.GymMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          deleteMany: {
            args: Prisma.GymMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>[]
          }
          upsert: {
            args: Prisma.GymMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          aggregate: {
            args: Prisma.GymMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymMembership>
          }
          groupBy: {
            args: Prisma.GymMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<GymMembershipCountAggregateOutputType> | number
          }
        }
      }
      MembershipPlan: {
        payload: Prisma.$MembershipPlanPayload<ExtArgs>
        fields: Prisma.MembershipPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          findFirst: {
            args: Prisma.MembershipPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          findMany: {
            args: Prisma.MembershipPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          create: {
            args: Prisma.MembershipPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          createMany: {
            args: Prisma.MembershipPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          delete: {
            args: Prisma.MembershipPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          update: {
            args: Prisma.MembershipPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          deleteMany: {
            args: Prisma.MembershipPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          upsert: {
            args: Prisma.MembershipPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          aggregate: {
            args: Prisma.MembershipPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipPlan>
          }
          groupBy: {
            args: Prisma.MembershipPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipPlanCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlanCountAggregateOutputType> | number
          }
        }
      }
      DayPass: {
        payload: Prisma.$DayPassPayload<ExtArgs>
        fields: Prisma.DayPassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DayPassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DayPassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>
          }
          findFirst: {
            args: Prisma.DayPassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DayPassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>
          }
          findMany: {
            args: Prisma.DayPassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>[]
          }
          create: {
            args: Prisma.DayPassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>
          }
          createMany: {
            args: Prisma.DayPassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DayPassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>[]
          }
          delete: {
            args: Prisma.DayPassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>
          }
          update: {
            args: Prisma.DayPassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>
          }
          deleteMany: {
            args: Prisma.DayPassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DayPassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DayPassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>[]
          }
          upsert: {
            args: Prisma.DayPassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayPassPayload>
          }
          aggregate: {
            args: Prisma.DayPassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDayPass>
          }
          groupBy: {
            args: Prisma.DayPassGroupByArgs<ExtArgs>
            result: $Utils.Optional<DayPassGroupByOutputType>[]
          }
          count: {
            args: Prisma.DayPassCountArgs<ExtArgs>
            result: $Utils.Optional<DayPassCountAggregateOutputType> | number
          }
        }
      }
      CheckIn: {
        payload: Prisma.$CheckInPayload<ExtArgs>
        fields: Prisma.CheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          findFirst: {
            args: Prisma.CheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          findMany: {
            args: Prisma.CheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          create: {
            args: Prisma.CheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          createMany: {
            args: Prisma.CheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          delete: {
            args: Prisma.CheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          update: {
            args: Prisma.CheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          deleteMany: {
            args: Prisma.CheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CheckInUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          upsert: {
            args: Prisma.CheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          aggregate: {
            args: Prisma.CheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckIn>
          }
          groupBy: {
            args: Prisma.CheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckInCountArgs<ExtArgs>
            result: $Utils.Optional<CheckInCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceRecord: {
        payload: Prisma.$MaintenanceRecordPayload<ExtArgs>
        fields: Prisma.MaintenanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>
          }
          findMany: {
            args: Prisma.MaintenanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>[]
          }
          create: {
            args: Prisma.MaintenanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>
          }
          createMany: {
            args: Prisma.MaintenanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>
          }
          update: {
            args: Prisma.MaintenanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRecordPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceRecord>
          }
          groupBy: {
            args: Prisma.MaintenanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRecordCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      GymSubscription: {
        payload: Prisma.$GymSubscriptionPayload<ExtArgs>
        fields: Prisma.GymSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.GymSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          findMany: {
            args: Prisma.GymSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>[]
          }
          create: {
            args: Prisma.GymSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          createMany: {
            args: Prisma.GymSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.GymSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          update: {
            args: Prisma.GymSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.GymSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.GymSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.GymSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymSubscription>
          }
          groupBy: {
            args: Prisma.GymSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<GymSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionFeature: {
        payload: Prisma.$SubscriptionFeaturePayload<ExtArgs>
        fields: Prisma.SubscriptionFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>
          }
          findMany: {
            args: Prisma.SubscriptionFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>[]
          }
          create: {
            args: Prisma.SubscriptionFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>
          }
          createMany: {
            args: Prisma.SubscriptionFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>[]
          }
          delete: {
            args: Prisma.SubscriptionFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>
          }
          update: {
            args: Prisma.SubscriptionFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionFeaturePayload>
          }
          aggregate: {
            args: Prisma.SubscriptionFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionFeature>
          }
          groupBy: {
            args: Prisma.SubscriptionFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionFeatureCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPayment: {
        payload: Prisma.$SubscriptionPaymentPayload<ExtArgs>
        fields: Prisma.SubscriptionPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          update: {
            args: Prisma.SubscriptionPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPayment>
          }
          groupBy: {
            args: Prisma.SubscriptionPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    verification?: VerificationOmit
    student?: StudentOmit
    studentProgress?: StudentProgressOmit
    studentProfile?: StudentProfileOmit
    weightHistory?: WeightHistoryOmit
    gym?: GymOmit
    gymProfile?: GymProfileOmit
    gymStats?: GymStatsOmit
    unit?: UnitOmit
    workout?: WorkoutOmit
    workoutExercise?: WorkoutExerciseOmit
    alternativeExercise?: AlternativeExerciseOmit
    workoutProgress?: WorkoutProgressOmit
    workoutHistory?: WorkoutHistoryOmit
    exerciseLog?: ExerciseLogOmit
    personalRecord?: PersonalRecordOmit
    dietPlan?: DietPlanOmit
    meal?: MealOmit
    dietPlanCompletion?: DietPlanCompletionOmit
    dailyNutrition?: DailyNutritionOmit
    nutritionMeal?: NutritionMealOmit
    nutritionFoodItem?: NutritionFoodItemOmit
    nutritionChatUsage?: NutritionChatUsageOmit
    foodItem?: FoodItemOmit
    achievement?: AchievementOmit
    achievementUnlock?: AchievementUnlockOmit
    gymUserPreference?: GymUserPreferenceOmit
    gymMembership?: GymMembershipOmit
    membershipPlan?: MembershipPlanOmit
    dayPass?: DayPassOmit
    checkIn?: CheckInOmit
    equipment?: EquipmentOmit
    maintenanceRecord?: MaintenanceRecordOmit
    payment?: PaymentOmit
    expense?: ExpenseOmit
    paymentMethod?: PaymentMethodOmit
    friendship?: FriendshipOmit
    subscription?: SubscriptionOmit
    gymSubscription?: GymSubscriptionOmit
    subscriptionFeature?: SubscriptionFeatureOmit
    subscriptionPayment?: SubscriptionPaymentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    gyms: number
    accounts: number
    sessions: number
    paymentMethods: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gyms?: boolean | UserCountOutputTypeCountGymsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    paymentMethods?: boolean | UserCountOutputTypeCountPaymentMethodsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGymsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    workouts: number
    workoutProgress: number
    records: number
    diets: number
    achievements: number
    weightHistory: number
    dailyNutrition: number
    nutritionChatUsage: number
    units: number
    memberships: number
    dayPasses: number
    friends: number
    friendOf: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workouts?: boolean | StudentCountOutputTypeCountWorkoutsArgs
    workoutProgress?: boolean | StudentCountOutputTypeCountWorkoutProgressArgs
    records?: boolean | StudentCountOutputTypeCountRecordsArgs
    diets?: boolean | StudentCountOutputTypeCountDietsArgs
    achievements?: boolean | StudentCountOutputTypeCountAchievementsArgs
    weightHistory?: boolean | StudentCountOutputTypeCountWeightHistoryArgs
    dailyNutrition?: boolean | StudentCountOutputTypeCountDailyNutritionArgs
    nutritionChatUsage?: boolean | StudentCountOutputTypeCountNutritionChatUsageArgs
    units?: boolean | StudentCountOutputTypeCountUnitsArgs
    memberships?: boolean | StudentCountOutputTypeCountMembershipsArgs
    dayPasses?: boolean | StudentCountOutputTypeCountDayPassesArgs
    friends?: boolean | StudentCountOutputTypeCountFriendsArgs
    friendOf?: boolean | StudentCountOutputTypeCountFriendOfArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutHistoryWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountWorkoutProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutProgressWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDietsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietPlanCompletionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementUnlockWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountWeightHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeightHistoryWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDailyNutritionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyNutritionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountNutritionChatUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionChatUsageWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymMembershipWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDayPassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayPassWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFriendOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }


  /**
   * Count Type GymCountOutputType
   */

  export type GymCountOutputType = {
    students: number
    equipment: number
    plans: number
    payments: number
    expenses: number
    checkIns: number
  }

  export type GymCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | GymCountOutputTypeCountStudentsArgs
    equipment?: boolean | GymCountOutputTypeCountEquipmentArgs
    plans?: boolean | GymCountOutputTypeCountPlansArgs
    payments?: boolean | GymCountOutputTypeCountPaymentsArgs
    expenses?: boolean | GymCountOutputTypeCountExpensesArgs
    checkIns?: boolean | GymCountOutputTypeCountCheckInsArgs
  }

  // Custom InputTypes
  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCountOutputType
     */
    select?: GymCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymMembershipWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipPlanWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    workouts: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workouts?: boolean | UnitCountOutputTypeCountWorkoutsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutWhereInput
  }


  /**
   * Count Type WorkoutCountOutputType
   */

  export type WorkoutCountOutputType = {
    exercises: number
    completions: number
    progress: number
  }

  export type WorkoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | WorkoutCountOutputTypeCountExercisesArgs
    completions?: boolean | WorkoutCountOutputTypeCountCompletionsArgs
    progress?: boolean | WorkoutCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutCountOutputType
     */
    select?: WorkoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutExerciseWhereInput
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutHistoryWhereInput
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutProgressWhereInput
  }


  /**
   * Count Type WorkoutExerciseCountOutputType
   */

  export type WorkoutExerciseCountOutputType = {
    alternatives: number
  }

  export type WorkoutExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alternatives?: boolean | WorkoutExerciseCountOutputTypeCountAlternativesArgs
  }

  // Custom InputTypes
  /**
   * WorkoutExerciseCountOutputType without action
   */
  export type WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExerciseCountOutputType
     */
    select?: WorkoutExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutExerciseCountOutputType without action
   */
  export type WorkoutExerciseCountOutputTypeCountAlternativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternativeExerciseWhereInput
  }


  /**
   * Count Type WorkoutHistoryCountOutputType
   */

  export type WorkoutHistoryCountOutputType = {
    exercises: number
    records: number
  }

  export type WorkoutHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | WorkoutHistoryCountOutputTypeCountExercisesArgs
    records?: boolean | WorkoutHistoryCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * WorkoutHistoryCountOutputType without action
   */
  export type WorkoutHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistoryCountOutputType
     */
    select?: WorkoutHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutHistoryCountOutputType without action
   */
  export type WorkoutHistoryCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseLogWhereInput
  }

  /**
   * WorkoutHistoryCountOutputType without action
   */
  export type WorkoutHistoryCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalRecordWhereInput
  }


  /**
   * Count Type DietPlanCountOutputType
   */

  export type DietPlanCountOutputType = {
    meals: number
    completions: number
  }

  export type DietPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meals?: boolean | DietPlanCountOutputTypeCountMealsArgs
    completions?: boolean | DietPlanCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * DietPlanCountOutputType without action
   */
  export type DietPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCountOutputType
     */
    select?: DietPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DietPlanCountOutputType without action
   */
  export type DietPlanCountOutputTypeCountMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
  }

  /**
   * DietPlanCountOutputType without action
   */
  export type DietPlanCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietPlanCompletionWhereInput
  }


  /**
   * Count Type DailyNutritionCountOutputType
   */

  export type DailyNutritionCountOutputType = {
    meals: number
  }

  export type DailyNutritionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meals?: boolean | DailyNutritionCountOutputTypeCountMealsArgs
  }

  // Custom InputTypes
  /**
   * DailyNutritionCountOutputType without action
   */
  export type DailyNutritionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutritionCountOutputType
     */
    select?: DailyNutritionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailyNutritionCountOutputType without action
   */
  export type DailyNutritionCountOutputTypeCountMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionMealWhereInput
  }


  /**
   * Count Type NutritionMealCountOutputType
   */

  export type NutritionMealCountOutputType = {
    foods: number
  }

  export type NutritionMealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foods?: boolean | NutritionMealCountOutputTypeCountFoodsArgs
  }

  // Custom InputTypes
  /**
   * NutritionMealCountOutputType without action
   */
  export type NutritionMealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMealCountOutputType
     */
    select?: NutritionMealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NutritionMealCountOutputType without action
   */
  export type NutritionMealCountOutputTypeCountFoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionFoodItemWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    unlocks: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlocks?: boolean | AchievementCountOutputTypeCountUnlocksArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUnlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementUnlockWhereInput
  }


  /**
   * Count Type MembershipPlanCountOutputType
   */

  export type MembershipPlanCountOutputType = {
    memberships: number
    payments: number
  }

  export type MembershipPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | MembershipPlanCountOutputTypeCountMembershipsArgs
    payments?: boolean | MembershipPlanCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlanCountOutputType
     */
    select?: MembershipPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymMembershipWhereInput
  }

  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    maintenanceHistory: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceHistory?: boolean | EquipmentCountOutputTypeCountMaintenanceHistoryArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountMaintenanceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    activeGymId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    activeGymId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    emailVerified: number
    image: number
    role: number
    createdAt: number
    updatedAt: number
    activeGymId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    activeGymId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    activeGymId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    activeGymId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    activeGymId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activeGymId?: boolean
    student?: boolean | User$studentArgs<ExtArgs>
    gyms?: boolean | User$gymsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    gymPreference?: boolean | User$gymPreferenceArgs<ExtArgs>
    paymentMethods?: boolean | User$paymentMethodsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activeGymId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activeGymId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activeGymId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "emailVerified" | "image" | "role" | "createdAt" | "updatedAt" | "activeGymId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | User$studentArgs<ExtArgs>
    gyms?: boolean | User$gymsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    gymPreference?: boolean | User$gymPreferenceArgs<ExtArgs>
    paymentMethods?: boolean | User$paymentMethodsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      gyms: Prisma.$GymPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      gymPreference: Prisma.$GymUserPreferencePayload<ExtArgs> | null
      paymentMethods: Prisma.$PaymentMethodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string
      emailVerified: boolean | null
      image: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
      activeGymId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gyms<T extends User$gymsArgs<ExtArgs> = {}>(args?: Subset<T, User$gymsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gymPreference<T extends User$gymPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$gymPreferenceArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paymentMethods<T extends User$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly activeGymId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.gyms
   */
  export type User$gymsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    where?: GymWhereInput
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    cursor?: GymWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.gymPreference
   */
  export type User$gymPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    where?: GymUserPreferenceWhereInput
  }

  /**
   * User.paymentMethods
   */
  export type User$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    cursor?: PaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    idToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    idToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    accessTokenExpiresAt: number
    idToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    idToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    idToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    idToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    idToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    idToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    idToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    idToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    idToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "accessTokenExpiresAt" | "idToken" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string | null
      provider: string | null
      providerAccountId: string | null
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      accountId: string | null
      providerId: string | null
      accessToken: string | null
      refreshToken: string | null
      accessTokenExpiresAt: Date | null
      idToken: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionToken: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionToken: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    sessionToken: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    sessionToken?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    sessionToken?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    sessionToken?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    sessionToken: string | null
    expires: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionToken?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt" | "sessionToken" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
      sessionToken: string | null
      expires: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    age: number | null
  }

  export type StudentSumAggregateOutputType = {
    age: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    age: number | null
    gender: string | null
    phone: string | null
    avatar: string | null
    isTrans: boolean | null
    usesHormones: boolean | null
    hormoneType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    age: number | null
    gender: string | null
    phone: string | null
    avatar: string | null
    isTrans: boolean | null
    usesHormones: boolean | null
    hormoneType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    age: number
    gender: number
    phone: number
    avatar: number
    isTrans: number
    usesHormones: number
    hormoneType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    age?: true
  }

  export type StudentSumAggregateInputType = {
    age?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    age?: true
    gender?: true
    phone?: true
    avatar?: true
    isTrans?: true
    usesHormones?: true
    hormoneType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    age?: true
    gender?: true
    phone?: true
    avatar?: true
    isTrans?: true
    usesHormones?: true
    hormoneType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    age?: true
    gender?: true
    phone?: true
    avatar?: true
    isTrans?: true
    usesHormones?: true
    hormoneType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    age: number | null
    gender: string | null
    phone: string | null
    avatar: string | null
    isTrans: boolean | null
    usesHormones: boolean | null
    hormoneType: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    age?: boolean
    gender?: boolean
    phone?: boolean
    avatar?: boolean
    isTrans?: boolean
    usesHormones?: boolean
    hormoneType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    progress?: boolean | Student$progressArgs<ExtArgs>
    profile?: boolean | Student$profileArgs<ExtArgs>
    workouts?: boolean | Student$workoutsArgs<ExtArgs>
    workoutProgress?: boolean | Student$workoutProgressArgs<ExtArgs>
    records?: boolean | Student$recordsArgs<ExtArgs>
    diets?: boolean | Student$dietsArgs<ExtArgs>
    achievements?: boolean | Student$achievementsArgs<ExtArgs>
    weightHistory?: boolean | Student$weightHistoryArgs<ExtArgs>
    dailyNutrition?: boolean | Student$dailyNutritionArgs<ExtArgs>
    nutritionChatUsage?: boolean | Student$nutritionChatUsageArgs<ExtArgs>
    units?: boolean | Student$unitsArgs<ExtArgs>
    memberships?: boolean | Student$membershipsArgs<ExtArgs>
    dayPasses?: boolean | Student$dayPassesArgs<ExtArgs>
    friends?: boolean | Student$friendsArgs<ExtArgs>
    friendOf?: boolean | Student$friendOfArgs<ExtArgs>
    subscription?: boolean | Student$subscriptionArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    age?: boolean
    gender?: boolean
    phone?: boolean
    avatar?: boolean
    isTrans?: boolean
    usesHormones?: boolean
    hormoneType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    age?: boolean
    gender?: boolean
    phone?: boolean
    avatar?: boolean
    isTrans?: boolean
    usesHormones?: boolean
    hormoneType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    age?: boolean
    gender?: boolean
    phone?: boolean
    avatar?: boolean
    isTrans?: boolean
    usesHormones?: boolean
    hormoneType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "age" | "gender" | "phone" | "avatar" | "isTrans" | "usesHormones" | "hormoneType" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    progress?: boolean | Student$progressArgs<ExtArgs>
    profile?: boolean | Student$profileArgs<ExtArgs>
    workouts?: boolean | Student$workoutsArgs<ExtArgs>
    workoutProgress?: boolean | Student$workoutProgressArgs<ExtArgs>
    records?: boolean | Student$recordsArgs<ExtArgs>
    diets?: boolean | Student$dietsArgs<ExtArgs>
    achievements?: boolean | Student$achievementsArgs<ExtArgs>
    weightHistory?: boolean | Student$weightHistoryArgs<ExtArgs>
    dailyNutrition?: boolean | Student$dailyNutritionArgs<ExtArgs>
    nutritionChatUsage?: boolean | Student$nutritionChatUsageArgs<ExtArgs>
    units?: boolean | Student$unitsArgs<ExtArgs>
    memberships?: boolean | Student$membershipsArgs<ExtArgs>
    dayPasses?: boolean | Student$dayPassesArgs<ExtArgs>
    friends?: boolean | Student$friendsArgs<ExtArgs>
    friendOf?: boolean | Student$friendOfArgs<ExtArgs>
    subscription?: boolean | Student$subscriptionArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      progress: Prisma.$StudentProgressPayload<ExtArgs> | null
      profile: Prisma.$StudentProfilePayload<ExtArgs> | null
      workouts: Prisma.$WorkoutHistoryPayload<ExtArgs>[]
      workoutProgress: Prisma.$WorkoutProgressPayload<ExtArgs>[]
      records: Prisma.$PersonalRecordPayload<ExtArgs>[]
      diets: Prisma.$DietPlanCompletionPayload<ExtArgs>[]
      achievements: Prisma.$AchievementUnlockPayload<ExtArgs>[]
      weightHistory: Prisma.$WeightHistoryPayload<ExtArgs>[]
      dailyNutrition: Prisma.$DailyNutritionPayload<ExtArgs>[]
      nutritionChatUsage: Prisma.$NutritionChatUsagePayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      memberships: Prisma.$GymMembershipPayload<ExtArgs>[]
      dayPasses: Prisma.$DayPassPayload<ExtArgs>[]
      friends: Prisma.$FriendshipPayload<ExtArgs>[]
      friendOf: Prisma.$FriendshipPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      age: number | null
      gender: string | null
      phone: string | null
      avatar: string | null
      isTrans: boolean | null
      usesHormones: boolean | null
      hormoneType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    progress<T extends Student$progressArgs<ExtArgs> = {}>(args?: Subset<T, Student$progressArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends Student$profileArgs<ExtArgs> = {}>(args?: Subset<T, Student$profileArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workouts<T extends Student$workoutsArgs<ExtArgs> = {}>(args?: Subset<T, Student$workoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workoutProgress<T extends Student$workoutProgressArgs<ExtArgs> = {}>(args?: Subset<T, Student$workoutProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    records<T extends Student$recordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diets<T extends Student$dietsArgs<ExtArgs> = {}>(args?: Subset<T, Student$dietsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends Student$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Student$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weightHistory<T extends Student$weightHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Student$weightHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyNutrition<T extends Student$dailyNutritionArgs<ExtArgs> = {}>(args?: Subset<T, Student$dailyNutritionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nutritionChatUsage<T extends Student$nutritionChatUsageArgs<ExtArgs> = {}>(args?: Subset<T, Student$nutritionChatUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Student$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Student$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends Student$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Student$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dayPasses<T extends Student$dayPassesArgs<ExtArgs> = {}>(args?: Subset<T, Student$dayPassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friends<T extends Student$friendsArgs<ExtArgs> = {}>(args?: Subset<T, Student$friendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendOf<T extends Student$friendOfArgs<ExtArgs> = {}>(args?: Subset<T, Student$friendOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Student$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Student$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly age: FieldRef<"Student", 'Int'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly phone: FieldRef<"Student", 'String'>
    readonly avatar: FieldRef<"Student", 'String'>
    readonly isTrans: FieldRef<"Student", 'Boolean'>
    readonly usesHormones: FieldRef<"Student", 'Boolean'>
    readonly hormoneType: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.progress
   */
  export type Student$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    where?: StudentProgressWhereInput
  }

  /**
   * Student.profile
   */
  export type Student$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * Student.workouts
   */
  export type Student$workoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    where?: WorkoutHistoryWhereInput
    orderBy?: WorkoutHistoryOrderByWithRelationInput | WorkoutHistoryOrderByWithRelationInput[]
    cursor?: WorkoutHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutHistoryScalarFieldEnum | WorkoutHistoryScalarFieldEnum[]
  }

  /**
   * Student.workoutProgress
   */
  export type Student$workoutProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    where?: WorkoutProgressWhereInput
    orderBy?: WorkoutProgressOrderByWithRelationInput | WorkoutProgressOrderByWithRelationInput[]
    cursor?: WorkoutProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutProgressScalarFieldEnum | WorkoutProgressScalarFieldEnum[]
  }

  /**
   * Student.records
   */
  export type Student$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    where?: PersonalRecordWhereInput
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    cursor?: PersonalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * Student.diets
   */
  export type Student$dietsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    where?: DietPlanCompletionWhereInput
    orderBy?: DietPlanCompletionOrderByWithRelationInput | DietPlanCompletionOrderByWithRelationInput[]
    cursor?: DietPlanCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietPlanCompletionScalarFieldEnum | DietPlanCompletionScalarFieldEnum[]
  }

  /**
   * Student.achievements
   */
  export type Student$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    where?: AchievementUnlockWhereInput
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    cursor?: AchievementUnlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * Student.weightHistory
   */
  export type Student$weightHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    where?: WeightHistoryWhereInput
    orderBy?: WeightHistoryOrderByWithRelationInput | WeightHistoryOrderByWithRelationInput[]
    cursor?: WeightHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeightHistoryScalarFieldEnum | WeightHistoryScalarFieldEnum[]
  }

  /**
   * Student.dailyNutrition
   */
  export type Student$dailyNutritionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    where?: DailyNutritionWhereInput
    orderBy?: DailyNutritionOrderByWithRelationInput | DailyNutritionOrderByWithRelationInput[]
    cursor?: DailyNutritionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyNutritionScalarFieldEnum | DailyNutritionScalarFieldEnum[]
  }

  /**
   * Student.nutritionChatUsage
   */
  export type Student$nutritionChatUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    where?: NutritionChatUsageWhereInput
    orderBy?: NutritionChatUsageOrderByWithRelationInput | NutritionChatUsageOrderByWithRelationInput[]
    cursor?: NutritionChatUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutritionChatUsageScalarFieldEnum | NutritionChatUsageScalarFieldEnum[]
  }

  /**
   * Student.units
   */
  export type Student$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Student.memberships
   */
  export type Student$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    where?: GymMembershipWhereInput
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    cursor?: GymMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * Student.dayPasses
   */
  export type Student$dayPassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    where?: DayPassWhereInput
    orderBy?: DayPassOrderByWithRelationInput | DayPassOrderByWithRelationInput[]
    cursor?: DayPassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DayPassScalarFieldEnum | DayPassScalarFieldEnum[]
  }

  /**
   * Student.friends
   */
  export type Student$friendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Student.friendOf
   */
  export type Student$friendOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Student.subscription
   */
  export type Student$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model StudentProgress
   */

  export type AggregateStudentProgress = {
    _count: StudentProgressCountAggregateOutputType | null
    _avg: StudentProgressAvgAggregateOutputType | null
    _sum: StudentProgressSumAggregateOutputType | null
    _min: StudentProgressMinAggregateOutputType | null
    _max: StudentProgressMaxAggregateOutputType | null
  }

  export type StudentProgressAvgAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    workoutsCompleted: number | null
    dailyGoalXP: number | null
    todayXP: number | null
  }

  export type StudentProgressSumAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    workoutsCompleted: number | null
    dailyGoalXP: number | null
    todayXP: number | null
  }

  export type StudentProgressMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    currentStreak: number | null
    longestStreak: number | null
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    workoutsCompleted: number | null
    lastActivityDate: Date | null
    dailyGoalXP: number | null
    todayXP: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProgressMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    currentStreak: number | null
    longestStreak: number | null
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    workoutsCompleted: number | null
    lastActivityDate: Date | null
    dailyGoalXP: number | null
    todayXP: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProgressCountAggregateOutputType = {
    id: number
    studentId: number
    currentStreak: number
    longestStreak: number
    totalXP: number
    currentLevel: number
    xpToNextLevel: number
    workoutsCompleted: number
    lastActivityDate: number
    dailyGoalXP: number
    todayXP: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentProgressAvgAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    workoutsCompleted?: true
    dailyGoalXP?: true
    todayXP?: true
  }

  export type StudentProgressSumAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    workoutsCompleted?: true
    dailyGoalXP?: true
    todayXP?: true
  }

  export type StudentProgressMinAggregateInputType = {
    id?: true
    studentId?: true
    currentStreak?: true
    longestStreak?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    workoutsCompleted?: true
    lastActivityDate?: true
    dailyGoalXP?: true
    todayXP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProgressMaxAggregateInputType = {
    id?: true
    studentId?: true
    currentStreak?: true
    longestStreak?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    workoutsCompleted?: true
    lastActivityDate?: true
    dailyGoalXP?: true
    todayXP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProgressCountAggregateInputType = {
    id?: true
    studentId?: true
    currentStreak?: true
    longestStreak?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    workoutsCompleted?: true
    lastActivityDate?: true
    dailyGoalXP?: true
    todayXP?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProgress to aggregate.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentProgresses
    **/
    _count?: true | StudentProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentProgressMaxAggregateInputType
  }

  export type GetStudentProgressAggregateType<T extends StudentProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentProgress[P]>
      : GetScalarType<T[P], AggregateStudentProgress[P]>
  }




  export type StudentProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProgressWhereInput
    orderBy?: StudentProgressOrderByWithAggregationInput | StudentProgressOrderByWithAggregationInput[]
    by: StudentProgressScalarFieldEnum[] | StudentProgressScalarFieldEnum
    having?: StudentProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentProgressCountAggregateInputType | true
    _avg?: StudentProgressAvgAggregateInputType
    _sum?: StudentProgressSumAggregateInputType
    _min?: StudentProgressMinAggregateInputType
    _max?: StudentProgressMaxAggregateInputType
  }

  export type StudentProgressGroupByOutputType = {
    id: string
    studentId: string
    currentStreak: number
    longestStreak: number
    totalXP: number
    currentLevel: number
    xpToNextLevel: number
    workoutsCompleted: number
    lastActivityDate: Date | null
    dailyGoalXP: number
    todayXP: number
    createdAt: Date
    updatedAt: Date
    _count: StudentProgressCountAggregateOutputType | null
    _avg: StudentProgressAvgAggregateOutputType | null
    _sum: StudentProgressSumAggregateOutputType | null
    _min: StudentProgressMinAggregateOutputType | null
    _max: StudentProgressMaxAggregateOutputType | null
  }

  type GetStudentProgressGroupByPayload<T extends StudentProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentProgressGroupByOutputType[P]>
            : GetScalarType<T[P], StudentProgressGroupByOutputType[P]>
        }
      >
    >


  export type StudentProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    workoutsCompleted?: boolean
    lastActivityDate?: boolean
    dailyGoalXP?: boolean
    todayXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProgress"]>

  export type StudentProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    workoutsCompleted?: boolean
    lastActivityDate?: boolean
    dailyGoalXP?: boolean
    todayXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProgress"]>

  export type StudentProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    workoutsCompleted?: boolean
    lastActivityDate?: boolean
    dailyGoalXP?: boolean
    todayXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProgress"]>

  export type StudentProgressSelectScalar = {
    id?: boolean
    studentId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    workoutsCompleted?: boolean
    lastActivityDate?: boolean
    dailyGoalXP?: boolean
    todayXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "currentStreak" | "longestStreak" | "totalXP" | "currentLevel" | "xpToNextLevel" | "workoutsCompleted" | "lastActivityDate" | "dailyGoalXP" | "todayXP" | "createdAt" | "updatedAt", ExtArgs["result"]["studentProgress"]>
  export type StudentProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentProgress"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      currentStreak: number
      longestStreak: number
      totalXP: number
      currentLevel: number
      xpToNextLevel: number
      workoutsCompleted: number
      lastActivityDate: Date | null
      dailyGoalXP: number
      todayXP: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentProgress"]>
    composites: {}
  }

  type StudentProgressGetPayload<S extends boolean | null | undefined | StudentProgressDefaultArgs> = $Result.GetResult<Prisma.$StudentProgressPayload, S>

  type StudentProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentProgressCountAggregateInputType | true
    }

  export interface StudentProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentProgress'], meta: { name: 'StudentProgress' } }
    /**
     * Find zero or one StudentProgress that matches the filter.
     * @param {StudentProgressFindUniqueArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentProgressFindUniqueArgs>(args: SelectSubset<T, StudentProgressFindUniqueArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentProgressFindUniqueOrThrowArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressFindFirstArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentProgressFindFirstArgs>(args?: SelectSubset<T, StudentProgressFindFirstArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressFindFirstOrThrowArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentProgresses
     * const studentProgresses = await prisma.studentProgress.findMany()
     * 
     * // Get first 10 StudentProgresses
     * const studentProgresses = await prisma.studentProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentProgressWithIdOnly = await prisma.studentProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentProgressFindManyArgs>(args?: SelectSubset<T, StudentProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentProgress.
     * @param {StudentProgressCreateArgs} args - Arguments to create a StudentProgress.
     * @example
     * // Create one StudentProgress
     * const StudentProgress = await prisma.studentProgress.create({
     *   data: {
     *     // ... data to create a StudentProgress
     *   }
     * })
     * 
     */
    create<T extends StudentProgressCreateArgs>(args: SelectSubset<T, StudentProgressCreateArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentProgresses.
     * @param {StudentProgressCreateManyArgs} args - Arguments to create many StudentProgresses.
     * @example
     * // Create many StudentProgresses
     * const studentProgress = await prisma.studentProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentProgressCreateManyArgs>(args?: SelectSubset<T, StudentProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentProgresses and returns the data saved in the database.
     * @param {StudentProgressCreateManyAndReturnArgs} args - Arguments to create many StudentProgresses.
     * @example
     * // Create many StudentProgresses
     * const studentProgress = await prisma.studentProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentProgresses and only return the `id`
     * const studentProgressWithIdOnly = await prisma.studentProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentProgress.
     * @param {StudentProgressDeleteArgs} args - Arguments to delete one StudentProgress.
     * @example
     * // Delete one StudentProgress
     * const StudentProgress = await prisma.studentProgress.delete({
     *   where: {
     *     // ... filter to delete one StudentProgress
     *   }
     * })
     * 
     */
    delete<T extends StudentProgressDeleteArgs>(args: SelectSubset<T, StudentProgressDeleteArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentProgress.
     * @param {StudentProgressUpdateArgs} args - Arguments to update one StudentProgress.
     * @example
     * // Update one StudentProgress
     * const studentProgress = await prisma.studentProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentProgressUpdateArgs>(args: SelectSubset<T, StudentProgressUpdateArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentProgresses.
     * @param {StudentProgressDeleteManyArgs} args - Arguments to filter StudentProgresses to delete.
     * @example
     * // Delete a few StudentProgresses
     * const { count } = await prisma.studentProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentProgressDeleteManyArgs>(args?: SelectSubset<T, StudentProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentProgresses
     * const studentProgress = await prisma.studentProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentProgressUpdateManyArgs>(args: SelectSubset<T, StudentProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProgresses and returns the data updated in the database.
     * @param {StudentProgressUpdateManyAndReturnArgs} args - Arguments to update many StudentProgresses.
     * @example
     * // Update many StudentProgresses
     * const studentProgress = await prisma.studentProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentProgresses and only return the `id`
     * const studentProgressWithIdOnly = await prisma.studentProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentProgress.
     * @param {StudentProgressUpsertArgs} args - Arguments to update or create a StudentProgress.
     * @example
     * // Update or create a StudentProgress
     * const studentProgress = await prisma.studentProgress.upsert({
     *   create: {
     *     // ... data to create a StudentProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentProgress we want to update
     *   }
     * })
     */
    upsert<T extends StudentProgressUpsertArgs>(args: SelectSubset<T, StudentProgressUpsertArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressCountArgs} args - Arguments to filter StudentProgresses to count.
     * @example
     * // Count the number of StudentProgresses
     * const count = await prisma.studentProgress.count({
     *   where: {
     *     // ... the filter for the StudentProgresses we want to count
     *   }
     * })
    **/
    count<T extends StudentProgressCountArgs>(
      args?: Subset<T, StudentProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentProgressAggregateArgs>(args: Subset<T, StudentProgressAggregateArgs>): Prisma.PrismaPromise<GetStudentProgressAggregateType<T>>

    /**
     * Group by StudentProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentProgressGroupByArgs['orderBy'] }
        : { orderBy?: StudentProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentProgress model
   */
  readonly fields: StudentProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentProgress model
   */
  interface StudentProgressFieldRefs {
    readonly id: FieldRef<"StudentProgress", 'String'>
    readonly studentId: FieldRef<"StudentProgress", 'String'>
    readonly currentStreak: FieldRef<"StudentProgress", 'Int'>
    readonly longestStreak: FieldRef<"StudentProgress", 'Int'>
    readonly totalXP: FieldRef<"StudentProgress", 'Int'>
    readonly currentLevel: FieldRef<"StudentProgress", 'Int'>
    readonly xpToNextLevel: FieldRef<"StudentProgress", 'Int'>
    readonly workoutsCompleted: FieldRef<"StudentProgress", 'Int'>
    readonly lastActivityDate: FieldRef<"StudentProgress", 'DateTime'>
    readonly dailyGoalXP: FieldRef<"StudentProgress", 'Int'>
    readonly todayXP: FieldRef<"StudentProgress", 'Int'>
    readonly createdAt: FieldRef<"StudentProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentProgress findUnique
   */
  export type StudentProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress findUniqueOrThrow
   */
  export type StudentProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress findFirst
   */
  export type StudentProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProgresses.
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProgresses.
     */
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentProgress findFirstOrThrow
   */
  export type StudentProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProgresses.
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProgresses.
     */
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentProgress findMany
   */
  export type StudentProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgresses to fetch.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentProgresses.
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentProgress create
   */
  export type StudentProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentProgress.
     */
    data: XOR<StudentProgressCreateInput, StudentProgressUncheckedCreateInput>
  }

  /**
   * StudentProgress createMany
   */
  export type StudentProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentProgresses.
     */
    data: StudentProgressCreateManyInput | StudentProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentProgress createManyAndReturn
   */
  export type StudentProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * The data used to create many StudentProgresses.
     */
    data: StudentProgressCreateManyInput | StudentProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProgress update
   */
  export type StudentProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentProgress.
     */
    data: XOR<StudentProgressUpdateInput, StudentProgressUncheckedUpdateInput>
    /**
     * Choose, which StudentProgress to update.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress updateMany
   */
  export type StudentProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentProgresses.
     */
    data: XOR<StudentProgressUpdateManyMutationInput, StudentProgressUncheckedUpdateManyInput>
    /**
     * Filter which StudentProgresses to update
     */
    where?: StudentProgressWhereInput
    /**
     * Limit how many StudentProgresses to update.
     */
    limit?: number
  }

  /**
   * StudentProgress updateManyAndReturn
   */
  export type StudentProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * The data used to update StudentProgresses.
     */
    data: XOR<StudentProgressUpdateManyMutationInput, StudentProgressUncheckedUpdateManyInput>
    /**
     * Filter which StudentProgresses to update
     */
    where?: StudentProgressWhereInput
    /**
     * Limit how many StudentProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProgress upsert
   */
  export type StudentProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentProgress to update in case it exists.
     */
    where: StudentProgressWhereUniqueInput
    /**
     * In case the StudentProgress found by the `where` argument doesn't exist, create a new StudentProgress with this data.
     */
    create: XOR<StudentProgressCreateInput, StudentProgressUncheckedCreateInput>
    /**
     * In case the StudentProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentProgressUpdateInput, StudentProgressUncheckedUpdateInput>
  }

  /**
   * StudentProgress delete
   */
  export type StudentProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter which StudentProgress to delete.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress deleteMany
   */
  export type StudentProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProgresses to delete
     */
    where?: StudentProgressWhereInput
    /**
     * Limit how many StudentProgresses to delete.
     */
    limit?: number
  }

  /**
   * StudentProgress without action
   */
  export type StudentProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
  }


  /**
   * Model StudentProfile
   */

  export type AggregateStudentProfile = {
    _count: StudentProfileCountAggregateOutputType | null
    _avg: StudentProfileAvgAggregateOutputType | null
    _sum: StudentProfileSumAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  export type StudentProfileAvgAggregateOutputType = {
    height: number | null
    weight: number | null
    weeklyWorkoutFrequency: number | null
    workoutDuration: number | null
    preferredSets: number | null
    targetCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    mealsPerDay: number | null
    bmr: number | null
    tdee: number | null
    activityLevel: number | null
    hormoneTreatmentDuration: number | null
    dailyAvailableHours: number | null
  }

  export type StudentProfileSumAggregateOutputType = {
    height: number | null
    weight: number | null
    weeklyWorkoutFrequency: number | null
    workoutDuration: number | null
    preferredSets: number | null
    targetCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    mealsPerDay: number | null
    bmr: number | null
    tdee: number | null
    activityLevel: number | null
    hormoneTreatmentDuration: number | null
    dailyAvailableHours: number | null
  }

  export type StudentProfileMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    height: number | null
    weight: number | null
    fitnessLevel: string | null
    weeklyWorkoutFrequency: number | null
    workoutDuration: number | null
    goals: string | null
    injuries: string | null
    availableEquipment: string | null
    gymType: string | null
    preferredWorkoutTime: string | null
    preferredSets: number | null
    preferredRepRange: string | null
    restTime: string | null
    dietType: string | null
    allergies: string | null
    targetCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    mealsPerDay: number | null
    bmr: number | null
    tdee: number | null
    activityLevel: number | null
    hormoneTreatmentDuration: number | null
    physicalLimitations: string | null
    motorLimitations: string | null
    medicalConditions: string | null
    limitationDetails: string | null
    dailyAvailableHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    height: number | null
    weight: number | null
    fitnessLevel: string | null
    weeklyWorkoutFrequency: number | null
    workoutDuration: number | null
    goals: string | null
    injuries: string | null
    availableEquipment: string | null
    gymType: string | null
    preferredWorkoutTime: string | null
    preferredSets: number | null
    preferredRepRange: string | null
    restTime: string | null
    dietType: string | null
    allergies: string | null
    targetCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    mealsPerDay: number | null
    bmr: number | null
    tdee: number | null
    activityLevel: number | null
    hormoneTreatmentDuration: number | null
    physicalLimitations: string | null
    motorLimitations: string | null
    medicalConditions: string | null
    limitationDetails: string | null
    dailyAvailableHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileCountAggregateOutputType = {
    id: number
    studentId: number
    height: number
    weight: number
    fitnessLevel: number
    weeklyWorkoutFrequency: number
    workoutDuration: number
    goals: number
    injuries: number
    availableEquipment: number
    gymType: number
    preferredWorkoutTime: number
    preferredSets: number
    preferredRepRange: number
    restTime: number
    dietType: number
    allergies: number
    targetCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    mealsPerDay: number
    bmr: number
    tdee: number
    activityLevel: number
    hormoneTreatmentDuration: number
    physicalLimitations: number
    motorLimitations: number
    medicalConditions: number
    limitationDetails: number
    dailyAvailableHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentProfileAvgAggregateInputType = {
    height?: true
    weight?: true
    weeklyWorkoutFrequency?: true
    workoutDuration?: true
    preferredSets?: true
    targetCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    mealsPerDay?: true
    bmr?: true
    tdee?: true
    activityLevel?: true
    hormoneTreatmentDuration?: true
    dailyAvailableHours?: true
  }

  export type StudentProfileSumAggregateInputType = {
    height?: true
    weight?: true
    weeklyWorkoutFrequency?: true
    workoutDuration?: true
    preferredSets?: true
    targetCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    mealsPerDay?: true
    bmr?: true
    tdee?: true
    activityLevel?: true
    hormoneTreatmentDuration?: true
    dailyAvailableHours?: true
  }

  export type StudentProfileMinAggregateInputType = {
    id?: true
    studentId?: true
    height?: true
    weight?: true
    fitnessLevel?: true
    weeklyWorkoutFrequency?: true
    workoutDuration?: true
    goals?: true
    injuries?: true
    availableEquipment?: true
    gymType?: true
    preferredWorkoutTime?: true
    preferredSets?: true
    preferredRepRange?: true
    restTime?: true
    dietType?: true
    allergies?: true
    targetCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    mealsPerDay?: true
    bmr?: true
    tdee?: true
    activityLevel?: true
    hormoneTreatmentDuration?: true
    physicalLimitations?: true
    motorLimitations?: true
    medicalConditions?: true
    limitationDetails?: true
    dailyAvailableHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileMaxAggregateInputType = {
    id?: true
    studentId?: true
    height?: true
    weight?: true
    fitnessLevel?: true
    weeklyWorkoutFrequency?: true
    workoutDuration?: true
    goals?: true
    injuries?: true
    availableEquipment?: true
    gymType?: true
    preferredWorkoutTime?: true
    preferredSets?: true
    preferredRepRange?: true
    restTime?: true
    dietType?: true
    allergies?: true
    targetCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    mealsPerDay?: true
    bmr?: true
    tdee?: true
    activityLevel?: true
    hormoneTreatmentDuration?: true
    physicalLimitations?: true
    motorLimitations?: true
    medicalConditions?: true
    limitationDetails?: true
    dailyAvailableHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileCountAggregateInputType = {
    id?: true
    studentId?: true
    height?: true
    weight?: true
    fitnessLevel?: true
    weeklyWorkoutFrequency?: true
    workoutDuration?: true
    goals?: true
    injuries?: true
    availableEquipment?: true
    gymType?: true
    preferredWorkoutTime?: true
    preferredSets?: true
    preferredRepRange?: true
    restTime?: true
    dietType?: true
    allergies?: true
    targetCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    mealsPerDay?: true
    bmr?: true
    tdee?: true
    activityLevel?: true
    hormoneTreatmentDuration?: true
    physicalLimitations?: true
    motorLimitations?: true
    medicalConditions?: true
    limitationDetails?: true
    dailyAvailableHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfile to aggregate.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentProfiles
    **/
    _count?: true | StudentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentProfileMaxAggregateInputType
  }

  export type GetStudentProfileAggregateType<T extends StudentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentProfile[P]>
      : GetScalarType<T[P], AggregateStudentProfile[P]>
  }




  export type StudentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithAggregationInput | StudentProfileOrderByWithAggregationInput[]
    by: StudentProfileScalarFieldEnum[] | StudentProfileScalarFieldEnum
    having?: StudentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentProfileCountAggregateInputType | true
    _avg?: StudentProfileAvgAggregateInputType
    _sum?: StudentProfileSumAggregateInputType
    _min?: StudentProfileMinAggregateInputType
    _max?: StudentProfileMaxAggregateInputType
  }

  export type StudentProfileGroupByOutputType = {
    id: string
    studentId: string
    height: number | null
    weight: number | null
    fitnessLevel: string | null
    weeklyWorkoutFrequency: number | null
    workoutDuration: number | null
    goals: string | null
    injuries: string | null
    availableEquipment: string | null
    gymType: string | null
    preferredWorkoutTime: string | null
    preferredSets: number | null
    preferredRepRange: string | null
    restTime: string | null
    dietType: string | null
    allergies: string | null
    targetCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    mealsPerDay: number | null
    bmr: number | null
    tdee: number | null
    activityLevel: number | null
    hormoneTreatmentDuration: number | null
    physicalLimitations: string | null
    motorLimitations: string | null
    medicalConditions: string | null
    limitationDetails: string | null
    dailyAvailableHours: number | null
    createdAt: Date
    updatedAt: Date
    _count: StudentProfileCountAggregateOutputType | null
    _avg: StudentProfileAvgAggregateOutputType | null
    _sum: StudentProfileSumAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  type GetStudentProfileGroupByPayload<T extends StudentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
        }
      >
    >


  export type StudentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    height?: boolean
    weight?: boolean
    fitnessLevel?: boolean
    weeklyWorkoutFrequency?: boolean
    workoutDuration?: boolean
    goals?: boolean
    injuries?: boolean
    availableEquipment?: boolean
    gymType?: boolean
    preferredWorkoutTime?: boolean
    preferredSets?: boolean
    preferredRepRange?: boolean
    restTime?: boolean
    dietType?: boolean
    allergies?: boolean
    targetCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    mealsPerDay?: boolean
    bmr?: boolean
    tdee?: boolean
    activityLevel?: boolean
    hormoneTreatmentDuration?: boolean
    physicalLimitations?: boolean
    motorLimitations?: boolean
    medicalConditions?: boolean
    limitationDetails?: boolean
    dailyAvailableHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    height?: boolean
    weight?: boolean
    fitnessLevel?: boolean
    weeklyWorkoutFrequency?: boolean
    workoutDuration?: boolean
    goals?: boolean
    injuries?: boolean
    availableEquipment?: boolean
    gymType?: boolean
    preferredWorkoutTime?: boolean
    preferredSets?: boolean
    preferredRepRange?: boolean
    restTime?: boolean
    dietType?: boolean
    allergies?: boolean
    targetCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    mealsPerDay?: boolean
    bmr?: boolean
    tdee?: boolean
    activityLevel?: boolean
    hormoneTreatmentDuration?: boolean
    physicalLimitations?: boolean
    motorLimitations?: boolean
    medicalConditions?: boolean
    limitationDetails?: boolean
    dailyAvailableHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    height?: boolean
    weight?: boolean
    fitnessLevel?: boolean
    weeklyWorkoutFrequency?: boolean
    workoutDuration?: boolean
    goals?: boolean
    injuries?: boolean
    availableEquipment?: boolean
    gymType?: boolean
    preferredWorkoutTime?: boolean
    preferredSets?: boolean
    preferredRepRange?: boolean
    restTime?: boolean
    dietType?: boolean
    allergies?: boolean
    targetCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    mealsPerDay?: boolean
    bmr?: boolean
    tdee?: boolean
    activityLevel?: boolean
    hormoneTreatmentDuration?: boolean
    physicalLimitations?: boolean
    motorLimitations?: boolean
    medicalConditions?: boolean
    limitationDetails?: boolean
    dailyAvailableHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectScalar = {
    id?: boolean
    studentId?: boolean
    height?: boolean
    weight?: boolean
    fitnessLevel?: boolean
    weeklyWorkoutFrequency?: boolean
    workoutDuration?: boolean
    goals?: boolean
    injuries?: boolean
    availableEquipment?: boolean
    gymType?: boolean
    preferredWorkoutTime?: boolean
    preferredSets?: boolean
    preferredRepRange?: boolean
    restTime?: boolean
    dietType?: boolean
    allergies?: boolean
    targetCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    mealsPerDay?: boolean
    bmr?: boolean
    tdee?: boolean
    activityLevel?: boolean
    hormoneTreatmentDuration?: boolean
    physicalLimitations?: boolean
    motorLimitations?: boolean
    medicalConditions?: boolean
    limitationDetails?: boolean
    dailyAvailableHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "height" | "weight" | "fitnessLevel" | "weeklyWorkoutFrequency" | "workoutDuration" | "goals" | "injuries" | "availableEquipment" | "gymType" | "preferredWorkoutTime" | "preferredSets" | "preferredRepRange" | "restTime" | "dietType" | "allergies" | "targetCalories" | "targetProtein" | "targetCarbs" | "targetFats" | "mealsPerDay" | "bmr" | "tdee" | "activityLevel" | "hormoneTreatmentDuration" | "physicalLimitations" | "motorLimitations" | "medicalConditions" | "limitationDetails" | "dailyAvailableHours" | "createdAt" | "updatedAt", ExtArgs["result"]["studentProfile"]>
  export type StudentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentProfile"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      height: number | null
      weight: number | null
      fitnessLevel: string | null
      weeklyWorkoutFrequency: number | null
      workoutDuration: number | null
      goals: string | null
      injuries: string | null
      availableEquipment: string | null
      gymType: string | null
      preferredWorkoutTime: string | null
      preferredSets: number | null
      preferredRepRange: string | null
      restTime: string | null
      dietType: string | null
      allergies: string | null
      targetCalories: number | null
      targetProtein: number | null
      targetCarbs: number | null
      targetFats: number | null
      mealsPerDay: number | null
      bmr: number | null
      tdee: number | null
      activityLevel: number | null
      hormoneTreatmentDuration: number | null
      physicalLimitations: string | null
      motorLimitations: string | null
      medicalConditions: string | null
      limitationDetails: string | null
      dailyAvailableHours: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentProfile"]>
    composites: {}
  }

  type StudentProfileGetPayload<S extends boolean | null | undefined | StudentProfileDefaultArgs> = $Result.GetResult<Prisma.$StudentProfilePayload, S>

  type StudentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentProfileCountAggregateInputType | true
    }

  export interface StudentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentProfile'], meta: { name: 'StudentProfile' } }
    /**
     * Find zero or one StudentProfile that matches the filter.
     * @param {StudentProfileFindUniqueArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentProfileFindUniqueArgs>(args: SelectSubset<T, StudentProfileFindUniqueArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentProfileFindUniqueOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentProfileFindFirstArgs>(args?: SelectSubset<T, StudentProfileFindFirstArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany()
     * 
     * // Get first 10 StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentProfileFindManyArgs>(args?: SelectSubset<T, StudentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentProfile.
     * @param {StudentProfileCreateArgs} args - Arguments to create a StudentProfile.
     * @example
     * // Create one StudentProfile
     * const StudentProfile = await prisma.studentProfile.create({
     *   data: {
     *     // ... data to create a StudentProfile
     *   }
     * })
     * 
     */
    create<T extends StudentProfileCreateArgs>(args: SelectSubset<T, StudentProfileCreateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentProfiles.
     * @param {StudentProfileCreateManyArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentProfileCreateManyArgs>(args?: SelectSubset<T, StudentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentProfiles and returns the data saved in the database.
     * @param {StudentProfileCreateManyAndReturnArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentProfile.
     * @param {StudentProfileDeleteArgs} args - Arguments to delete one StudentProfile.
     * @example
     * // Delete one StudentProfile
     * const StudentProfile = await prisma.studentProfile.delete({
     *   where: {
     *     // ... filter to delete one StudentProfile
     *   }
     * })
     * 
     */
    delete<T extends StudentProfileDeleteArgs>(args: SelectSubset<T, StudentProfileDeleteArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentProfile.
     * @param {StudentProfileUpdateArgs} args - Arguments to update one StudentProfile.
     * @example
     * // Update one StudentProfile
     * const studentProfile = await prisma.studentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentProfileUpdateArgs>(args: SelectSubset<T, StudentProfileUpdateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentProfiles.
     * @param {StudentProfileDeleteManyArgs} args - Arguments to filter StudentProfiles to delete.
     * @example
     * // Delete a few StudentProfiles
     * const { count } = await prisma.studentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentProfileDeleteManyArgs>(args?: SelectSubset<T, StudentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentProfileUpdateManyArgs>(args: SelectSubset<T, StudentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles and returns the data updated in the database.
     * @param {StudentProfileUpdateManyAndReturnArgs} args - Arguments to update many StudentProfiles.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentProfile.
     * @param {StudentProfileUpsertArgs} args - Arguments to update or create a StudentProfile.
     * @example
     * // Update or create a StudentProfile
     * const studentProfile = await prisma.studentProfile.upsert({
     *   create: {
     *     // ... data to create a StudentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentProfile we want to update
     *   }
     * })
     */
    upsert<T extends StudentProfileUpsertArgs>(args: SelectSubset<T, StudentProfileUpsertArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileCountArgs} args - Arguments to filter StudentProfiles to count.
     * @example
     * // Count the number of StudentProfiles
     * const count = await prisma.studentProfile.count({
     *   where: {
     *     // ... the filter for the StudentProfiles we want to count
     *   }
     * })
    **/
    count<T extends StudentProfileCountArgs>(
      args?: Subset<T, StudentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentProfileAggregateArgs>(args: Subset<T, StudentProfileAggregateArgs>): Prisma.PrismaPromise<GetStudentProfileAggregateType<T>>

    /**
     * Group by StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentProfileGroupByArgs['orderBy'] }
        : { orderBy?: StudentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentProfile model
   */
  readonly fields: StudentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentProfile model
   */
  interface StudentProfileFieldRefs {
    readonly id: FieldRef<"StudentProfile", 'String'>
    readonly studentId: FieldRef<"StudentProfile", 'String'>
    readonly height: FieldRef<"StudentProfile", 'Float'>
    readonly weight: FieldRef<"StudentProfile", 'Float'>
    readonly fitnessLevel: FieldRef<"StudentProfile", 'String'>
    readonly weeklyWorkoutFrequency: FieldRef<"StudentProfile", 'Int'>
    readonly workoutDuration: FieldRef<"StudentProfile", 'Int'>
    readonly goals: FieldRef<"StudentProfile", 'String'>
    readonly injuries: FieldRef<"StudentProfile", 'String'>
    readonly availableEquipment: FieldRef<"StudentProfile", 'String'>
    readonly gymType: FieldRef<"StudentProfile", 'String'>
    readonly preferredWorkoutTime: FieldRef<"StudentProfile", 'String'>
    readonly preferredSets: FieldRef<"StudentProfile", 'Int'>
    readonly preferredRepRange: FieldRef<"StudentProfile", 'String'>
    readonly restTime: FieldRef<"StudentProfile", 'String'>
    readonly dietType: FieldRef<"StudentProfile", 'String'>
    readonly allergies: FieldRef<"StudentProfile", 'String'>
    readonly targetCalories: FieldRef<"StudentProfile", 'Int'>
    readonly targetProtein: FieldRef<"StudentProfile", 'Float'>
    readonly targetCarbs: FieldRef<"StudentProfile", 'Float'>
    readonly targetFats: FieldRef<"StudentProfile", 'Float'>
    readonly mealsPerDay: FieldRef<"StudentProfile", 'Int'>
    readonly bmr: FieldRef<"StudentProfile", 'Float'>
    readonly tdee: FieldRef<"StudentProfile", 'Float'>
    readonly activityLevel: FieldRef<"StudentProfile", 'Int'>
    readonly hormoneTreatmentDuration: FieldRef<"StudentProfile", 'Int'>
    readonly physicalLimitations: FieldRef<"StudentProfile", 'String'>
    readonly motorLimitations: FieldRef<"StudentProfile", 'String'>
    readonly medicalConditions: FieldRef<"StudentProfile", 'String'>
    readonly limitationDetails: FieldRef<"StudentProfile", 'String'>
    readonly dailyAvailableHours: FieldRef<"StudentProfile", 'Float'>
    readonly createdAt: FieldRef<"StudentProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentProfile findUnique
   */
  export type StudentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findUniqueOrThrow
   */
  export type StudentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findFirst
   */
  export type StudentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findFirstOrThrow
   */
  export type StudentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findMany
   */
  export type StudentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfiles to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile create
   */
  export type StudentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentProfile.
     */
    data: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
  }

  /**
   * StudentProfile createMany
   */
  export type StudentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentProfile createManyAndReturn
   */
  export type StudentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile update
   */
  export type StudentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentProfile.
     */
    data: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
    /**
     * Choose, which StudentProfile to update.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile updateMany
   */
  export type StudentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to update.
     */
    limit?: number
  }

  /**
   * StudentProfile updateManyAndReturn
   */
  export type StudentProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile upsert
   */
  export type StudentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentProfile to update in case it exists.
     */
    where: StudentProfileWhereUniqueInput
    /**
     * In case the StudentProfile found by the `where` argument doesn't exist, create a new StudentProfile with this data.
     */
    create: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
    /**
     * In case the StudentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
  }

  /**
   * StudentProfile delete
   */
  export type StudentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter which StudentProfile to delete.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile deleteMany
   */
  export type StudentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfiles to delete
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to delete.
     */
    limit?: number
  }

  /**
   * StudentProfile without action
   */
  export type StudentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
  }


  /**
   * Model WeightHistory
   */

  export type AggregateWeightHistory = {
    _count: WeightHistoryCountAggregateOutputType | null
    _avg: WeightHistoryAvgAggregateOutputType | null
    _sum: WeightHistorySumAggregateOutputType | null
    _min: WeightHistoryMinAggregateOutputType | null
    _max: WeightHistoryMaxAggregateOutputType | null
  }

  export type WeightHistoryAvgAggregateOutputType = {
    weight: number | null
  }

  export type WeightHistorySumAggregateOutputType = {
    weight: number | null
  }

  export type WeightHistoryMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    weight: number | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeightHistoryMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    weight: number | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeightHistoryCountAggregateOutputType = {
    id: number
    studentId: number
    weight: number
    date: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeightHistoryAvgAggregateInputType = {
    weight?: true
  }

  export type WeightHistorySumAggregateInputType = {
    weight?: true
  }

  export type WeightHistoryMinAggregateInputType = {
    id?: true
    studentId?: true
    weight?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeightHistoryMaxAggregateInputType = {
    id?: true
    studentId?: true
    weight?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeightHistoryCountAggregateInputType = {
    id?: true
    studentId?: true
    weight?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeightHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeightHistory to aggregate.
     */
    where?: WeightHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightHistories to fetch.
     */
    orderBy?: WeightHistoryOrderByWithRelationInput | WeightHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeightHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeightHistories
    **/
    _count?: true | WeightHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeightHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeightHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeightHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeightHistoryMaxAggregateInputType
  }

  export type GetWeightHistoryAggregateType<T extends WeightHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWeightHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeightHistory[P]>
      : GetScalarType<T[P], AggregateWeightHistory[P]>
  }




  export type WeightHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeightHistoryWhereInput
    orderBy?: WeightHistoryOrderByWithAggregationInput | WeightHistoryOrderByWithAggregationInput[]
    by: WeightHistoryScalarFieldEnum[] | WeightHistoryScalarFieldEnum
    having?: WeightHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeightHistoryCountAggregateInputType | true
    _avg?: WeightHistoryAvgAggregateInputType
    _sum?: WeightHistorySumAggregateInputType
    _min?: WeightHistoryMinAggregateInputType
    _max?: WeightHistoryMaxAggregateInputType
  }

  export type WeightHistoryGroupByOutputType = {
    id: string
    studentId: string
    weight: number
    date: Date
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WeightHistoryCountAggregateOutputType | null
    _avg: WeightHistoryAvgAggregateOutputType | null
    _sum: WeightHistorySumAggregateOutputType | null
    _min: WeightHistoryMinAggregateOutputType | null
    _max: WeightHistoryMaxAggregateOutputType | null
  }

  type GetWeightHistoryGroupByPayload<T extends WeightHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeightHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeightHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeightHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], WeightHistoryGroupByOutputType[P]>
        }
      >
    >


  export type WeightHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    weight?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weightHistory"]>

  export type WeightHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    weight?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weightHistory"]>

  export type WeightHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    weight?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weightHistory"]>

  export type WeightHistorySelectScalar = {
    id?: boolean
    studentId?: boolean
    weight?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeightHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "weight" | "date" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["weightHistory"]>
  export type WeightHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type WeightHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type WeightHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $WeightHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeightHistory"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      weight: number
      date: Date
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weightHistory"]>
    composites: {}
  }

  type WeightHistoryGetPayload<S extends boolean | null | undefined | WeightHistoryDefaultArgs> = $Result.GetResult<Prisma.$WeightHistoryPayload, S>

  type WeightHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeightHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeightHistoryCountAggregateInputType | true
    }

  export interface WeightHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeightHistory'], meta: { name: 'WeightHistory' } }
    /**
     * Find zero or one WeightHistory that matches the filter.
     * @param {WeightHistoryFindUniqueArgs} args - Arguments to find a WeightHistory
     * @example
     * // Get one WeightHistory
     * const weightHistory = await prisma.weightHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeightHistoryFindUniqueArgs>(args: SelectSubset<T, WeightHistoryFindUniqueArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeightHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeightHistoryFindUniqueOrThrowArgs} args - Arguments to find a WeightHistory
     * @example
     * // Get one WeightHistory
     * const weightHistory = await prisma.weightHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeightHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, WeightHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeightHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryFindFirstArgs} args - Arguments to find a WeightHistory
     * @example
     * // Get one WeightHistory
     * const weightHistory = await prisma.weightHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeightHistoryFindFirstArgs>(args?: SelectSubset<T, WeightHistoryFindFirstArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeightHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryFindFirstOrThrowArgs} args - Arguments to find a WeightHistory
     * @example
     * // Get one WeightHistory
     * const weightHistory = await prisma.weightHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeightHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, WeightHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeightHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeightHistories
     * const weightHistories = await prisma.weightHistory.findMany()
     * 
     * // Get first 10 WeightHistories
     * const weightHistories = await prisma.weightHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weightHistoryWithIdOnly = await prisma.weightHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeightHistoryFindManyArgs>(args?: SelectSubset<T, WeightHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeightHistory.
     * @param {WeightHistoryCreateArgs} args - Arguments to create a WeightHistory.
     * @example
     * // Create one WeightHistory
     * const WeightHistory = await prisma.weightHistory.create({
     *   data: {
     *     // ... data to create a WeightHistory
     *   }
     * })
     * 
     */
    create<T extends WeightHistoryCreateArgs>(args: SelectSubset<T, WeightHistoryCreateArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeightHistories.
     * @param {WeightHistoryCreateManyArgs} args - Arguments to create many WeightHistories.
     * @example
     * // Create many WeightHistories
     * const weightHistory = await prisma.weightHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeightHistoryCreateManyArgs>(args?: SelectSubset<T, WeightHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeightHistories and returns the data saved in the database.
     * @param {WeightHistoryCreateManyAndReturnArgs} args - Arguments to create many WeightHistories.
     * @example
     * // Create many WeightHistories
     * const weightHistory = await prisma.weightHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeightHistories and only return the `id`
     * const weightHistoryWithIdOnly = await prisma.weightHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeightHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, WeightHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeightHistory.
     * @param {WeightHistoryDeleteArgs} args - Arguments to delete one WeightHistory.
     * @example
     * // Delete one WeightHistory
     * const WeightHistory = await prisma.weightHistory.delete({
     *   where: {
     *     // ... filter to delete one WeightHistory
     *   }
     * })
     * 
     */
    delete<T extends WeightHistoryDeleteArgs>(args: SelectSubset<T, WeightHistoryDeleteArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeightHistory.
     * @param {WeightHistoryUpdateArgs} args - Arguments to update one WeightHistory.
     * @example
     * // Update one WeightHistory
     * const weightHistory = await prisma.weightHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeightHistoryUpdateArgs>(args: SelectSubset<T, WeightHistoryUpdateArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeightHistories.
     * @param {WeightHistoryDeleteManyArgs} args - Arguments to filter WeightHistories to delete.
     * @example
     * // Delete a few WeightHistories
     * const { count } = await prisma.weightHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeightHistoryDeleteManyArgs>(args?: SelectSubset<T, WeightHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeightHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeightHistories
     * const weightHistory = await prisma.weightHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeightHistoryUpdateManyArgs>(args: SelectSubset<T, WeightHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeightHistories and returns the data updated in the database.
     * @param {WeightHistoryUpdateManyAndReturnArgs} args - Arguments to update many WeightHistories.
     * @example
     * // Update many WeightHistories
     * const weightHistory = await prisma.weightHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeightHistories and only return the `id`
     * const weightHistoryWithIdOnly = await prisma.weightHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeightHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, WeightHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeightHistory.
     * @param {WeightHistoryUpsertArgs} args - Arguments to update or create a WeightHistory.
     * @example
     * // Update or create a WeightHistory
     * const weightHistory = await prisma.weightHistory.upsert({
     *   create: {
     *     // ... data to create a WeightHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeightHistory we want to update
     *   }
     * })
     */
    upsert<T extends WeightHistoryUpsertArgs>(args: SelectSubset<T, WeightHistoryUpsertArgs<ExtArgs>>): Prisma__WeightHistoryClient<$Result.GetResult<Prisma.$WeightHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeightHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryCountArgs} args - Arguments to filter WeightHistories to count.
     * @example
     * // Count the number of WeightHistories
     * const count = await prisma.weightHistory.count({
     *   where: {
     *     // ... the filter for the WeightHistories we want to count
     *   }
     * })
    **/
    count<T extends WeightHistoryCountArgs>(
      args?: Subset<T, WeightHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeightHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeightHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeightHistoryAggregateArgs>(args: Subset<T, WeightHistoryAggregateArgs>): Prisma.PrismaPromise<GetWeightHistoryAggregateType<T>>

    /**
     * Group by WeightHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeightHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeightHistoryGroupByArgs['orderBy'] }
        : { orderBy?: WeightHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeightHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeightHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeightHistory model
   */
  readonly fields: WeightHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeightHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeightHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeightHistory model
   */
  interface WeightHistoryFieldRefs {
    readonly id: FieldRef<"WeightHistory", 'String'>
    readonly studentId: FieldRef<"WeightHistory", 'String'>
    readonly weight: FieldRef<"WeightHistory", 'Float'>
    readonly date: FieldRef<"WeightHistory", 'DateTime'>
    readonly notes: FieldRef<"WeightHistory", 'String'>
    readonly createdAt: FieldRef<"WeightHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"WeightHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeightHistory findUnique
   */
  export type WeightHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WeightHistory to fetch.
     */
    where: WeightHistoryWhereUniqueInput
  }

  /**
   * WeightHistory findUniqueOrThrow
   */
  export type WeightHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WeightHistory to fetch.
     */
    where: WeightHistoryWhereUniqueInput
  }

  /**
   * WeightHistory findFirst
   */
  export type WeightHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WeightHistory to fetch.
     */
    where?: WeightHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightHistories to fetch.
     */
    orderBy?: WeightHistoryOrderByWithRelationInput | WeightHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeightHistories.
     */
    cursor?: WeightHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeightHistories.
     */
    distinct?: WeightHistoryScalarFieldEnum | WeightHistoryScalarFieldEnum[]
  }

  /**
   * WeightHistory findFirstOrThrow
   */
  export type WeightHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WeightHistory to fetch.
     */
    where?: WeightHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightHistories to fetch.
     */
    orderBy?: WeightHistoryOrderByWithRelationInput | WeightHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeightHistories.
     */
    cursor?: WeightHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeightHistories.
     */
    distinct?: WeightHistoryScalarFieldEnum | WeightHistoryScalarFieldEnum[]
  }

  /**
   * WeightHistory findMany
   */
  export type WeightHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WeightHistories to fetch.
     */
    where?: WeightHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeightHistories to fetch.
     */
    orderBy?: WeightHistoryOrderByWithRelationInput | WeightHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeightHistories.
     */
    cursor?: WeightHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeightHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeightHistories.
     */
    skip?: number
    distinct?: WeightHistoryScalarFieldEnum | WeightHistoryScalarFieldEnum[]
  }

  /**
   * WeightHistory create
   */
  export type WeightHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a WeightHistory.
     */
    data: XOR<WeightHistoryCreateInput, WeightHistoryUncheckedCreateInput>
  }

  /**
   * WeightHistory createMany
   */
  export type WeightHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeightHistories.
     */
    data: WeightHistoryCreateManyInput | WeightHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeightHistory createManyAndReturn
   */
  export type WeightHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many WeightHistories.
     */
    data: WeightHistoryCreateManyInput | WeightHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeightHistory update
   */
  export type WeightHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a WeightHistory.
     */
    data: XOR<WeightHistoryUpdateInput, WeightHistoryUncheckedUpdateInput>
    /**
     * Choose, which WeightHistory to update.
     */
    where: WeightHistoryWhereUniqueInput
  }

  /**
   * WeightHistory updateMany
   */
  export type WeightHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeightHistories.
     */
    data: XOR<WeightHistoryUpdateManyMutationInput, WeightHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WeightHistories to update
     */
    where?: WeightHistoryWhereInput
    /**
     * Limit how many WeightHistories to update.
     */
    limit?: number
  }

  /**
   * WeightHistory updateManyAndReturn
   */
  export type WeightHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * The data used to update WeightHistories.
     */
    data: XOR<WeightHistoryUpdateManyMutationInput, WeightHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WeightHistories to update
     */
    where?: WeightHistoryWhereInput
    /**
     * Limit how many WeightHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeightHistory upsert
   */
  export type WeightHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the WeightHistory to update in case it exists.
     */
    where: WeightHistoryWhereUniqueInput
    /**
     * In case the WeightHistory found by the `where` argument doesn't exist, create a new WeightHistory with this data.
     */
    create: XOR<WeightHistoryCreateInput, WeightHistoryUncheckedCreateInput>
    /**
     * In case the WeightHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeightHistoryUpdateInput, WeightHistoryUncheckedUpdateInput>
  }

  /**
   * WeightHistory delete
   */
  export type WeightHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
    /**
     * Filter which WeightHistory to delete.
     */
    where: WeightHistoryWhereUniqueInput
  }

  /**
   * WeightHistory deleteMany
   */
  export type WeightHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeightHistories to delete
     */
    where?: WeightHistoryWhereInput
    /**
     * Limit how many WeightHistories to delete.
     */
    limit?: number
  }

  /**
   * WeightHistory without action
   */
  export type WeightHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightHistory
     */
    select?: WeightHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeightHistory
     */
    omit?: WeightHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Gym
   */

  export type AggregateGym = {
    _count: GymCountAggregateOutputType | null
    _avg: GymAvgAggregateOutputType | null
    _sum: GymSumAggregateOutputType | null
    _min: GymMinAggregateOutputType | null
    _max: GymMaxAggregateOutputType | null
  }

  export type GymAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalReviews: number | null
  }

  export type GymSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalReviews: number | null
  }

  export type GymMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    logo: string | null
    address: string | null
    phone: string | null
    email: string | null
    cnpj: string | null
    plan: string | null
    isActive: boolean | null
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalReviews: number | null
    amenities: string | null
    openingHours: string | null
    photos: string | null
    isPartner: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    logo: string | null
    address: string | null
    phone: string | null
    email: string | null
    cnpj: string | null
    plan: string | null
    isActive: boolean | null
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalReviews: number | null
    amenities: string | null
    openingHours: string | null
    photos: string | null
    isPartner: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    logo: number
    address: number
    phone: number
    email: number
    cnpj: number
    plan: number
    isActive: number
    latitude: number
    longitude: number
    rating: number
    totalReviews: number
    amenities: number
    openingHours: number
    photos: number
    isPartner: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    rating?: true
    totalReviews?: true
  }

  export type GymSumAggregateInputType = {
    latitude?: true
    longitude?: true
    rating?: true
    totalReviews?: true
  }

  export type GymMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    logo?: true
    address?: true
    phone?: true
    email?: true
    cnpj?: true
    plan?: true
    isActive?: true
    latitude?: true
    longitude?: true
    rating?: true
    totalReviews?: true
    amenities?: true
    openingHours?: true
    photos?: true
    isPartner?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    logo?: true
    address?: true
    phone?: true
    email?: true
    cnpj?: true
    plan?: true
    isActive?: true
    latitude?: true
    longitude?: true
    rating?: true
    totalReviews?: true
    amenities?: true
    openingHours?: true
    photos?: true
    isPartner?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    logo?: true
    address?: true
    phone?: true
    email?: true
    cnpj?: true
    plan?: true
    isActive?: true
    latitude?: true
    longitude?: true
    rating?: true
    totalReviews?: true
    amenities?: true
    openingHours?: true
    photos?: true
    isPartner?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gym to aggregate.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gyms
    **/
    _count?: true | GymCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymMaxAggregateInputType
  }

  export type GetGymAggregateType<T extends GymAggregateArgs> = {
        [P in keyof T & keyof AggregateGym]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGym[P]>
      : GetScalarType<T[P], AggregateGym[P]>
  }




  export type GymGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymWhereInput
    orderBy?: GymOrderByWithAggregationInput | GymOrderByWithAggregationInput[]
    by: GymScalarFieldEnum[] | GymScalarFieldEnum
    having?: GymScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymCountAggregateInputType | true
    _avg?: GymAvgAggregateInputType
    _sum?: GymSumAggregateInputType
    _min?: GymMinAggregateInputType
    _max?: GymMaxAggregateInputType
  }

  export type GymGroupByOutputType = {
    id: string
    userId: string
    name: string
    logo: string | null
    address: string
    phone: string
    email: string
    cnpj: string | null
    plan: string
    isActive: boolean
    latitude: number | null
    longitude: number | null
    rating: number | null
    totalReviews: number
    amenities: string | null
    openingHours: string | null
    photos: string | null
    isPartner: boolean
    createdAt: Date
    updatedAt: Date
    _count: GymCountAggregateOutputType | null
    _avg: GymAvgAggregateOutputType | null
    _sum: GymSumAggregateOutputType | null
    _min: GymMinAggregateOutputType | null
    _max: GymMaxAggregateOutputType | null
  }

  type GetGymGroupByPayload<T extends GymGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymGroupByOutputType[P]>
            : GetScalarType<T[P], GymGroupByOutputType[P]>
        }
      >
    >


  export type GymSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    cnpj?: boolean
    plan?: boolean
    isActive?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalReviews?: boolean
    amenities?: boolean
    openingHours?: boolean
    photos?: boolean
    isPartner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | Gym$profileArgs<ExtArgs>
    students?: boolean | Gym$studentsArgs<ExtArgs>
    equipment?: boolean | Gym$equipmentArgs<ExtArgs>
    plans?: boolean | Gym$plansArgs<ExtArgs>
    payments?: boolean | Gym$paymentsArgs<ExtArgs>
    expenses?: boolean | Gym$expensesArgs<ExtArgs>
    checkIns?: boolean | Gym$checkInsArgs<ExtArgs>
    stats?: boolean | Gym$statsArgs<ExtArgs>
    subscription?: boolean | Gym$subscriptionArgs<ExtArgs>
    _count?: boolean | GymCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gym"]>

  export type GymSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    cnpj?: boolean
    plan?: boolean
    isActive?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalReviews?: boolean
    amenities?: boolean
    openingHours?: boolean
    photos?: boolean
    isPartner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gym"]>

  export type GymSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    cnpj?: boolean
    plan?: boolean
    isActive?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalReviews?: boolean
    amenities?: boolean
    openingHours?: boolean
    photos?: boolean
    isPartner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gym"]>

  export type GymSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    cnpj?: boolean
    plan?: boolean
    isActive?: boolean
    latitude?: boolean
    longitude?: boolean
    rating?: boolean
    totalReviews?: boolean
    amenities?: boolean
    openingHours?: boolean
    photos?: boolean
    isPartner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "logo" | "address" | "phone" | "email" | "cnpj" | "plan" | "isActive" | "latitude" | "longitude" | "rating" | "totalReviews" | "amenities" | "openingHours" | "photos" | "isPartner" | "createdAt" | "updatedAt", ExtArgs["result"]["gym"]>
  export type GymInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | Gym$profileArgs<ExtArgs>
    students?: boolean | Gym$studentsArgs<ExtArgs>
    equipment?: boolean | Gym$equipmentArgs<ExtArgs>
    plans?: boolean | Gym$plansArgs<ExtArgs>
    payments?: boolean | Gym$paymentsArgs<ExtArgs>
    expenses?: boolean | Gym$expensesArgs<ExtArgs>
    checkIns?: boolean | Gym$checkInsArgs<ExtArgs>
    stats?: boolean | Gym$statsArgs<ExtArgs>
    subscription?: boolean | Gym$subscriptionArgs<ExtArgs>
    _count?: boolean | GymCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GymIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GymIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GymPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gym"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profile: Prisma.$GymProfilePayload<ExtArgs> | null
      students: Prisma.$GymMembershipPayload<ExtArgs>[]
      equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      plans: Prisma.$MembershipPlanPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      checkIns: Prisma.$CheckInPayload<ExtArgs>[]
      stats: Prisma.$GymStatsPayload<ExtArgs> | null
      subscription: Prisma.$GymSubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      logo: string | null
      address: string
      phone: string
      email: string
      cnpj: string | null
      plan: string
      isActive: boolean
      latitude: number | null
      longitude: number | null
      rating: number | null
      totalReviews: number
      amenities: string | null
      openingHours: string | null
      photos: string | null
      isPartner: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gym"]>
    composites: {}
  }

  type GymGetPayload<S extends boolean | null | undefined | GymDefaultArgs> = $Result.GetResult<Prisma.$GymPayload, S>

  type GymCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymCountAggregateInputType | true
    }

  export interface GymDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gym'], meta: { name: 'Gym' } }
    /**
     * Find zero or one Gym that matches the filter.
     * @param {GymFindUniqueArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymFindUniqueArgs>(args: SelectSubset<T, GymFindUniqueArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gym that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymFindUniqueOrThrowArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymFindUniqueOrThrowArgs>(args: SelectSubset<T, GymFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gym that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFindFirstArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymFindFirstArgs>(args?: SelectSubset<T, GymFindFirstArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gym that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFindFirstOrThrowArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymFindFirstOrThrowArgs>(args?: SelectSubset<T, GymFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gyms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gyms
     * const gyms = await prisma.gym.findMany()
     * 
     * // Get first 10 Gyms
     * const gyms = await prisma.gym.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymWithIdOnly = await prisma.gym.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymFindManyArgs>(args?: SelectSubset<T, GymFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gym.
     * @param {GymCreateArgs} args - Arguments to create a Gym.
     * @example
     * // Create one Gym
     * const Gym = await prisma.gym.create({
     *   data: {
     *     // ... data to create a Gym
     *   }
     * })
     * 
     */
    create<T extends GymCreateArgs>(args: SelectSubset<T, GymCreateArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gyms.
     * @param {GymCreateManyArgs} args - Arguments to create many Gyms.
     * @example
     * // Create many Gyms
     * const gym = await prisma.gym.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymCreateManyArgs>(args?: SelectSubset<T, GymCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gyms and returns the data saved in the database.
     * @param {GymCreateManyAndReturnArgs} args - Arguments to create many Gyms.
     * @example
     * // Create many Gyms
     * const gym = await prisma.gym.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gyms and only return the `id`
     * const gymWithIdOnly = await prisma.gym.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymCreateManyAndReturnArgs>(args?: SelectSubset<T, GymCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gym.
     * @param {GymDeleteArgs} args - Arguments to delete one Gym.
     * @example
     * // Delete one Gym
     * const Gym = await prisma.gym.delete({
     *   where: {
     *     // ... filter to delete one Gym
     *   }
     * })
     * 
     */
    delete<T extends GymDeleteArgs>(args: SelectSubset<T, GymDeleteArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gym.
     * @param {GymUpdateArgs} args - Arguments to update one Gym.
     * @example
     * // Update one Gym
     * const gym = await prisma.gym.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymUpdateArgs>(args: SelectSubset<T, GymUpdateArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gyms.
     * @param {GymDeleteManyArgs} args - Arguments to filter Gyms to delete.
     * @example
     * // Delete a few Gyms
     * const { count } = await prisma.gym.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymDeleteManyArgs>(args?: SelectSubset<T, GymDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gyms
     * const gym = await prisma.gym.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymUpdateManyArgs>(args: SelectSubset<T, GymUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gyms and returns the data updated in the database.
     * @param {GymUpdateManyAndReturnArgs} args - Arguments to update many Gyms.
     * @example
     * // Update many Gyms
     * const gym = await prisma.gym.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gyms and only return the `id`
     * const gymWithIdOnly = await prisma.gym.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymUpdateManyAndReturnArgs>(args: SelectSubset<T, GymUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gym.
     * @param {GymUpsertArgs} args - Arguments to update or create a Gym.
     * @example
     * // Update or create a Gym
     * const gym = await prisma.gym.upsert({
     *   create: {
     *     // ... data to create a Gym
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gym we want to update
     *   }
     * })
     */
    upsert<T extends GymUpsertArgs>(args: SelectSubset<T, GymUpsertArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCountArgs} args - Arguments to filter Gyms to count.
     * @example
     * // Count the number of Gyms
     * const count = await prisma.gym.count({
     *   where: {
     *     // ... the filter for the Gyms we want to count
     *   }
     * })
    **/
    count<T extends GymCountArgs>(
      args?: Subset<T, GymCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gym.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymAggregateArgs>(args: Subset<T, GymAggregateArgs>): Prisma.PrismaPromise<GetGymAggregateType<T>>

    /**
     * Group by Gym.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymGroupByArgs['orderBy'] }
        : { orderBy?: GymGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gym model
   */
  readonly fields: GymFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gym.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends Gym$profileArgs<ExtArgs> = {}>(args?: Subset<T, Gym$profileArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends Gym$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Gym$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipment<T extends Gym$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Gym$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plans<T extends Gym$plansArgs<ExtArgs> = {}>(args?: Subset<T, Gym$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Gym$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Gym$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Gym$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Gym$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkIns<T extends Gym$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, Gym$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends Gym$statsArgs<ExtArgs> = {}>(args?: Subset<T, Gym$statsArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscription<T extends Gym$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Gym$subscriptionArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gym model
   */
  interface GymFieldRefs {
    readonly id: FieldRef<"Gym", 'String'>
    readonly userId: FieldRef<"Gym", 'String'>
    readonly name: FieldRef<"Gym", 'String'>
    readonly logo: FieldRef<"Gym", 'String'>
    readonly address: FieldRef<"Gym", 'String'>
    readonly phone: FieldRef<"Gym", 'String'>
    readonly email: FieldRef<"Gym", 'String'>
    readonly cnpj: FieldRef<"Gym", 'String'>
    readonly plan: FieldRef<"Gym", 'String'>
    readonly isActive: FieldRef<"Gym", 'Boolean'>
    readonly latitude: FieldRef<"Gym", 'Float'>
    readonly longitude: FieldRef<"Gym", 'Float'>
    readonly rating: FieldRef<"Gym", 'Float'>
    readonly totalReviews: FieldRef<"Gym", 'Int'>
    readonly amenities: FieldRef<"Gym", 'String'>
    readonly openingHours: FieldRef<"Gym", 'String'>
    readonly photos: FieldRef<"Gym", 'String'>
    readonly isPartner: FieldRef<"Gym", 'Boolean'>
    readonly createdAt: FieldRef<"Gym", 'DateTime'>
    readonly updatedAt: FieldRef<"Gym", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gym findUnique
   */
  export type GymFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym findUniqueOrThrow
   */
  export type GymFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym findFirst
   */
  export type GymFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gyms.
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gyms.
     */
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * Gym findFirstOrThrow
   */
  export type GymFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gyms.
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gyms.
     */
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * Gym findMany
   */
  export type GymFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gyms to fetch.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gyms.
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * Gym create
   */
  export type GymCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * The data needed to create a Gym.
     */
    data: XOR<GymCreateInput, GymUncheckedCreateInput>
  }

  /**
   * Gym createMany
   */
  export type GymCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gyms.
     */
    data: GymCreateManyInput | GymCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gym createManyAndReturn
   */
  export type GymCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * The data used to create many Gyms.
     */
    data: GymCreateManyInput | GymCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gym update
   */
  export type GymUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * The data needed to update a Gym.
     */
    data: XOR<GymUpdateInput, GymUncheckedUpdateInput>
    /**
     * Choose, which Gym to update.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym updateMany
   */
  export type GymUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gyms.
     */
    data: XOR<GymUpdateManyMutationInput, GymUncheckedUpdateManyInput>
    /**
     * Filter which Gyms to update
     */
    where?: GymWhereInput
    /**
     * Limit how many Gyms to update.
     */
    limit?: number
  }

  /**
   * Gym updateManyAndReturn
   */
  export type GymUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * The data used to update Gyms.
     */
    data: XOR<GymUpdateManyMutationInput, GymUncheckedUpdateManyInput>
    /**
     * Filter which Gyms to update
     */
    where?: GymWhereInput
    /**
     * Limit how many Gyms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gym upsert
   */
  export type GymUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * The filter to search for the Gym to update in case it exists.
     */
    where: GymWhereUniqueInput
    /**
     * In case the Gym found by the `where` argument doesn't exist, create a new Gym with this data.
     */
    create: XOR<GymCreateInput, GymUncheckedCreateInput>
    /**
     * In case the Gym was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymUpdateInput, GymUncheckedUpdateInput>
  }

  /**
   * Gym delete
   */
  export type GymDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter which Gym to delete.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym deleteMany
   */
  export type GymDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gyms to delete
     */
    where?: GymWhereInput
    /**
     * Limit how many Gyms to delete.
     */
    limit?: number
  }

  /**
   * Gym.profile
   */
  export type Gym$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    where?: GymProfileWhereInput
  }

  /**
   * Gym.students
   */
  export type Gym$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    where?: GymMembershipWhereInput
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    cursor?: GymMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * Gym.equipment
   */
  export type Gym$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Gym.plans
   */
  export type Gym$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    where?: MembershipPlanWhereInput
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    cursor?: MembershipPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * Gym.payments
   */
  export type Gym$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Gym.expenses
   */
  export type Gym$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Gym.checkIns
   */
  export type Gym$checkInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * Gym.stats
   */
  export type Gym$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    where?: GymStatsWhereInput
  }

  /**
   * Gym.subscription
   */
  export type Gym$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    where?: GymSubscriptionWhereInput
  }

  /**
   * Gym without action
   */
  export type GymDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
  }


  /**
   * Model GymProfile
   */

  export type AggregateGymProfile = {
    _count: GymProfileCountAggregateOutputType | null
    _avg: GymProfileAvgAggregateOutputType | null
    _sum: GymProfileSumAggregateOutputType | null
    _min: GymProfileMinAggregateOutputType | null
    _max: GymProfileMaxAggregateOutputType | null
  }

  export type GymProfileAvgAggregateOutputType = {
    totalStudents: number | null
    activeStudents: number | null
    equipmentCount: number | null
    level: number | null
    xp: number | null
    xpToNextLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    monthlyStudentGoal: number | null
    avgStudentFrequency: number | null
    equipmentUtilization: number | null
    ranking: number | null
  }

  export type GymProfileSumAggregateOutputType = {
    totalStudents: number | null
    activeStudents: number | null
    equipmentCount: number | null
    level: number | null
    xp: number | null
    xpToNextLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    monthlyStudentGoal: number | null
    avgStudentFrequency: number | null
    equipmentUtilization: number | null
    ranking: number | null
  }

  export type GymProfileMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    totalStudents: number | null
    activeStudents: number | null
    equipmentCount: number | null
    level: number | null
    xp: number | null
    xpToNextLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    monthlyStudentGoal: number | null
    avgStudentFrequency: number | null
    equipmentUtilization: number | null
    ranking: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymProfileMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    totalStudents: number | null
    activeStudents: number | null
    equipmentCount: number | null
    level: number | null
    xp: number | null
    xpToNextLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    monthlyStudentGoal: number | null
    avgStudentFrequency: number | null
    equipmentUtilization: number | null
    ranking: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymProfileCountAggregateOutputType = {
    id: number
    gymId: number
    totalStudents: number
    activeStudents: number
    equipmentCount: number
    level: number
    xp: number
    xpToNextLevel: number
    currentStreak: number
    longestStreak: number
    monthlyStudentGoal: number
    avgStudentFrequency: number
    equipmentUtilization: number
    ranking: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymProfileAvgAggregateInputType = {
    totalStudents?: true
    activeStudents?: true
    equipmentCount?: true
    level?: true
    xp?: true
    xpToNextLevel?: true
    currentStreak?: true
    longestStreak?: true
    monthlyStudentGoal?: true
    avgStudentFrequency?: true
    equipmentUtilization?: true
    ranking?: true
  }

  export type GymProfileSumAggregateInputType = {
    totalStudents?: true
    activeStudents?: true
    equipmentCount?: true
    level?: true
    xp?: true
    xpToNextLevel?: true
    currentStreak?: true
    longestStreak?: true
    monthlyStudentGoal?: true
    avgStudentFrequency?: true
    equipmentUtilization?: true
    ranking?: true
  }

  export type GymProfileMinAggregateInputType = {
    id?: true
    gymId?: true
    totalStudents?: true
    activeStudents?: true
    equipmentCount?: true
    level?: true
    xp?: true
    xpToNextLevel?: true
    currentStreak?: true
    longestStreak?: true
    monthlyStudentGoal?: true
    avgStudentFrequency?: true
    equipmentUtilization?: true
    ranking?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymProfileMaxAggregateInputType = {
    id?: true
    gymId?: true
    totalStudents?: true
    activeStudents?: true
    equipmentCount?: true
    level?: true
    xp?: true
    xpToNextLevel?: true
    currentStreak?: true
    longestStreak?: true
    monthlyStudentGoal?: true
    avgStudentFrequency?: true
    equipmentUtilization?: true
    ranking?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymProfileCountAggregateInputType = {
    id?: true
    gymId?: true
    totalStudents?: true
    activeStudents?: true
    equipmentCount?: true
    level?: true
    xp?: true
    xpToNextLevel?: true
    currentStreak?: true
    longestStreak?: true
    monthlyStudentGoal?: true
    avgStudentFrequency?: true
    equipmentUtilization?: true
    ranking?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymProfile to aggregate.
     */
    where?: GymProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymProfiles to fetch.
     */
    orderBy?: GymProfileOrderByWithRelationInput | GymProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymProfiles
    **/
    _count?: true | GymProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymProfileMaxAggregateInputType
  }

  export type GetGymProfileAggregateType<T extends GymProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateGymProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymProfile[P]>
      : GetScalarType<T[P], AggregateGymProfile[P]>
  }




  export type GymProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymProfileWhereInput
    orderBy?: GymProfileOrderByWithAggregationInput | GymProfileOrderByWithAggregationInput[]
    by: GymProfileScalarFieldEnum[] | GymProfileScalarFieldEnum
    having?: GymProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymProfileCountAggregateInputType | true
    _avg?: GymProfileAvgAggregateInputType
    _sum?: GymProfileSumAggregateInputType
    _min?: GymProfileMinAggregateInputType
    _max?: GymProfileMaxAggregateInputType
  }

  export type GymProfileGroupByOutputType = {
    id: string
    gymId: string
    totalStudents: number
    activeStudents: number
    equipmentCount: number
    level: number
    xp: number
    xpToNextLevel: number
    currentStreak: number
    longestStreak: number
    monthlyStudentGoal: number | null
    avgStudentFrequency: number | null
    equipmentUtilization: number | null
    ranking: number | null
    createdAt: Date
    updatedAt: Date
    _count: GymProfileCountAggregateOutputType | null
    _avg: GymProfileAvgAggregateOutputType | null
    _sum: GymProfileSumAggregateOutputType | null
    _min: GymProfileMinAggregateOutputType | null
    _max: GymProfileMaxAggregateOutputType | null
  }

  type GetGymProfileGroupByPayload<T extends GymProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymProfileGroupByOutputType[P]>
            : GetScalarType<T[P], GymProfileGroupByOutputType[P]>
        }
      >
    >


  export type GymProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    totalStudents?: boolean
    activeStudents?: boolean
    equipmentCount?: boolean
    level?: boolean
    xp?: boolean
    xpToNextLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    monthlyStudentGoal?: boolean
    avgStudentFrequency?: boolean
    equipmentUtilization?: boolean
    ranking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymProfile"]>

  export type GymProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    totalStudents?: boolean
    activeStudents?: boolean
    equipmentCount?: boolean
    level?: boolean
    xp?: boolean
    xpToNextLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    monthlyStudentGoal?: boolean
    avgStudentFrequency?: boolean
    equipmentUtilization?: boolean
    ranking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymProfile"]>

  export type GymProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    totalStudents?: boolean
    activeStudents?: boolean
    equipmentCount?: boolean
    level?: boolean
    xp?: boolean
    xpToNextLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    monthlyStudentGoal?: boolean
    avgStudentFrequency?: boolean
    equipmentUtilization?: boolean
    ranking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymProfile"]>

  export type GymProfileSelectScalar = {
    id?: boolean
    gymId?: boolean
    totalStudents?: boolean
    activeStudents?: boolean
    equipmentCount?: boolean
    level?: boolean
    xp?: boolean
    xpToNextLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    monthlyStudentGoal?: boolean
    avgStudentFrequency?: boolean
    equipmentUtilization?: boolean
    ranking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "totalStudents" | "activeStudents" | "equipmentCount" | "level" | "xp" | "xpToNextLevel" | "currentStreak" | "longestStreak" | "monthlyStudentGoal" | "avgStudentFrequency" | "equipmentUtilization" | "ranking" | "createdAt" | "updatedAt", ExtArgs["result"]["gymProfile"]>
  export type GymProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $GymProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymProfile"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      totalStudents: number
      activeStudents: number
      equipmentCount: number
      level: number
      xp: number
      xpToNextLevel: number
      currentStreak: number
      longestStreak: number
      monthlyStudentGoal: number | null
      avgStudentFrequency: number | null
      equipmentUtilization: number | null
      ranking: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymProfile"]>
    composites: {}
  }

  type GymProfileGetPayload<S extends boolean | null | undefined | GymProfileDefaultArgs> = $Result.GetResult<Prisma.$GymProfilePayload, S>

  type GymProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymProfileCountAggregateInputType | true
    }

  export interface GymProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymProfile'], meta: { name: 'GymProfile' } }
    /**
     * Find zero or one GymProfile that matches the filter.
     * @param {GymProfileFindUniqueArgs} args - Arguments to find a GymProfile
     * @example
     * // Get one GymProfile
     * const gymProfile = await prisma.gymProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymProfileFindUniqueArgs>(args: SelectSubset<T, GymProfileFindUniqueArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymProfileFindUniqueOrThrowArgs} args - Arguments to find a GymProfile
     * @example
     * // Get one GymProfile
     * const gymProfile = await prisma.gymProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, GymProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileFindFirstArgs} args - Arguments to find a GymProfile
     * @example
     * // Get one GymProfile
     * const gymProfile = await prisma.gymProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymProfileFindFirstArgs>(args?: SelectSubset<T, GymProfileFindFirstArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileFindFirstOrThrowArgs} args - Arguments to find a GymProfile
     * @example
     * // Get one GymProfile
     * const gymProfile = await prisma.gymProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, GymProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymProfiles
     * const gymProfiles = await prisma.gymProfile.findMany()
     * 
     * // Get first 10 GymProfiles
     * const gymProfiles = await prisma.gymProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymProfileWithIdOnly = await prisma.gymProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymProfileFindManyArgs>(args?: SelectSubset<T, GymProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymProfile.
     * @param {GymProfileCreateArgs} args - Arguments to create a GymProfile.
     * @example
     * // Create one GymProfile
     * const GymProfile = await prisma.gymProfile.create({
     *   data: {
     *     // ... data to create a GymProfile
     *   }
     * })
     * 
     */
    create<T extends GymProfileCreateArgs>(args: SelectSubset<T, GymProfileCreateArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymProfiles.
     * @param {GymProfileCreateManyArgs} args - Arguments to create many GymProfiles.
     * @example
     * // Create many GymProfiles
     * const gymProfile = await prisma.gymProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymProfileCreateManyArgs>(args?: SelectSubset<T, GymProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymProfiles and returns the data saved in the database.
     * @param {GymProfileCreateManyAndReturnArgs} args - Arguments to create many GymProfiles.
     * @example
     * // Create many GymProfiles
     * const gymProfile = await prisma.gymProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymProfiles and only return the `id`
     * const gymProfileWithIdOnly = await prisma.gymProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, GymProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymProfile.
     * @param {GymProfileDeleteArgs} args - Arguments to delete one GymProfile.
     * @example
     * // Delete one GymProfile
     * const GymProfile = await prisma.gymProfile.delete({
     *   where: {
     *     // ... filter to delete one GymProfile
     *   }
     * })
     * 
     */
    delete<T extends GymProfileDeleteArgs>(args: SelectSubset<T, GymProfileDeleteArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymProfile.
     * @param {GymProfileUpdateArgs} args - Arguments to update one GymProfile.
     * @example
     * // Update one GymProfile
     * const gymProfile = await prisma.gymProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymProfileUpdateArgs>(args: SelectSubset<T, GymProfileUpdateArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymProfiles.
     * @param {GymProfileDeleteManyArgs} args - Arguments to filter GymProfiles to delete.
     * @example
     * // Delete a few GymProfiles
     * const { count } = await prisma.gymProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymProfileDeleteManyArgs>(args?: SelectSubset<T, GymProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymProfiles
     * const gymProfile = await prisma.gymProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymProfileUpdateManyArgs>(args: SelectSubset<T, GymProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymProfiles and returns the data updated in the database.
     * @param {GymProfileUpdateManyAndReturnArgs} args - Arguments to update many GymProfiles.
     * @example
     * // Update many GymProfiles
     * const gymProfile = await prisma.gymProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymProfiles and only return the `id`
     * const gymProfileWithIdOnly = await prisma.gymProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, GymProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymProfile.
     * @param {GymProfileUpsertArgs} args - Arguments to update or create a GymProfile.
     * @example
     * // Update or create a GymProfile
     * const gymProfile = await prisma.gymProfile.upsert({
     *   create: {
     *     // ... data to create a GymProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymProfile we want to update
     *   }
     * })
     */
    upsert<T extends GymProfileUpsertArgs>(args: SelectSubset<T, GymProfileUpsertArgs<ExtArgs>>): Prisma__GymProfileClient<$Result.GetResult<Prisma.$GymProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileCountArgs} args - Arguments to filter GymProfiles to count.
     * @example
     * // Count the number of GymProfiles
     * const count = await prisma.gymProfile.count({
     *   where: {
     *     // ... the filter for the GymProfiles we want to count
     *   }
     * })
    **/
    count<T extends GymProfileCountArgs>(
      args?: Subset<T, GymProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymProfileAggregateArgs>(args: Subset<T, GymProfileAggregateArgs>): Prisma.PrismaPromise<GetGymProfileAggregateType<T>>

    /**
     * Group by GymProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymProfileGroupByArgs['orderBy'] }
        : { orderBy?: GymProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymProfile model
   */
  readonly fields: GymProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymProfile model
   */
  interface GymProfileFieldRefs {
    readonly id: FieldRef<"GymProfile", 'String'>
    readonly gymId: FieldRef<"GymProfile", 'String'>
    readonly totalStudents: FieldRef<"GymProfile", 'Int'>
    readonly activeStudents: FieldRef<"GymProfile", 'Int'>
    readonly equipmentCount: FieldRef<"GymProfile", 'Int'>
    readonly level: FieldRef<"GymProfile", 'Int'>
    readonly xp: FieldRef<"GymProfile", 'Int'>
    readonly xpToNextLevel: FieldRef<"GymProfile", 'Int'>
    readonly currentStreak: FieldRef<"GymProfile", 'Int'>
    readonly longestStreak: FieldRef<"GymProfile", 'Int'>
    readonly monthlyStudentGoal: FieldRef<"GymProfile", 'Int'>
    readonly avgStudentFrequency: FieldRef<"GymProfile", 'Float'>
    readonly equipmentUtilization: FieldRef<"GymProfile", 'Float'>
    readonly ranking: FieldRef<"GymProfile", 'Int'>
    readonly createdAt: FieldRef<"GymProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"GymProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymProfile findUnique
   */
  export type GymProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * Filter, which GymProfile to fetch.
     */
    where: GymProfileWhereUniqueInput
  }

  /**
   * GymProfile findUniqueOrThrow
   */
  export type GymProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * Filter, which GymProfile to fetch.
     */
    where: GymProfileWhereUniqueInput
  }

  /**
   * GymProfile findFirst
   */
  export type GymProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * Filter, which GymProfile to fetch.
     */
    where?: GymProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymProfiles to fetch.
     */
    orderBy?: GymProfileOrderByWithRelationInput | GymProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymProfiles.
     */
    cursor?: GymProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymProfiles.
     */
    distinct?: GymProfileScalarFieldEnum | GymProfileScalarFieldEnum[]
  }

  /**
   * GymProfile findFirstOrThrow
   */
  export type GymProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * Filter, which GymProfile to fetch.
     */
    where?: GymProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymProfiles to fetch.
     */
    orderBy?: GymProfileOrderByWithRelationInput | GymProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymProfiles.
     */
    cursor?: GymProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymProfiles.
     */
    distinct?: GymProfileScalarFieldEnum | GymProfileScalarFieldEnum[]
  }

  /**
   * GymProfile findMany
   */
  export type GymProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * Filter, which GymProfiles to fetch.
     */
    where?: GymProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymProfiles to fetch.
     */
    orderBy?: GymProfileOrderByWithRelationInput | GymProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymProfiles.
     */
    cursor?: GymProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymProfiles.
     */
    skip?: number
    distinct?: GymProfileScalarFieldEnum | GymProfileScalarFieldEnum[]
  }

  /**
   * GymProfile create
   */
  export type GymProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a GymProfile.
     */
    data: XOR<GymProfileCreateInput, GymProfileUncheckedCreateInput>
  }

  /**
   * GymProfile createMany
   */
  export type GymProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymProfiles.
     */
    data: GymProfileCreateManyInput | GymProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymProfile createManyAndReturn
   */
  export type GymProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * The data used to create many GymProfiles.
     */
    data: GymProfileCreateManyInput | GymProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymProfile update
   */
  export type GymProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a GymProfile.
     */
    data: XOR<GymProfileUpdateInput, GymProfileUncheckedUpdateInput>
    /**
     * Choose, which GymProfile to update.
     */
    where: GymProfileWhereUniqueInput
  }

  /**
   * GymProfile updateMany
   */
  export type GymProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymProfiles.
     */
    data: XOR<GymProfileUpdateManyMutationInput, GymProfileUncheckedUpdateManyInput>
    /**
     * Filter which GymProfiles to update
     */
    where?: GymProfileWhereInput
    /**
     * Limit how many GymProfiles to update.
     */
    limit?: number
  }

  /**
   * GymProfile updateManyAndReturn
   */
  export type GymProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * The data used to update GymProfiles.
     */
    data: XOR<GymProfileUpdateManyMutationInput, GymProfileUncheckedUpdateManyInput>
    /**
     * Filter which GymProfiles to update
     */
    where?: GymProfileWhereInput
    /**
     * Limit how many GymProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymProfile upsert
   */
  export type GymProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the GymProfile to update in case it exists.
     */
    where: GymProfileWhereUniqueInput
    /**
     * In case the GymProfile found by the `where` argument doesn't exist, create a new GymProfile with this data.
     */
    create: XOR<GymProfileCreateInput, GymProfileUncheckedCreateInput>
    /**
     * In case the GymProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymProfileUpdateInput, GymProfileUncheckedUpdateInput>
  }

  /**
   * GymProfile delete
   */
  export type GymProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
    /**
     * Filter which GymProfile to delete.
     */
    where: GymProfileWhereUniqueInput
  }

  /**
   * GymProfile deleteMany
   */
  export type GymProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymProfiles to delete
     */
    where?: GymProfileWhereInput
    /**
     * Limit how many GymProfiles to delete.
     */
    limit?: number
  }

  /**
   * GymProfile without action
   */
  export type GymProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymProfile
     */
    select?: GymProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymProfile
     */
    omit?: GymProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymProfileInclude<ExtArgs> | null
  }


  /**
   * Model GymStats
   */

  export type AggregateGymStats = {
    _count: GymStatsCountAggregateOutputType | null
    _avg: GymStatsAvgAggregateOutputType | null
    _sum: GymStatsSumAggregateOutputType | null
    _min: GymStatsMinAggregateOutputType | null
    _max: GymStatsMaxAggregateOutputType | null
  }

  export type GymStatsAvgAggregateOutputType = {
    todayCheckins: number | null
    todayActiveStudents: number | null
    todayEquipmentInUse: number | null
    weekTotalCheckins: number | null
    weekAvgDailyCheckins: number | null
    weekNewMembers: number | null
    weekCanceledMembers: number | null
    monthTotalCheckins: number | null
    monthRetentionRate: number | null
    monthGrowthRate: number | null
  }

  export type GymStatsSumAggregateOutputType = {
    todayCheckins: number | null
    todayActiveStudents: number | null
    todayEquipmentInUse: number | null
    weekTotalCheckins: number | null
    weekAvgDailyCheckins: number | null
    weekNewMembers: number | null
    weekCanceledMembers: number | null
    monthTotalCheckins: number | null
    monthRetentionRate: number | null
    monthGrowthRate: number | null
  }

  export type GymStatsMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    todayCheckins: number | null
    todayActiveStudents: number | null
    todayEquipmentInUse: number | null
    weekTotalCheckins: number | null
    weekAvgDailyCheckins: number | null
    weekNewMembers: number | null
    weekCanceledMembers: number | null
    monthTotalCheckins: number | null
    monthRetentionRate: number | null
    monthGrowthRate: number | null
    updatedAt: Date | null
  }

  export type GymStatsMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    todayCheckins: number | null
    todayActiveStudents: number | null
    todayEquipmentInUse: number | null
    weekTotalCheckins: number | null
    weekAvgDailyCheckins: number | null
    weekNewMembers: number | null
    weekCanceledMembers: number | null
    monthTotalCheckins: number | null
    monthRetentionRate: number | null
    monthGrowthRate: number | null
    updatedAt: Date | null
  }

  export type GymStatsCountAggregateOutputType = {
    id: number
    gymId: number
    todayCheckins: number
    todayActiveStudents: number
    todayEquipmentInUse: number
    weekTotalCheckins: number
    weekAvgDailyCheckins: number
    weekNewMembers: number
    weekCanceledMembers: number
    monthTotalCheckins: number
    monthRetentionRate: number
    monthGrowthRate: number
    updatedAt: number
    _all: number
  }


  export type GymStatsAvgAggregateInputType = {
    todayCheckins?: true
    todayActiveStudents?: true
    todayEquipmentInUse?: true
    weekTotalCheckins?: true
    weekAvgDailyCheckins?: true
    weekNewMembers?: true
    weekCanceledMembers?: true
    monthTotalCheckins?: true
    monthRetentionRate?: true
    monthGrowthRate?: true
  }

  export type GymStatsSumAggregateInputType = {
    todayCheckins?: true
    todayActiveStudents?: true
    todayEquipmentInUse?: true
    weekTotalCheckins?: true
    weekAvgDailyCheckins?: true
    weekNewMembers?: true
    weekCanceledMembers?: true
    monthTotalCheckins?: true
    monthRetentionRate?: true
    monthGrowthRate?: true
  }

  export type GymStatsMinAggregateInputType = {
    id?: true
    gymId?: true
    todayCheckins?: true
    todayActiveStudents?: true
    todayEquipmentInUse?: true
    weekTotalCheckins?: true
    weekAvgDailyCheckins?: true
    weekNewMembers?: true
    weekCanceledMembers?: true
    monthTotalCheckins?: true
    monthRetentionRate?: true
    monthGrowthRate?: true
    updatedAt?: true
  }

  export type GymStatsMaxAggregateInputType = {
    id?: true
    gymId?: true
    todayCheckins?: true
    todayActiveStudents?: true
    todayEquipmentInUse?: true
    weekTotalCheckins?: true
    weekAvgDailyCheckins?: true
    weekNewMembers?: true
    weekCanceledMembers?: true
    monthTotalCheckins?: true
    monthRetentionRate?: true
    monthGrowthRate?: true
    updatedAt?: true
  }

  export type GymStatsCountAggregateInputType = {
    id?: true
    gymId?: true
    todayCheckins?: true
    todayActiveStudents?: true
    todayEquipmentInUse?: true
    weekTotalCheckins?: true
    weekAvgDailyCheckins?: true
    weekNewMembers?: true
    weekCanceledMembers?: true
    monthTotalCheckins?: true
    monthRetentionRate?: true
    monthGrowthRate?: true
    updatedAt?: true
    _all?: true
  }

  export type GymStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymStats to aggregate.
     */
    where?: GymStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymStats to fetch.
     */
    orderBy?: GymStatsOrderByWithRelationInput | GymStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymStats
    **/
    _count?: true | GymStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymStatsMaxAggregateInputType
  }

  export type GetGymStatsAggregateType<T extends GymStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateGymStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymStats[P]>
      : GetScalarType<T[P], AggregateGymStats[P]>
  }




  export type GymStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymStatsWhereInput
    orderBy?: GymStatsOrderByWithAggregationInput | GymStatsOrderByWithAggregationInput[]
    by: GymStatsScalarFieldEnum[] | GymStatsScalarFieldEnum
    having?: GymStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymStatsCountAggregateInputType | true
    _avg?: GymStatsAvgAggregateInputType
    _sum?: GymStatsSumAggregateInputType
    _min?: GymStatsMinAggregateInputType
    _max?: GymStatsMaxAggregateInputType
  }

  export type GymStatsGroupByOutputType = {
    id: string
    gymId: string
    todayCheckins: number
    todayActiveStudents: number
    todayEquipmentInUse: number
    weekTotalCheckins: number
    weekAvgDailyCheckins: number
    weekNewMembers: number
    weekCanceledMembers: number
    monthTotalCheckins: number
    monthRetentionRate: number
    monthGrowthRate: number
    updatedAt: Date
    _count: GymStatsCountAggregateOutputType | null
    _avg: GymStatsAvgAggregateOutputType | null
    _sum: GymStatsSumAggregateOutputType | null
    _min: GymStatsMinAggregateOutputType | null
    _max: GymStatsMaxAggregateOutputType | null
  }

  type GetGymStatsGroupByPayload<T extends GymStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymStatsGroupByOutputType[P]>
            : GetScalarType<T[P], GymStatsGroupByOutputType[P]>
        }
      >
    >


  export type GymStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    todayCheckins?: boolean
    todayActiveStudents?: boolean
    todayEquipmentInUse?: boolean
    weekTotalCheckins?: boolean
    weekAvgDailyCheckins?: boolean
    weekNewMembers?: boolean
    weekCanceledMembers?: boolean
    monthTotalCheckins?: boolean
    monthRetentionRate?: boolean
    monthGrowthRate?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymStats"]>

  export type GymStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    todayCheckins?: boolean
    todayActiveStudents?: boolean
    todayEquipmentInUse?: boolean
    weekTotalCheckins?: boolean
    weekAvgDailyCheckins?: boolean
    weekNewMembers?: boolean
    weekCanceledMembers?: boolean
    monthTotalCheckins?: boolean
    monthRetentionRate?: boolean
    monthGrowthRate?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymStats"]>

  export type GymStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    todayCheckins?: boolean
    todayActiveStudents?: boolean
    todayEquipmentInUse?: boolean
    weekTotalCheckins?: boolean
    weekAvgDailyCheckins?: boolean
    weekNewMembers?: boolean
    weekCanceledMembers?: boolean
    monthTotalCheckins?: boolean
    monthRetentionRate?: boolean
    monthGrowthRate?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymStats"]>

  export type GymStatsSelectScalar = {
    id?: boolean
    gymId?: boolean
    todayCheckins?: boolean
    todayActiveStudents?: boolean
    todayEquipmentInUse?: boolean
    weekTotalCheckins?: boolean
    weekAvgDailyCheckins?: boolean
    weekNewMembers?: boolean
    weekCanceledMembers?: boolean
    monthTotalCheckins?: boolean
    monthRetentionRate?: boolean
    monthGrowthRate?: boolean
    updatedAt?: boolean
  }

  export type GymStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "todayCheckins" | "todayActiveStudents" | "todayEquipmentInUse" | "weekTotalCheckins" | "weekAvgDailyCheckins" | "weekNewMembers" | "weekCanceledMembers" | "monthTotalCheckins" | "monthRetentionRate" | "monthGrowthRate" | "updatedAt", ExtArgs["result"]["gymStats"]>
  export type GymStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $GymStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymStats"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      todayCheckins: number
      todayActiveStudents: number
      todayEquipmentInUse: number
      weekTotalCheckins: number
      weekAvgDailyCheckins: number
      weekNewMembers: number
      weekCanceledMembers: number
      monthTotalCheckins: number
      monthRetentionRate: number
      monthGrowthRate: number
      updatedAt: Date
    }, ExtArgs["result"]["gymStats"]>
    composites: {}
  }

  type GymStatsGetPayload<S extends boolean | null | undefined | GymStatsDefaultArgs> = $Result.GetResult<Prisma.$GymStatsPayload, S>

  type GymStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymStatsCountAggregateInputType | true
    }

  export interface GymStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymStats'], meta: { name: 'GymStats' } }
    /**
     * Find zero or one GymStats that matches the filter.
     * @param {GymStatsFindUniqueArgs} args - Arguments to find a GymStats
     * @example
     * // Get one GymStats
     * const gymStats = await prisma.gymStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymStatsFindUniqueArgs>(args: SelectSubset<T, GymStatsFindUniqueArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymStatsFindUniqueOrThrowArgs} args - Arguments to find a GymStats
     * @example
     * // Get one GymStats
     * const gymStats = await prisma.gymStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, GymStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsFindFirstArgs} args - Arguments to find a GymStats
     * @example
     * // Get one GymStats
     * const gymStats = await prisma.gymStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymStatsFindFirstArgs>(args?: SelectSubset<T, GymStatsFindFirstArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsFindFirstOrThrowArgs} args - Arguments to find a GymStats
     * @example
     * // Get one GymStats
     * const gymStats = await prisma.gymStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, GymStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymStats
     * const gymStats = await prisma.gymStats.findMany()
     * 
     * // Get first 10 GymStats
     * const gymStats = await prisma.gymStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymStatsWithIdOnly = await prisma.gymStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymStatsFindManyArgs>(args?: SelectSubset<T, GymStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymStats.
     * @param {GymStatsCreateArgs} args - Arguments to create a GymStats.
     * @example
     * // Create one GymStats
     * const GymStats = await prisma.gymStats.create({
     *   data: {
     *     // ... data to create a GymStats
     *   }
     * })
     * 
     */
    create<T extends GymStatsCreateArgs>(args: SelectSubset<T, GymStatsCreateArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymStats.
     * @param {GymStatsCreateManyArgs} args - Arguments to create many GymStats.
     * @example
     * // Create many GymStats
     * const gymStats = await prisma.gymStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymStatsCreateManyArgs>(args?: SelectSubset<T, GymStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymStats and returns the data saved in the database.
     * @param {GymStatsCreateManyAndReturnArgs} args - Arguments to create many GymStats.
     * @example
     * // Create many GymStats
     * const gymStats = await prisma.gymStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymStats and only return the `id`
     * const gymStatsWithIdOnly = await prisma.gymStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, GymStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymStats.
     * @param {GymStatsDeleteArgs} args - Arguments to delete one GymStats.
     * @example
     * // Delete one GymStats
     * const GymStats = await prisma.gymStats.delete({
     *   where: {
     *     // ... filter to delete one GymStats
     *   }
     * })
     * 
     */
    delete<T extends GymStatsDeleteArgs>(args: SelectSubset<T, GymStatsDeleteArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymStats.
     * @param {GymStatsUpdateArgs} args - Arguments to update one GymStats.
     * @example
     * // Update one GymStats
     * const gymStats = await prisma.gymStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymStatsUpdateArgs>(args: SelectSubset<T, GymStatsUpdateArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymStats.
     * @param {GymStatsDeleteManyArgs} args - Arguments to filter GymStats to delete.
     * @example
     * // Delete a few GymStats
     * const { count } = await prisma.gymStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymStatsDeleteManyArgs>(args?: SelectSubset<T, GymStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymStats
     * const gymStats = await prisma.gymStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymStatsUpdateManyArgs>(args: SelectSubset<T, GymStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymStats and returns the data updated in the database.
     * @param {GymStatsUpdateManyAndReturnArgs} args - Arguments to update many GymStats.
     * @example
     * // Update many GymStats
     * const gymStats = await prisma.gymStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymStats and only return the `id`
     * const gymStatsWithIdOnly = await prisma.gymStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, GymStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymStats.
     * @param {GymStatsUpsertArgs} args - Arguments to update or create a GymStats.
     * @example
     * // Update or create a GymStats
     * const gymStats = await prisma.gymStats.upsert({
     *   create: {
     *     // ... data to create a GymStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymStats we want to update
     *   }
     * })
     */
    upsert<T extends GymStatsUpsertArgs>(args: SelectSubset<T, GymStatsUpsertArgs<ExtArgs>>): Prisma__GymStatsClient<$Result.GetResult<Prisma.$GymStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsCountArgs} args - Arguments to filter GymStats to count.
     * @example
     * // Count the number of GymStats
     * const count = await prisma.gymStats.count({
     *   where: {
     *     // ... the filter for the GymStats we want to count
     *   }
     * })
    **/
    count<T extends GymStatsCountArgs>(
      args?: Subset<T, GymStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymStatsAggregateArgs>(args: Subset<T, GymStatsAggregateArgs>): Prisma.PrismaPromise<GetGymStatsAggregateType<T>>

    /**
     * Group by GymStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymStatsGroupByArgs['orderBy'] }
        : { orderBy?: GymStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymStats model
   */
  readonly fields: GymStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymStats model
   */
  interface GymStatsFieldRefs {
    readonly id: FieldRef<"GymStats", 'String'>
    readonly gymId: FieldRef<"GymStats", 'String'>
    readonly todayCheckins: FieldRef<"GymStats", 'Int'>
    readonly todayActiveStudents: FieldRef<"GymStats", 'Int'>
    readonly todayEquipmentInUse: FieldRef<"GymStats", 'Int'>
    readonly weekTotalCheckins: FieldRef<"GymStats", 'Int'>
    readonly weekAvgDailyCheckins: FieldRef<"GymStats", 'Float'>
    readonly weekNewMembers: FieldRef<"GymStats", 'Int'>
    readonly weekCanceledMembers: FieldRef<"GymStats", 'Int'>
    readonly monthTotalCheckins: FieldRef<"GymStats", 'Int'>
    readonly monthRetentionRate: FieldRef<"GymStats", 'Float'>
    readonly monthGrowthRate: FieldRef<"GymStats", 'Float'>
    readonly updatedAt: FieldRef<"GymStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymStats findUnique
   */
  export type GymStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * Filter, which GymStats to fetch.
     */
    where: GymStatsWhereUniqueInput
  }

  /**
   * GymStats findUniqueOrThrow
   */
  export type GymStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * Filter, which GymStats to fetch.
     */
    where: GymStatsWhereUniqueInput
  }

  /**
   * GymStats findFirst
   */
  export type GymStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * Filter, which GymStats to fetch.
     */
    where?: GymStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymStats to fetch.
     */
    orderBy?: GymStatsOrderByWithRelationInput | GymStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymStats.
     */
    cursor?: GymStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymStats.
     */
    distinct?: GymStatsScalarFieldEnum | GymStatsScalarFieldEnum[]
  }

  /**
   * GymStats findFirstOrThrow
   */
  export type GymStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * Filter, which GymStats to fetch.
     */
    where?: GymStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymStats to fetch.
     */
    orderBy?: GymStatsOrderByWithRelationInput | GymStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymStats.
     */
    cursor?: GymStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymStats.
     */
    distinct?: GymStatsScalarFieldEnum | GymStatsScalarFieldEnum[]
  }

  /**
   * GymStats findMany
   */
  export type GymStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * Filter, which GymStats to fetch.
     */
    where?: GymStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymStats to fetch.
     */
    orderBy?: GymStatsOrderByWithRelationInput | GymStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymStats.
     */
    cursor?: GymStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymStats.
     */
    skip?: number
    distinct?: GymStatsScalarFieldEnum | GymStatsScalarFieldEnum[]
  }

  /**
   * GymStats create
   */
  export type GymStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a GymStats.
     */
    data: XOR<GymStatsCreateInput, GymStatsUncheckedCreateInput>
  }

  /**
   * GymStats createMany
   */
  export type GymStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymStats.
     */
    data: GymStatsCreateManyInput | GymStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymStats createManyAndReturn
   */
  export type GymStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * The data used to create many GymStats.
     */
    data: GymStatsCreateManyInput | GymStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymStats update
   */
  export type GymStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a GymStats.
     */
    data: XOR<GymStatsUpdateInput, GymStatsUncheckedUpdateInput>
    /**
     * Choose, which GymStats to update.
     */
    where: GymStatsWhereUniqueInput
  }

  /**
   * GymStats updateMany
   */
  export type GymStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymStats.
     */
    data: XOR<GymStatsUpdateManyMutationInput, GymStatsUncheckedUpdateManyInput>
    /**
     * Filter which GymStats to update
     */
    where?: GymStatsWhereInput
    /**
     * Limit how many GymStats to update.
     */
    limit?: number
  }

  /**
   * GymStats updateManyAndReturn
   */
  export type GymStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * The data used to update GymStats.
     */
    data: XOR<GymStatsUpdateManyMutationInput, GymStatsUncheckedUpdateManyInput>
    /**
     * Filter which GymStats to update
     */
    where?: GymStatsWhereInput
    /**
     * Limit how many GymStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymStats upsert
   */
  export type GymStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the GymStats to update in case it exists.
     */
    where: GymStatsWhereUniqueInput
    /**
     * In case the GymStats found by the `where` argument doesn't exist, create a new GymStats with this data.
     */
    create: XOR<GymStatsCreateInput, GymStatsUncheckedCreateInput>
    /**
     * In case the GymStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymStatsUpdateInput, GymStatsUncheckedUpdateInput>
  }

  /**
   * GymStats delete
   */
  export type GymStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
    /**
     * Filter which GymStats to delete.
     */
    where: GymStatsWhereUniqueInput
  }

  /**
   * GymStats deleteMany
   */
  export type GymStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymStats to delete
     */
    where?: GymStatsWhereInput
    /**
     * Limit how many GymStats to delete.
     */
    limit?: number
  }

  /**
   * GymStats without action
   */
  export type GymStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymStats
     */
    select?: GymStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymStats
     */
    omit?: GymStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymStatsInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    order: number | null
  }

  export type UnitSumAggregateOutputType = {
    order: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    color: string | null
    icon: string | null
    order: number | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    color: string | null
    icon: string | null
    order: number | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    title: number
    description: number
    color: number
    icon: number
    order: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    order?: true
  }

  export type UnitSumAggregateInputType = {
    order?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    color?: true
    icon?: true
    order?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    color?: true
    icon?: true
    order?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    color?: true
    icon?: true
    order?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    title: string
    description: string | null
    color: string | null
    icon: string | null
    order: number
    studentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    order?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Unit$studentArgs<ExtArgs>
    workouts?: boolean | Unit$workoutsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    order?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Unit$studentArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    order?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Unit$studentArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    order?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "color" | "icon" | "order" | "studentId" | "createdAt" | "updatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Unit$studentArgs<ExtArgs>
    workouts?: boolean | Unit$workoutsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Unit$studentArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Unit$studentArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      workouts: Prisma.$WorkoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      color: string | null
      icon: string | null
      order: number
      studentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends Unit$studentArgs<ExtArgs> = {}>(args?: Subset<T, Unit$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workouts<T extends Unit$workoutsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$workoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly title: FieldRef<"Unit", 'String'>
    readonly description: FieldRef<"Unit", 'String'>
    readonly color: FieldRef<"Unit", 'String'>
    readonly icon: FieldRef<"Unit", 'String'>
    readonly order: FieldRef<"Unit", 'Int'>
    readonly studentId: FieldRef<"Unit", 'String'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.student
   */
  export type Unit$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Unit.workouts
   */
  export type Unit$workoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    where?: WorkoutWhereInput
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    cursor?: WorkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Workout
   */

  export type AggregateWorkout = {
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  export type WorkoutAvgAggregateOutputType = {
    xpReward: number | null
    estimatedTime: number | null
    order: number | null
  }

  export type WorkoutSumAggregateOutputType = {
    xpReward: number | null
    estimatedTime: number | null
    order: number | null
  }

  export type WorkoutMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    title: string | null
    description: string | null
    type: string | null
    muscleGroup: string | null
    difficulty: string | null
    xpReward: number | null
    estimatedTime: number | null
    order: number | null
    locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    title: string | null
    description: string | null
    type: string | null
    muscleGroup: string | null
    difficulty: string | null
    xpReward: number | null
    estimatedTime: number | null
    order: number | null
    locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutCountAggregateOutputType = {
    id: number
    unitId: number
    title: number
    description: number
    type: number
    muscleGroup: number
    difficulty: number
    xpReward: number
    estimatedTime: number
    order: number
    locked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkoutAvgAggregateInputType = {
    xpReward?: true
    estimatedTime?: true
    order?: true
  }

  export type WorkoutSumAggregateInputType = {
    xpReward?: true
    estimatedTime?: true
    order?: true
  }

  export type WorkoutMinAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    type?: true
    muscleGroup?: true
    difficulty?: true
    xpReward?: true
    estimatedTime?: true
    order?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutMaxAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    type?: true
    muscleGroup?: true
    difficulty?: true
    xpReward?: true
    estimatedTime?: true
    order?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutCountAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    type?: true
    muscleGroup?: true
    difficulty?: true
    xpReward?: true
    estimatedTime?: true
    order?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workout to aggregate.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workouts
    **/
    _count?: true | WorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutMaxAggregateInputType
  }

  export type GetWorkoutAggregateType<T extends WorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkout[P]>
      : GetScalarType<T[P], AggregateWorkout[P]>
  }




  export type WorkoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutWhereInput
    orderBy?: WorkoutOrderByWithAggregationInput | WorkoutOrderByWithAggregationInput[]
    by: WorkoutScalarFieldEnum[] | WorkoutScalarFieldEnum
    having?: WorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutCountAggregateInputType | true
    _avg?: WorkoutAvgAggregateInputType
    _sum?: WorkoutSumAggregateInputType
    _min?: WorkoutMinAggregateInputType
    _max?: WorkoutMaxAggregateInputType
  }

  export type WorkoutGroupByOutputType = {
    id: string
    unitId: string | null
    title: string
    description: string | null
    type: string
    muscleGroup: string
    difficulty: string
    xpReward: number
    estimatedTime: number
    order: number
    locked: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  type GetWorkoutGroupByPayload<T extends WorkoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    muscleGroup?: boolean
    difficulty?: boolean
    xpReward?: boolean
    estimatedTime?: boolean
    order?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | Workout$unitArgs<ExtArgs>
    exercises?: boolean | Workout$exercisesArgs<ExtArgs>
    completions?: boolean | Workout$completionsArgs<ExtArgs>
    progress?: boolean | Workout$progressArgs<ExtArgs>
    _count?: boolean | WorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    muscleGroup?: boolean
    difficulty?: boolean
    xpReward?: boolean
    estimatedTime?: boolean
    order?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | Workout$unitArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    muscleGroup?: boolean
    difficulty?: boolean
    xpReward?: boolean
    estimatedTime?: boolean
    order?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | Workout$unitArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectScalar = {
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    muscleGroup?: boolean
    difficulty?: boolean
    xpReward?: boolean
    estimatedTime?: boolean
    order?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "title" | "description" | "type" | "muscleGroup" | "difficulty" | "xpReward" | "estimatedTime" | "order" | "locked" | "createdAt" | "updatedAt", ExtArgs["result"]["workout"]>
  export type WorkoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Workout$unitArgs<ExtArgs>
    exercises?: boolean | Workout$exercisesArgs<ExtArgs>
    completions?: boolean | Workout$completionsArgs<ExtArgs>
    progress?: boolean | Workout$progressArgs<ExtArgs>
    _count?: boolean | WorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Workout$unitArgs<ExtArgs>
  }
  export type WorkoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Workout$unitArgs<ExtArgs>
  }

  export type $WorkoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workout"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs> | null
      exercises: Prisma.$WorkoutExercisePayload<ExtArgs>[]
      completions: Prisma.$WorkoutHistoryPayload<ExtArgs>[]
      progress: Prisma.$WorkoutProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string | null
      title: string
      description: string | null
      type: string
      muscleGroup: string
      difficulty: string
      xpReward: number
      estimatedTime: number
      order: number
      locked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workout"]>
    composites: {}
  }

  type WorkoutGetPayload<S extends boolean | null | undefined | WorkoutDefaultArgs> = $Result.GetResult<Prisma.$WorkoutPayload, S>

  type WorkoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutCountAggregateInputType | true
    }

  export interface WorkoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workout'], meta: { name: 'Workout' } }
    /**
     * Find zero or one Workout that matches the filter.
     * @param {WorkoutFindUniqueArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutFindUniqueArgs>(args: SelectSubset<T, WorkoutFindUniqueArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutFindUniqueOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutFindFirstArgs>(args?: SelectSubset<T, WorkoutFindFirstArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workouts
     * const workouts = await prisma.workout.findMany()
     * 
     * // Get first 10 Workouts
     * const workouts = await prisma.workout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutWithIdOnly = await prisma.workout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutFindManyArgs>(args?: SelectSubset<T, WorkoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workout.
     * @param {WorkoutCreateArgs} args - Arguments to create a Workout.
     * @example
     * // Create one Workout
     * const Workout = await prisma.workout.create({
     *   data: {
     *     // ... data to create a Workout
     *   }
     * })
     * 
     */
    create<T extends WorkoutCreateArgs>(args: SelectSubset<T, WorkoutCreateArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workouts.
     * @param {WorkoutCreateManyArgs} args - Arguments to create many Workouts.
     * @example
     * // Create many Workouts
     * const workout = await prisma.workout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutCreateManyArgs>(args?: SelectSubset<T, WorkoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workouts and returns the data saved in the database.
     * @param {WorkoutCreateManyAndReturnArgs} args - Arguments to create many Workouts.
     * @example
     * // Create many Workouts
     * const workout = await prisma.workout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workouts and only return the `id`
     * const workoutWithIdOnly = await prisma.workout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workout.
     * @param {WorkoutDeleteArgs} args - Arguments to delete one Workout.
     * @example
     * // Delete one Workout
     * const Workout = await prisma.workout.delete({
     *   where: {
     *     // ... filter to delete one Workout
     *   }
     * })
     * 
     */
    delete<T extends WorkoutDeleteArgs>(args: SelectSubset<T, WorkoutDeleteArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workout.
     * @param {WorkoutUpdateArgs} args - Arguments to update one Workout.
     * @example
     * // Update one Workout
     * const workout = await prisma.workout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutUpdateArgs>(args: SelectSubset<T, WorkoutUpdateArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workouts.
     * @param {WorkoutDeleteManyArgs} args - Arguments to filter Workouts to delete.
     * @example
     * // Delete a few Workouts
     * const { count } = await prisma.workout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutDeleteManyArgs>(args?: SelectSubset<T, WorkoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutUpdateManyArgs>(args: SelectSubset<T, WorkoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts and returns the data updated in the database.
     * @param {WorkoutUpdateManyAndReturnArgs} args - Arguments to update many Workouts.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workouts and only return the `id`
     * const workoutWithIdOnly = await prisma.workout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workout.
     * @param {WorkoutUpsertArgs} args - Arguments to update or create a Workout.
     * @example
     * // Update or create a Workout
     * const workout = await prisma.workout.upsert({
     *   create: {
     *     // ... data to create a Workout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workout we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutUpsertArgs>(args: SelectSubset<T, WorkoutUpsertArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutCountArgs} args - Arguments to filter Workouts to count.
     * @example
     * // Count the number of Workouts
     * const count = await prisma.workout.count({
     *   where: {
     *     // ... the filter for the Workouts we want to count
     *   }
     * })
    **/
    count<T extends WorkoutCountArgs>(
      args?: Subset<T, WorkoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutAggregateArgs>(args: Subset<T, WorkoutAggregateArgs>): Prisma.PrismaPromise<GetWorkoutAggregateType<T>>

    /**
     * Group by Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workout model
   */
  readonly fields: WorkoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends Workout$unitArgs<ExtArgs> = {}>(args?: Subset<T, Workout$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    exercises<T extends Workout$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Workout$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completions<T extends Workout$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Workout$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Workout$progressArgs<ExtArgs> = {}>(args?: Subset<T, Workout$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workout model
   */
  interface WorkoutFieldRefs {
    readonly id: FieldRef<"Workout", 'String'>
    readonly unitId: FieldRef<"Workout", 'String'>
    readonly title: FieldRef<"Workout", 'String'>
    readonly description: FieldRef<"Workout", 'String'>
    readonly type: FieldRef<"Workout", 'String'>
    readonly muscleGroup: FieldRef<"Workout", 'String'>
    readonly difficulty: FieldRef<"Workout", 'String'>
    readonly xpReward: FieldRef<"Workout", 'Int'>
    readonly estimatedTime: FieldRef<"Workout", 'Int'>
    readonly order: FieldRef<"Workout", 'Int'>
    readonly locked: FieldRef<"Workout", 'Boolean'>
    readonly createdAt: FieldRef<"Workout", 'DateTime'>
    readonly updatedAt: FieldRef<"Workout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workout findUnique
   */
  export type WorkoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findUniqueOrThrow
   */
  export type WorkoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findFirst
   */
  export type WorkoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout findFirstOrThrow
   */
  export type WorkoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout findMany
   */
  export type WorkoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workouts to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout create
   */
  export type WorkoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Workout.
     */
    data: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
  }

  /**
   * Workout createMany
   */
  export type WorkoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workouts.
     */
    data: WorkoutCreateManyInput | WorkoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workout createManyAndReturn
   */
  export type WorkoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * The data used to create many Workouts.
     */
    data: WorkoutCreateManyInput | WorkoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workout update
   */
  export type WorkoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Workout.
     */
    data: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
    /**
     * Choose, which Workout to update.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout updateMany
   */
  export type WorkoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workouts.
     */
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    /**
     * Filter which Workouts to update
     */
    where?: WorkoutWhereInput
    /**
     * Limit how many Workouts to update.
     */
    limit?: number
  }

  /**
   * Workout updateManyAndReturn
   */
  export type WorkoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * The data used to update Workouts.
     */
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    /**
     * Filter which Workouts to update
     */
    where?: WorkoutWhereInput
    /**
     * Limit how many Workouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workout upsert
   */
  export type WorkoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Workout to update in case it exists.
     */
    where: WorkoutWhereUniqueInput
    /**
     * In case the Workout found by the `where` argument doesn't exist, create a new Workout with this data.
     */
    create: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
    /**
     * In case the Workout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
  }

  /**
   * Workout delete
   */
  export type WorkoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter which Workout to delete.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout deleteMany
   */
  export type WorkoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workouts to delete
     */
    where?: WorkoutWhereInput
    /**
     * Limit how many Workouts to delete.
     */
    limit?: number
  }

  /**
   * Workout.unit
   */
  export type Workout$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Workout.exercises
   */
  export type Workout$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    where?: WorkoutExerciseWhereInput
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    cursor?: WorkoutExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * Workout.completions
   */
  export type Workout$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    where?: WorkoutHistoryWhereInput
    orderBy?: WorkoutHistoryOrderByWithRelationInput | WorkoutHistoryOrderByWithRelationInput[]
    cursor?: WorkoutHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutHistoryScalarFieldEnum | WorkoutHistoryScalarFieldEnum[]
  }

  /**
   * Workout.progress
   */
  export type Workout$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    where?: WorkoutProgressWhereInput
    orderBy?: WorkoutProgressOrderByWithRelationInput | WorkoutProgressOrderByWithRelationInput[]
    cursor?: WorkoutProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutProgressScalarFieldEnum | WorkoutProgressScalarFieldEnum[]
  }

  /**
   * Workout without action
   */
  export type WorkoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutExercise
   */

  export type AggregateWorkoutExercise = {
    _count: WorkoutExerciseCountAggregateOutputType | null
    _avg: WorkoutExerciseAvgAggregateOutputType | null
    _sum: WorkoutExerciseSumAggregateOutputType | null
    _min: WorkoutExerciseMinAggregateOutputType | null
    _max: WorkoutExerciseMaxAggregateOutputType | null
  }

  export type WorkoutExerciseAvgAggregateOutputType = {
    sets: number | null
    rest: number | null
    order: number | null
  }

  export type WorkoutExerciseSumAggregateOutputType = {
    sets: number | null
    rest: number | null
    order: number | null
  }

  export type WorkoutExerciseMinAggregateOutputType = {
    id: string | null
    workoutId: string | null
    name: string | null
    sets: number | null
    reps: string | null
    rest: number | null
    notes: string | null
    videoUrl: string | null
    educationalId: string | null
    order: number | null
    primaryMuscles: string | null
    secondaryMuscles: string | null
    difficulty: string | null
    equipment: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    benefits: string | null
    scientificEvidence: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutExerciseMaxAggregateOutputType = {
    id: string | null
    workoutId: string | null
    name: string | null
    sets: number | null
    reps: string | null
    rest: number | null
    notes: string | null
    videoUrl: string | null
    educationalId: string | null
    order: number | null
    primaryMuscles: string | null
    secondaryMuscles: string | null
    difficulty: string | null
    equipment: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    benefits: string | null
    scientificEvidence: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutExerciseCountAggregateOutputType = {
    id: number
    workoutId: number
    name: number
    sets: number
    reps: number
    rest: number
    notes: number
    videoUrl: number
    educationalId: number
    order: number
    primaryMuscles: number
    secondaryMuscles: number
    difficulty: number
    equipment: number
    instructions: number
    tips: number
    commonMistakes: number
    benefits: number
    scientificEvidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkoutExerciseAvgAggregateInputType = {
    sets?: true
    rest?: true
    order?: true
  }

  export type WorkoutExerciseSumAggregateInputType = {
    sets?: true
    rest?: true
    order?: true
  }

  export type WorkoutExerciseMinAggregateInputType = {
    id?: true
    workoutId?: true
    name?: true
    sets?: true
    reps?: true
    rest?: true
    notes?: true
    videoUrl?: true
    educationalId?: true
    order?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    difficulty?: true
    equipment?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    benefits?: true
    scientificEvidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutExerciseMaxAggregateInputType = {
    id?: true
    workoutId?: true
    name?: true
    sets?: true
    reps?: true
    rest?: true
    notes?: true
    videoUrl?: true
    educationalId?: true
    order?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    difficulty?: true
    equipment?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    benefits?: true
    scientificEvidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutExerciseCountAggregateInputType = {
    id?: true
    workoutId?: true
    name?: true
    sets?: true
    reps?: true
    rest?: true
    notes?: true
    videoUrl?: true
    educationalId?: true
    order?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    difficulty?: true
    equipment?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    benefits?: true
    scientificEvidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkoutExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutExercise to aggregate.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutExercises
    **/
    _count?: true | WorkoutExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutExerciseMaxAggregateInputType
  }

  export type GetWorkoutExerciseAggregateType<T extends WorkoutExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutExercise[P]>
      : GetScalarType<T[P], AggregateWorkoutExercise[P]>
  }




  export type WorkoutExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutExerciseWhereInput
    orderBy?: WorkoutExerciseOrderByWithAggregationInput | WorkoutExerciseOrderByWithAggregationInput[]
    by: WorkoutExerciseScalarFieldEnum[] | WorkoutExerciseScalarFieldEnum
    having?: WorkoutExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutExerciseCountAggregateInputType | true
    _avg?: WorkoutExerciseAvgAggregateInputType
    _sum?: WorkoutExerciseSumAggregateInputType
    _min?: WorkoutExerciseMinAggregateInputType
    _max?: WorkoutExerciseMaxAggregateInputType
  }

  export type WorkoutExerciseGroupByOutputType = {
    id: string
    workoutId: string
    name: string
    sets: number
    reps: string
    rest: number
    notes: string | null
    videoUrl: string | null
    educationalId: string | null
    order: number
    primaryMuscles: string | null
    secondaryMuscles: string | null
    difficulty: string | null
    equipment: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    benefits: string | null
    scientificEvidence: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkoutExerciseCountAggregateOutputType | null
    _avg: WorkoutExerciseAvgAggregateOutputType | null
    _sum: WorkoutExerciseSumAggregateOutputType | null
    _min: WorkoutExerciseMinAggregateOutputType | null
    _max: WorkoutExerciseMaxAggregateOutputType | null
  }

  type GetWorkoutExerciseGroupByPayload<T extends WorkoutExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutExerciseGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    name?: boolean
    sets?: boolean
    reps?: boolean
    rest?: boolean
    notes?: boolean
    videoUrl?: boolean
    educationalId?: boolean
    order?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    equipment?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    benefits?: boolean
    scientificEvidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    alternatives?: boolean | WorkoutExercise$alternativesArgs<ExtArgs>
    _count?: boolean | WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutExercise"]>

  export type WorkoutExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    name?: boolean
    sets?: boolean
    reps?: boolean
    rest?: boolean
    notes?: boolean
    videoUrl?: boolean
    educationalId?: boolean
    order?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    equipment?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    benefits?: boolean
    scientificEvidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutExercise"]>

  export type WorkoutExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    name?: boolean
    sets?: boolean
    reps?: boolean
    rest?: boolean
    notes?: boolean
    videoUrl?: boolean
    educationalId?: boolean
    order?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    equipment?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    benefits?: boolean
    scientificEvidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutExercise"]>

  export type WorkoutExerciseSelectScalar = {
    id?: boolean
    workoutId?: boolean
    name?: boolean
    sets?: boolean
    reps?: boolean
    rest?: boolean
    notes?: boolean
    videoUrl?: boolean
    educationalId?: boolean
    order?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    equipment?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    benefits?: boolean
    scientificEvidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkoutExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workoutId" | "name" | "sets" | "reps" | "rest" | "notes" | "videoUrl" | "educationalId" | "order" | "primaryMuscles" | "secondaryMuscles" | "difficulty" | "equipment" | "instructions" | "tips" | "commonMistakes" | "benefits" | "scientificEvidence" | "createdAt" | "updatedAt", ExtArgs["result"]["workoutExercise"]>
  export type WorkoutExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    alternatives?: boolean | WorkoutExercise$alternativesArgs<ExtArgs>
    _count?: boolean | WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }
  export type WorkoutExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }

  export type $WorkoutExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutExercise"
    objects: {
      workout: Prisma.$WorkoutPayload<ExtArgs>
      alternatives: Prisma.$AlternativeExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workoutId: string
      name: string
      sets: number
      reps: string
      rest: number
      notes: string | null
      videoUrl: string | null
      educationalId: string | null
      order: number
      primaryMuscles: string | null
      secondaryMuscles: string | null
      difficulty: string | null
      equipment: string | null
      instructions: string | null
      tips: string | null
      commonMistakes: string | null
      benefits: string | null
      scientificEvidence: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workoutExercise"]>
    composites: {}
  }

  type WorkoutExerciseGetPayload<S extends boolean | null | undefined | WorkoutExerciseDefaultArgs> = $Result.GetResult<Prisma.$WorkoutExercisePayload, S>

  type WorkoutExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutExerciseCountAggregateInputType | true
    }

  export interface WorkoutExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutExercise'], meta: { name: 'WorkoutExercise' } }
    /**
     * Find zero or one WorkoutExercise that matches the filter.
     * @param {WorkoutExerciseFindUniqueArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutExerciseFindUniqueArgs>(args: SelectSubset<T, WorkoutExerciseFindUniqueArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutExerciseFindUniqueOrThrowArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindFirstArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutExerciseFindFirstArgs>(args?: SelectSubset<T, WorkoutExerciseFindFirstArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindFirstOrThrowArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutExercises
     * const workoutExercises = await prisma.workoutExercise.findMany()
     * 
     * // Get first 10 WorkoutExercises
     * const workoutExercises = await prisma.workoutExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutExerciseWithIdOnly = await prisma.workoutExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutExerciseFindManyArgs>(args?: SelectSubset<T, WorkoutExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutExercise.
     * @param {WorkoutExerciseCreateArgs} args - Arguments to create a WorkoutExercise.
     * @example
     * // Create one WorkoutExercise
     * const WorkoutExercise = await prisma.workoutExercise.create({
     *   data: {
     *     // ... data to create a WorkoutExercise
     *   }
     * })
     * 
     */
    create<T extends WorkoutExerciseCreateArgs>(args: SelectSubset<T, WorkoutExerciseCreateArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutExercises.
     * @param {WorkoutExerciseCreateManyArgs} args - Arguments to create many WorkoutExercises.
     * @example
     * // Create many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutExerciseCreateManyArgs>(args?: SelectSubset<T, WorkoutExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutExercises and returns the data saved in the database.
     * @param {WorkoutExerciseCreateManyAndReturnArgs} args - Arguments to create many WorkoutExercises.
     * @example
     * // Create many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutExercises and only return the `id`
     * const workoutExerciseWithIdOnly = await prisma.workoutExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutExercise.
     * @param {WorkoutExerciseDeleteArgs} args - Arguments to delete one WorkoutExercise.
     * @example
     * // Delete one WorkoutExercise
     * const WorkoutExercise = await prisma.workoutExercise.delete({
     *   where: {
     *     // ... filter to delete one WorkoutExercise
     *   }
     * })
     * 
     */
    delete<T extends WorkoutExerciseDeleteArgs>(args: SelectSubset<T, WorkoutExerciseDeleteArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutExercise.
     * @param {WorkoutExerciseUpdateArgs} args - Arguments to update one WorkoutExercise.
     * @example
     * // Update one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutExerciseUpdateArgs>(args: SelectSubset<T, WorkoutExerciseUpdateArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutExercises.
     * @param {WorkoutExerciseDeleteManyArgs} args - Arguments to filter WorkoutExercises to delete.
     * @example
     * // Delete a few WorkoutExercises
     * const { count } = await prisma.workoutExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutExerciseDeleteManyArgs>(args?: SelectSubset<T, WorkoutExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutExerciseUpdateManyArgs>(args: SelectSubset<T, WorkoutExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutExercises and returns the data updated in the database.
     * @param {WorkoutExerciseUpdateManyAndReturnArgs} args - Arguments to update many WorkoutExercises.
     * @example
     * // Update many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutExercises and only return the `id`
     * const workoutExerciseWithIdOnly = await prisma.workoutExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutExercise.
     * @param {WorkoutExerciseUpsertArgs} args - Arguments to update or create a WorkoutExercise.
     * @example
     * // Update or create a WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.upsert({
     *   create: {
     *     // ... data to create a WorkoutExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutExercise we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutExerciseUpsertArgs>(args: SelectSubset<T, WorkoutExerciseUpsertArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseCountArgs} args - Arguments to filter WorkoutExercises to count.
     * @example
     * // Count the number of WorkoutExercises
     * const count = await prisma.workoutExercise.count({
     *   where: {
     *     // ... the filter for the WorkoutExercises we want to count
     *   }
     * })
    **/
    count<T extends WorkoutExerciseCountArgs>(
      args?: Subset<T, WorkoutExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutExerciseAggregateArgs>(args: Subset<T, WorkoutExerciseAggregateArgs>): Prisma.PrismaPromise<GetWorkoutExerciseAggregateType<T>>

    /**
     * Group by WorkoutExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutExerciseGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutExercise model
   */
  readonly fields: WorkoutExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workout<T extends WorkoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutDefaultArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    alternatives<T extends WorkoutExercise$alternativesArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutExercise$alternativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutExercise model
   */
  interface WorkoutExerciseFieldRefs {
    readonly id: FieldRef<"WorkoutExercise", 'String'>
    readonly workoutId: FieldRef<"WorkoutExercise", 'String'>
    readonly name: FieldRef<"WorkoutExercise", 'String'>
    readonly sets: FieldRef<"WorkoutExercise", 'Int'>
    readonly reps: FieldRef<"WorkoutExercise", 'String'>
    readonly rest: FieldRef<"WorkoutExercise", 'Int'>
    readonly notes: FieldRef<"WorkoutExercise", 'String'>
    readonly videoUrl: FieldRef<"WorkoutExercise", 'String'>
    readonly educationalId: FieldRef<"WorkoutExercise", 'String'>
    readonly order: FieldRef<"WorkoutExercise", 'Int'>
    readonly primaryMuscles: FieldRef<"WorkoutExercise", 'String'>
    readonly secondaryMuscles: FieldRef<"WorkoutExercise", 'String'>
    readonly difficulty: FieldRef<"WorkoutExercise", 'String'>
    readonly equipment: FieldRef<"WorkoutExercise", 'String'>
    readonly instructions: FieldRef<"WorkoutExercise", 'String'>
    readonly tips: FieldRef<"WorkoutExercise", 'String'>
    readonly commonMistakes: FieldRef<"WorkoutExercise", 'String'>
    readonly benefits: FieldRef<"WorkoutExercise", 'String'>
    readonly scientificEvidence: FieldRef<"WorkoutExercise", 'String'>
    readonly createdAt: FieldRef<"WorkoutExercise", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkoutExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutExercise findUnique
   */
  export type WorkoutExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise findUniqueOrThrow
   */
  export type WorkoutExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise findFirst
   */
  export type WorkoutExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutExercises.
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutExercises.
     */
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise findFirstOrThrow
   */
  export type WorkoutExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutExercises.
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutExercises.
     */
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise findMany
   */
  export type WorkoutExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercises to fetch.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutExercises.
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise create
   */
  export type WorkoutExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutExercise.
     */
    data: XOR<WorkoutExerciseCreateInput, WorkoutExerciseUncheckedCreateInput>
  }

  /**
   * WorkoutExercise createMany
   */
  export type WorkoutExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutExercises.
     */
    data: WorkoutExerciseCreateManyInput | WorkoutExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutExercise createManyAndReturn
   */
  export type WorkoutExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutExercises.
     */
    data: WorkoutExerciseCreateManyInput | WorkoutExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutExercise update
   */
  export type WorkoutExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutExercise.
     */
    data: XOR<WorkoutExerciseUpdateInput, WorkoutExerciseUncheckedUpdateInput>
    /**
     * Choose, which WorkoutExercise to update.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise updateMany
   */
  export type WorkoutExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutExercises.
     */
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutExercises to update
     */
    where?: WorkoutExerciseWhereInput
    /**
     * Limit how many WorkoutExercises to update.
     */
    limit?: number
  }

  /**
   * WorkoutExercise updateManyAndReturn
   */
  export type WorkoutExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutExercises.
     */
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutExercises to update
     */
    where?: WorkoutExerciseWhereInput
    /**
     * Limit how many WorkoutExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutExercise upsert
   */
  export type WorkoutExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutExercise to update in case it exists.
     */
    where: WorkoutExerciseWhereUniqueInput
    /**
     * In case the WorkoutExercise found by the `where` argument doesn't exist, create a new WorkoutExercise with this data.
     */
    create: XOR<WorkoutExerciseCreateInput, WorkoutExerciseUncheckedCreateInput>
    /**
     * In case the WorkoutExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutExerciseUpdateInput, WorkoutExerciseUncheckedUpdateInput>
  }

  /**
   * WorkoutExercise delete
   */
  export type WorkoutExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter which WorkoutExercise to delete.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise deleteMany
   */
  export type WorkoutExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutExercises to delete
     */
    where?: WorkoutExerciseWhereInput
    /**
     * Limit how many WorkoutExercises to delete.
     */
    limit?: number
  }

  /**
   * WorkoutExercise.alternatives
   */
  export type WorkoutExercise$alternativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    where?: AlternativeExerciseWhereInput
    orderBy?: AlternativeExerciseOrderByWithRelationInput | AlternativeExerciseOrderByWithRelationInput[]
    cursor?: AlternativeExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlternativeExerciseScalarFieldEnum | AlternativeExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise without action
   */
  export type WorkoutExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutExercise
     */
    omit?: WorkoutExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
  }


  /**
   * Model AlternativeExercise
   */

  export type AggregateAlternativeExercise = {
    _count: AlternativeExerciseCountAggregateOutputType | null
    _avg: AlternativeExerciseAvgAggregateOutputType | null
    _sum: AlternativeExerciseSumAggregateOutputType | null
    _min: AlternativeExerciseMinAggregateOutputType | null
    _max: AlternativeExerciseMaxAggregateOutputType | null
  }

  export type AlternativeExerciseAvgAggregateOutputType = {
    order: number | null
  }

  export type AlternativeExerciseSumAggregateOutputType = {
    order: number | null
  }

  export type AlternativeExerciseMinAggregateOutputType = {
    id: string | null
    workoutExerciseId: string | null
    name: string | null
    reason: string | null
    educationalId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlternativeExerciseMaxAggregateOutputType = {
    id: string | null
    workoutExerciseId: string | null
    name: string | null
    reason: string | null
    educationalId: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlternativeExerciseCountAggregateOutputType = {
    id: number
    workoutExerciseId: number
    name: number
    reason: number
    educationalId: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlternativeExerciseAvgAggregateInputType = {
    order?: true
  }

  export type AlternativeExerciseSumAggregateInputType = {
    order?: true
  }

  export type AlternativeExerciseMinAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    name?: true
    reason?: true
    educationalId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlternativeExerciseMaxAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    name?: true
    reason?: true
    educationalId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlternativeExerciseCountAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    name?: true
    reason?: true
    educationalId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlternativeExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlternativeExercise to aggregate.
     */
    where?: AlternativeExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternativeExercises to fetch.
     */
    orderBy?: AlternativeExerciseOrderByWithRelationInput | AlternativeExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlternativeExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternativeExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternativeExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlternativeExercises
    **/
    _count?: true | AlternativeExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlternativeExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlternativeExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlternativeExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlternativeExerciseMaxAggregateInputType
  }

  export type GetAlternativeExerciseAggregateType<T extends AlternativeExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateAlternativeExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlternativeExercise[P]>
      : GetScalarType<T[P], AggregateAlternativeExercise[P]>
  }




  export type AlternativeExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternativeExerciseWhereInput
    orderBy?: AlternativeExerciseOrderByWithAggregationInput | AlternativeExerciseOrderByWithAggregationInput[]
    by: AlternativeExerciseScalarFieldEnum[] | AlternativeExerciseScalarFieldEnum
    having?: AlternativeExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlternativeExerciseCountAggregateInputType | true
    _avg?: AlternativeExerciseAvgAggregateInputType
    _sum?: AlternativeExerciseSumAggregateInputType
    _min?: AlternativeExerciseMinAggregateInputType
    _max?: AlternativeExerciseMaxAggregateInputType
  }

  export type AlternativeExerciseGroupByOutputType = {
    id: string
    workoutExerciseId: string
    name: string
    reason: string
    educationalId: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: AlternativeExerciseCountAggregateOutputType | null
    _avg: AlternativeExerciseAvgAggregateOutputType | null
    _sum: AlternativeExerciseSumAggregateOutputType | null
    _min: AlternativeExerciseMinAggregateOutputType | null
    _max: AlternativeExerciseMaxAggregateOutputType | null
  }

  type GetAlternativeExerciseGroupByPayload<T extends AlternativeExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlternativeExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlternativeExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlternativeExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], AlternativeExerciseGroupByOutputType[P]>
        }
      >
    >


  export type AlternativeExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutExerciseId?: boolean
    name?: boolean
    reason?: boolean
    educationalId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternativeExercise"]>

  export type AlternativeExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutExerciseId?: boolean
    name?: boolean
    reason?: boolean
    educationalId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternativeExercise"]>

  export type AlternativeExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutExerciseId?: boolean
    name?: boolean
    reason?: boolean
    educationalId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternativeExercise"]>

  export type AlternativeExerciseSelectScalar = {
    id?: boolean
    workoutExerciseId?: boolean
    name?: boolean
    reason?: boolean
    educationalId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlternativeExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workoutExerciseId" | "name" | "reason" | "educationalId" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["alternativeExercise"]>
  export type AlternativeExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }
  export type AlternativeExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }
  export type AlternativeExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }

  export type $AlternativeExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlternativeExercise"
    objects: {
      workoutExercise: Prisma.$WorkoutExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workoutExerciseId: string
      name: string
      reason: string
      educationalId: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alternativeExercise"]>
    composites: {}
  }

  type AlternativeExerciseGetPayload<S extends boolean | null | undefined | AlternativeExerciseDefaultArgs> = $Result.GetResult<Prisma.$AlternativeExercisePayload, S>

  type AlternativeExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlternativeExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlternativeExerciseCountAggregateInputType | true
    }

  export interface AlternativeExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlternativeExercise'], meta: { name: 'AlternativeExercise' } }
    /**
     * Find zero or one AlternativeExercise that matches the filter.
     * @param {AlternativeExerciseFindUniqueArgs} args - Arguments to find a AlternativeExercise
     * @example
     * // Get one AlternativeExercise
     * const alternativeExercise = await prisma.alternativeExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlternativeExerciseFindUniqueArgs>(args: SelectSubset<T, AlternativeExerciseFindUniqueArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlternativeExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlternativeExerciseFindUniqueOrThrowArgs} args - Arguments to find a AlternativeExercise
     * @example
     * // Get one AlternativeExercise
     * const alternativeExercise = await prisma.alternativeExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlternativeExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, AlternativeExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlternativeExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseFindFirstArgs} args - Arguments to find a AlternativeExercise
     * @example
     * // Get one AlternativeExercise
     * const alternativeExercise = await prisma.alternativeExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlternativeExerciseFindFirstArgs>(args?: SelectSubset<T, AlternativeExerciseFindFirstArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlternativeExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseFindFirstOrThrowArgs} args - Arguments to find a AlternativeExercise
     * @example
     * // Get one AlternativeExercise
     * const alternativeExercise = await prisma.alternativeExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlternativeExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, AlternativeExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlternativeExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlternativeExercises
     * const alternativeExercises = await prisma.alternativeExercise.findMany()
     * 
     * // Get first 10 AlternativeExercises
     * const alternativeExercises = await prisma.alternativeExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alternativeExerciseWithIdOnly = await prisma.alternativeExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlternativeExerciseFindManyArgs>(args?: SelectSubset<T, AlternativeExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlternativeExercise.
     * @param {AlternativeExerciseCreateArgs} args - Arguments to create a AlternativeExercise.
     * @example
     * // Create one AlternativeExercise
     * const AlternativeExercise = await prisma.alternativeExercise.create({
     *   data: {
     *     // ... data to create a AlternativeExercise
     *   }
     * })
     * 
     */
    create<T extends AlternativeExerciseCreateArgs>(args: SelectSubset<T, AlternativeExerciseCreateArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlternativeExercises.
     * @param {AlternativeExerciseCreateManyArgs} args - Arguments to create many AlternativeExercises.
     * @example
     * // Create many AlternativeExercises
     * const alternativeExercise = await prisma.alternativeExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlternativeExerciseCreateManyArgs>(args?: SelectSubset<T, AlternativeExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlternativeExercises and returns the data saved in the database.
     * @param {AlternativeExerciseCreateManyAndReturnArgs} args - Arguments to create many AlternativeExercises.
     * @example
     * // Create many AlternativeExercises
     * const alternativeExercise = await prisma.alternativeExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlternativeExercises and only return the `id`
     * const alternativeExerciseWithIdOnly = await prisma.alternativeExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlternativeExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, AlternativeExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlternativeExercise.
     * @param {AlternativeExerciseDeleteArgs} args - Arguments to delete one AlternativeExercise.
     * @example
     * // Delete one AlternativeExercise
     * const AlternativeExercise = await prisma.alternativeExercise.delete({
     *   where: {
     *     // ... filter to delete one AlternativeExercise
     *   }
     * })
     * 
     */
    delete<T extends AlternativeExerciseDeleteArgs>(args: SelectSubset<T, AlternativeExerciseDeleteArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlternativeExercise.
     * @param {AlternativeExerciseUpdateArgs} args - Arguments to update one AlternativeExercise.
     * @example
     * // Update one AlternativeExercise
     * const alternativeExercise = await prisma.alternativeExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlternativeExerciseUpdateArgs>(args: SelectSubset<T, AlternativeExerciseUpdateArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlternativeExercises.
     * @param {AlternativeExerciseDeleteManyArgs} args - Arguments to filter AlternativeExercises to delete.
     * @example
     * // Delete a few AlternativeExercises
     * const { count } = await prisma.alternativeExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlternativeExerciseDeleteManyArgs>(args?: SelectSubset<T, AlternativeExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlternativeExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlternativeExercises
     * const alternativeExercise = await prisma.alternativeExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlternativeExerciseUpdateManyArgs>(args: SelectSubset<T, AlternativeExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlternativeExercises and returns the data updated in the database.
     * @param {AlternativeExerciseUpdateManyAndReturnArgs} args - Arguments to update many AlternativeExercises.
     * @example
     * // Update many AlternativeExercises
     * const alternativeExercise = await prisma.alternativeExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlternativeExercises and only return the `id`
     * const alternativeExerciseWithIdOnly = await prisma.alternativeExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlternativeExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, AlternativeExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlternativeExercise.
     * @param {AlternativeExerciseUpsertArgs} args - Arguments to update or create a AlternativeExercise.
     * @example
     * // Update or create a AlternativeExercise
     * const alternativeExercise = await prisma.alternativeExercise.upsert({
     *   create: {
     *     // ... data to create a AlternativeExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlternativeExercise we want to update
     *   }
     * })
     */
    upsert<T extends AlternativeExerciseUpsertArgs>(args: SelectSubset<T, AlternativeExerciseUpsertArgs<ExtArgs>>): Prisma__AlternativeExerciseClient<$Result.GetResult<Prisma.$AlternativeExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlternativeExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseCountArgs} args - Arguments to filter AlternativeExercises to count.
     * @example
     * // Count the number of AlternativeExercises
     * const count = await prisma.alternativeExercise.count({
     *   where: {
     *     // ... the filter for the AlternativeExercises we want to count
     *   }
     * })
    **/
    count<T extends AlternativeExerciseCountArgs>(
      args?: Subset<T, AlternativeExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlternativeExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlternativeExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlternativeExerciseAggregateArgs>(args: Subset<T, AlternativeExerciseAggregateArgs>): Prisma.PrismaPromise<GetAlternativeExerciseAggregateType<T>>

    /**
     * Group by AlternativeExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlternativeExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlternativeExerciseGroupByArgs['orderBy'] }
        : { orderBy?: AlternativeExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlternativeExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlternativeExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlternativeExercise model
   */
  readonly fields: AlternativeExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlternativeExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlternativeExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workoutExercise<T extends WorkoutExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutExerciseDefaultArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlternativeExercise model
   */
  interface AlternativeExerciseFieldRefs {
    readonly id: FieldRef<"AlternativeExercise", 'String'>
    readonly workoutExerciseId: FieldRef<"AlternativeExercise", 'String'>
    readonly name: FieldRef<"AlternativeExercise", 'String'>
    readonly reason: FieldRef<"AlternativeExercise", 'String'>
    readonly educationalId: FieldRef<"AlternativeExercise", 'String'>
    readonly order: FieldRef<"AlternativeExercise", 'Int'>
    readonly createdAt: FieldRef<"AlternativeExercise", 'DateTime'>
    readonly updatedAt: FieldRef<"AlternativeExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlternativeExercise findUnique
   */
  export type AlternativeExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * Filter, which AlternativeExercise to fetch.
     */
    where: AlternativeExerciseWhereUniqueInput
  }

  /**
   * AlternativeExercise findUniqueOrThrow
   */
  export type AlternativeExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * Filter, which AlternativeExercise to fetch.
     */
    where: AlternativeExerciseWhereUniqueInput
  }

  /**
   * AlternativeExercise findFirst
   */
  export type AlternativeExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * Filter, which AlternativeExercise to fetch.
     */
    where?: AlternativeExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternativeExercises to fetch.
     */
    orderBy?: AlternativeExerciseOrderByWithRelationInput | AlternativeExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlternativeExercises.
     */
    cursor?: AlternativeExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternativeExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternativeExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlternativeExercises.
     */
    distinct?: AlternativeExerciseScalarFieldEnum | AlternativeExerciseScalarFieldEnum[]
  }

  /**
   * AlternativeExercise findFirstOrThrow
   */
  export type AlternativeExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * Filter, which AlternativeExercise to fetch.
     */
    where?: AlternativeExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternativeExercises to fetch.
     */
    orderBy?: AlternativeExerciseOrderByWithRelationInput | AlternativeExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlternativeExercises.
     */
    cursor?: AlternativeExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternativeExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternativeExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlternativeExercises.
     */
    distinct?: AlternativeExerciseScalarFieldEnum | AlternativeExerciseScalarFieldEnum[]
  }

  /**
   * AlternativeExercise findMany
   */
  export type AlternativeExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * Filter, which AlternativeExercises to fetch.
     */
    where?: AlternativeExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternativeExercises to fetch.
     */
    orderBy?: AlternativeExerciseOrderByWithRelationInput | AlternativeExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlternativeExercises.
     */
    cursor?: AlternativeExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternativeExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternativeExercises.
     */
    skip?: number
    distinct?: AlternativeExerciseScalarFieldEnum | AlternativeExerciseScalarFieldEnum[]
  }

  /**
   * AlternativeExercise create
   */
  export type AlternativeExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a AlternativeExercise.
     */
    data: XOR<AlternativeExerciseCreateInput, AlternativeExerciseUncheckedCreateInput>
  }

  /**
   * AlternativeExercise createMany
   */
  export type AlternativeExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlternativeExercises.
     */
    data: AlternativeExerciseCreateManyInput | AlternativeExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlternativeExercise createManyAndReturn
   */
  export type AlternativeExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many AlternativeExercises.
     */
    data: AlternativeExerciseCreateManyInput | AlternativeExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlternativeExercise update
   */
  export type AlternativeExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a AlternativeExercise.
     */
    data: XOR<AlternativeExerciseUpdateInput, AlternativeExerciseUncheckedUpdateInput>
    /**
     * Choose, which AlternativeExercise to update.
     */
    where: AlternativeExerciseWhereUniqueInput
  }

  /**
   * AlternativeExercise updateMany
   */
  export type AlternativeExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlternativeExercises.
     */
    data: XOR<AlternativeExerciseUpdateManyMutationInput, AlternativeExerciseUncheckedUpdateManyInput>
    /**
     * Filter which AlternativeExercises to update
     */
    where?: AlternativeExerciseWhereInput
    /**
     * Limit how many AlternativeExercises to update.
     */
    limit?: number
  }

  /**
   * AlternativeExercise updateManyAndReturn
   */
  export type AlternativeExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * The data used to update AlternativeExercises.
     */
    data: XOR<AlternativeExerciseUpdateManyMutationInput, AlternativeExerciseUncheckedUpdateManyInput>
    /**
     * Filter which AlternativeExercises to update
     */
    where?: AlternativeExerciseWhereInput
    /**
     * Limit how many AlternativeExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlternativeExercise upsert
   */
  export type AlternativeExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the AlternativeExercise to update in case it exists.
     */
    where: AlternativeExerciseWhereUniqueInput
    /**
     * In case the AlternativeExercise found by the `where` argument doesn't exist, create a new AlternativeExercise with this data.
     */
    create: XOR<AlternativeExerciseCreateInput, AlternativeExerciseUncheckedCreateInput>
    /**
     * In case the AlternativeExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlternativeExerciseUpdateInput, AlternativeExerciseUncheckedUpdateInput>
  }

  /**
   * AlternativeExercise delete
   */
  export type AlternativeExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
    /**
     * Filter which AlternativeExercise to delete.
     */
    where: AlternativeExerciseWhereUniqueInput
  }

  /**
   * AlternativeExercise deleteMany
   */
  export type AlternativeExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlternativeExercises to delete
     */
    where?: AlternativeExerciseWhereInput
    /**
     * Limit how many AlternativeExercises to delete.
     */
    limit?: number
  }

  /**
   * AlternativeExercise without action
   */
  export type AlternativeExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeExercise
     */
    select?: AlternativeExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternativeExercise
     */
    omit?: AlternativeExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeExerciseInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutProgress
   */

  export type AggregateWorkoutProgress = {
    _count: WorkoutProgressCountAggregateOutputType | null
    _avg: WorkoutProgressAvgAggregateOutputType | null
    _sum: WorkoutProgressSumAggregateOutputType | null
    _min: WorkoutProgressMinAggregateOutputType | null
    _max: WorkoutProgressMaxAggregateOutputType | null
  }

  export type WorkoutProgressAvgAggregateOutputType = {
    currentExerciseIndex: number | null
    xpEarned: number | null
    totalVolume: number | null
    completionPercentage: number | null
    cardioDuration: number | null
  }

  export type WorkoutProgressSumAggregateOutputType = {
    currentExerciseIndex: number | null
    xpEarned: number | null
    totalVolume: number | null
    completionPercentage: number | null
    cardioDuration: number | null
  }

  export type WorkoutProgressMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    workoutId: string | null
    currentExerciseIndex: number | null
    exerciseLogs: string | null
    skippedExercises: string | null
    selectedAlternatives: string | null
    xpEarned: number | null
    totalVolume: number | null
    completionPercentage: number | null
    startTime: Date | null
    cardioPreference: string | null
    cardioDuration: number | null
    selectedCardioType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutProgressMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    workoutId: string | null
    currentExerciseIndex: number | null
    exerciseLogs: string | null
    skippedExercises: string | null
    selectedAlternatives: string | null
    xpEarned: number | null
    totalVolume: number | null
    completionPercentage: number | null
    startTime: Date | null
    cardioPreference: string | null
    cardioDuration: number | null
    selectedCardioType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutProgressCountAggregateOutputType = {
    id: number
    studentId: number
    workoutId: number
    currentExerciseIndex: number
    exerciseLogs: number
    skippedExercises: number
    selectedAlternatives: number
    xpEarned: number
    totalVolume: number
    completionPercentage: number
    startTime: number
    cardioPreference: number
    cardioDuration: number
    selectedCardioType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkoutProgressAvgAggregateInputType = {
    currentExerciseIndex?: true
    xpEarned?: true
    totalVolume?: true
    completionPercentage?: true
    cardioDuration?: true
  }

  export type WorkoutProgressSumAggregateInputType = {
    currentExerciseIndex?: true
    xpEarned?: true
    totalVolume?: true
    completionPercentage?: true
    cardioDuration?: true
  }

  export type WorkoutProgressMinAggregateInputType = {
    id?: true
    studentId?: true
    workoutId?: true
    currentExerciseIndex?: true
    exerciseLogs?: true
    skippedExercises?: true
    selectedAlternatives?: true
    xpEarned?: true
    totalVolume?: true
    completionPercentage?: true
    startTime?: true
    cardioPreference?: true
    cardioDuration?: true
    selectedCardioType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutProgressMaxAggregateInputType = {
    id?: true
    studentId?: true
    workoutId?: true
    currentExerciseIndex?: true
    exerciseLogs?: true
    skippedExercises?: true
    selectedAlternatives?: true
    xpEarned?: true
    totalVolume?: true
    completionPercentage?: true
    startTime?: true
    cardioPreference?: true
    cardioDuration?: true
    selectedCardioType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutProgressCountAggregateInputType = {
    id?: true
    studentId?: true
    workoutId?: true
    currentExerciseIndex?: true
    exerciseLogs?: true
    skippedExercises?: true
    selectedAlternatives?: true
    xpEarned?: true
    totalVolume?: true
    completionPercentage?: true
    startTime?: true
    cardioPreference?: true
    cardioDuration?: true
    selectedCardioType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkoutProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutProgress to aggregate.
     */
    where?: WorkoutProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutProgresses to fetch.
     */
    orderBy?: WorkoutProgressOrderByWithRelationInput | WorkoutProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutProgresses
    **/
    _count?: true | WorkoutProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutProgressMaxAggregateInputType
  }

  export type GetWorkoutProgressAggregateType<T extends WorkoutProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutProgress[P]>
      : GetScalarType<T[P], AggregateWorkoutProgress[P]>
  }




  export type WorkoutProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutProgressWhereInput
    orderBy?: WorkoutProgressOrderByWithAggregationInput | WorkoutProgressOrderByWithAggregationInput[]
    by: WorkoutProgressScalarFieldEnum[] | WorkoutProgressScalarFieldEnum
    having?: WorkoutProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutProgressCountAggregateInputType | true
    _avg?: WorkoutProgressAvgAggregateInputType
    _sum?: WorkoutProgressSumAggregateInputType
    _min?: WorkoutProgressMinAggregateInputType
    _max?: WorkoutProgressMaxAggregateInputType
  }

  export type WorkoutProgressGroupByOutputType = {
    id: string
    studentId: string
    workoutId: string
    currentExerciseIndex: number
    exerciseLogs: string
    skippedExercises: string | null
    selectedAlternatives: string | null
    xpEarned: number
    totalVolume: number
    completionPercentage: number
    startTime: Date
    cardioPreference: string | null
    cardioDuration: number | null
    selectedCardioType: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkoutProgressCountAggregateOutputType | null
    _avg: WorkoutProgressAvgAggregateOutputType | null
    _sum: WorkoutProgressSumAggregateOutputType | null
    _min: WorkoutProgressMinAggregateOutputType | null
    _max: WorkoutProgressMaxAggregateOutputType | null
  }

  type GetWorkoutProgressGroupByPayload<T extends WorkoutProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutProgressGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutProgressGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    currentExerciseIndex?: boolean
    exerciseLogs?: boolean
    skippedExercises?: boolean
    selectedAlternatives?: boolean
    xpEarned?: boolean
    totalVolume?: boolean
    completionPercentage?: boolean
    startTime?: boolean
    cardioPreference?: boolean
    cardioDuration?: boolean
    selectedCardioType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutProgress"]>

  export type WorkoutProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    currentExerciseIndex?: boolean
    exerciseLogs?: boolean
    skippedExercises?: boolean
    selectedAlternatives?: boolean
    xpEarned?: boolean
    totalVolume?: boolean
    completionPercentage?: boolean
    startTime?: boolean
    cardioPreference?: boolean
    cardioDuration?: boolean
    selectedCardioType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutProgress"]>

  export type WorkoutProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    currentExerciseIndex?: boolean
    exerciseLogs?: boolean
    skippedExercises?: boolean
    selectedAlternatives?: boolean
    xpEarned?: boolean
    totalVolume?: boolean
    completionPercentage?: boolean
    startTime?: boolean
    cardioPreference?: boolean
    cardioDuration?: boolean
    selectedCardioType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutProgress"]>

  export type WorkoutProgressSelectScalar = {
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    currentExerciseIndex?: boolean
    exerciseLogs?: boolean
    skippedExercises?: boolean
    selectedAlternatives?: boolean
    xpEarned?: boolean
    totalVolume?: boolean
    completionPercentage?: boolean
    startTime?: boolean
    cardioPreference?: boolean
    cardioDuration?: boolean
    selectedCardioType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkoutProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "workoutId" | "currentExerciseIndex" | "exerciseLogs" | "skippedExercises" | "selectedAlternatives" | "xpEarned" | "totalVolume" | "completionPercentage" | "startTime" | "cardioPreference" | "cardioDuration" | "selectedCardioType" | "createdAt" | "updatedAt", ExtArgs["result"]["workoutProgress"]>
  export type WorkoutProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }
  export type WorkoutProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }
  export type WorkoutProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }

  export type $WorkoutProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutProgress"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      workout: Prisma.$WorkoutPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      workoutId: string
      currentExerciseIndex: number
      exerciseLogs: string
      skippedExercises: string | null
      selectedAlternatives: string | null
      xpEarned: number
      totalVolume: number
      completionPercentage: number
      startTime: Date
      cardioPreference: string | null
      cardioDuration: number | null
      selectedCardioType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workoutProgress"]>
    composites: {}
  }

  type WorkoutProgressGetPayload<S extends boolean | null | undefined | WorkoutProgressDefaultArgs> = $Result.GetResult<Prisma.$WorkoutProgressPayload, S>

  type WorkoutProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutProgressCountAggregateInputType | true
    }

  export interface WorkoutProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutProgress'], meta: { name: 'WorkoutProgress' } }
    /**
     * Find zero or one WorkoutProgress that matches the filter.
     * @param {WorkoutProgressFindUniqueArgs} args - Arguments to find a WorkoutProgress
     * @example
     * // Get one WorkoutProgress
     * const workoutProgress = await prisma.workoutProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutProgressFindUniqueArgs>(args: SelectSubset<T, WorkoutProgressFindUniqueArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutProgressFindUniqueOrThrowArgs} args - Arguments to find a WorkoutProgress
     * @example
     * // Get one WorkoutProgress
     * const workoutProgress = await prisma.workoutProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressFindFirstArgs} args - Arguments to find a WorkoutProgress
     * @example
     * // Get one WorkoutProgress
     * const workoutProgress = await prisma.workoutProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutProgressFindFirstArgs>(args?: SelectSubset<T, WorkoutProgressFindFirstArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressFindFirstOrThrowArgs} args - Arguments to find a WorkoutProgress
     * @example
     * // Get one WorkoutProgress
     * const workoutProgress = await prisma.workoutProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutProgresses
     * const workoutProgresses = await prisma.workoutProgress.findMany()
     * 
     * // Get first 10 WorkoutProgresses
     * const workoutProgresses = await prisma.workoutProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutProgressWithIdOnly = await prisma.workoutProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutProgressFindManyArgs>(args?: SelectSubset<T, WorkoutProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutProgress.
     * @param {WorkoutProgressCreateArgs} args - Arguments to create a WorkoutProgress.
     * @example
     * // Create one WorkoutProgress
     * const WorkoutProgress = await prisma.workoutProgress.create({
     *   data: {
     *     // ... data to create a WorkoutProgress
     *   }
     * })
     * 
     */
    create<T extends WorkoutProgressCreateArgs>(args: SelectSubset<T, WorkoutProgressCreateArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutProgresses.
     * @param {WorkoutProgressCreateManyArgs} args - Arguments to create many WorkoutProgresses.
     * @example
     * // Create many WorkoutProgresses
     * const workoutProgress = await prisma.workoutProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutProgressCreateManyArgs>(args?: SelectSubset<T, WorkoutProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutProgresses and returns the data saved in the database.
     * @param {WorkoutProgressCreateManyAndReturnArgs} args - Arguments to create many WorkoutProgresses.
     * @example
     * // Create many WorkoutProgresses
     * const workoutProgress = await prisma.workoutProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutProgresses and only return the `id`
     * const workoutProgressWithIdOnly = await prisma.workoutProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutProgress.
     * @param {WorkoutProgressDeleteArgs} args - Arguments to delete one WorkoutProgress.
     * @example
     * // Delete one WorkoutProgress
     * const WorkoutProgress = await prisma.workoutProgress.delete({
     *   where: {
     *     // ... filter to delete one WorkoutProgress
     *   }
     * })
     * 
     */
    delete<T extends WorkoutProgressDeleteArgs>(args: SelectSubset<T, WorkoutProgressDeleteArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutProgress.
     * @param {WorkoutProgressUpdateArgs} args - Arguments to update one WorkoutProgress.
     * @example
     * // Update one WorkoutProgress
     * const workoutProgress = await prisma.workoutProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutProgressUpdateArgs>(args: SelectSubset<T, WorkoutProgressUpdateArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutProgresses.
     * @param {WorkoutProgressDeleteManyArgs} args - Arguments to filter WorkoutProgresses to delete.
     * @example
     * // Delete a few WorkoutProgresses
     * const { count } = await prisma.workoutProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutProgressDeleteManyArgs>(args?: SelectSubset<T, WorkoutProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutProgresses
     * const workoutProgress = await prisma.workoutProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutProgressUpdateManyArgs>(args: SelectSubset<T, WorkoutProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutProgresses and returns the data updated in the database.
     * @param {WorkoutProgressUpdateManyAndReturnArgs} args - Arguments to update many WorkoutProgresses.
     * @example
     * // Update many WorkoutProgresses
     * const workoutProgress = await prisma.workoutProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutProgresses and only return the `id`
     * const workoutProgressWithIdOnly = await prisma.workoutProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutProgress.
     * @param {WorkoutProgressUpsertArgs} args - Arguments to update or create a WorkoutProgress.
     * @example
     * // Update or create a WorkoutProgress
     * const workoutProgress = await prisma.workoutProgress.upsert({
     *   create: {
     *     // ... data to create a WorkoutProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutProgress we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutProgressUpsertArgs>(args: SelectSubset<T, WorkoutProgressUpsertArgs<ExtArgs>>): Prisma__WorkoutProgressClient<$Result.GetResult<Prisma.$WorkoutProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressCountArgs} args - Arguments to filter WorkoutProgresses to count.
     * @example
     * // Count the number of WorkoutProgresses
     * const count = await prisma.workoutProgress.count({
     *   where: {
     *     // ... the filter for the WorkoutProgresses we want to count
     *   }
     * })
    **/
    count<T extends WorkoutProgressCountArgs>(
      args?: Subset<T, WorkoutProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutProgressAggregateArgs>(args: Subset<T, WorkoutProgressAggregateArgs>): Prisma.PrismaPromise<GetWorkoutProgressAggregateType<T>>

    /**
     * Group by WorkoutProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutProgressGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutProgress model
   */
  readonly fields: WorkoutProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workout<T extends WorkoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutDefaultArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutProgress model
   */
  interface WorkoutProgressFieldRefs {
    readonly id: FieldRef<"WorkoutProgress", 'String'>
    readonly studentId: FieldRef<"WorkoutProgress", 'String'>
    readonly workoutId: FieldRef<"WorkoutProgress", 'String'>
    readonly currentExerciseIndex: FieldRef<"WorkoutProgress", 'Int'>
    readonly exerciseLogs: FieldRef<"WorkoutProgress", 'String'>
    readonly skippedExercises: FieldRef<"WorkoutProgress", 'String'>
    readonly selectedAlternatives: FieldRef<"WorkoutProgress", 'String'>
    readonly xpEarned: FieldRef<"WorkoutProgress", 'Int'>
    readonly totalVolume: FieldRef<"WorkoutProgress", 'Float'>
    readonly completionPercentage: FieldRef<"WorkoutProgress", 'Float'>
    readonly startTime: FieldRef<"WorkoutProgress", 'DateTime'>
    readonly cardioPreference: FieldRef<"WorkoutProgress", 'String'>
    readonly cardioDuration: FieldRef<"WorkoutProgress", 'Int'>
    readonly selectedCardioType: FieldRef<"WorkoutProgress", 'String'>
    readonly createdAt: FieldRef<"WorkoutProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkoutProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutProgress findUnique
   */
  export type WorkoutProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutProgress to fetch.
     */
    where: WorkoutProgressWhereUniqueInput
  }

  /**
   * WorkoutProgress findUniqueOrThrow
   */
  export type WorkoutProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutProgress to fetch.
     */
    where: WorkoutProgressWhereUniqueInput
  }

  /**
   * WorkoutProgress findFirst
   */
  export type WorkoutProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutProgress to fetch.
     */
    where?: WorkoutProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutProgresses to fetch.
     */
    orderBy?: WorkoutProgressOrderByWithRelationInput | WorkoutProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutProgresses.
     */
    cursor?: WorkoutProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutProgresses.
     */
    distinct?: WorkoutProgressScalarFieldEnum | WorkoutProgressScalarFieldEnum[]
  }

  /**
   * WorkoutProgress findFirstOrThrow
   */
  export type WorkoutProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutProgress to fetch.
     */
    where?: WorkoutProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutProgresses to fetch.
     */
    orderBy?: WorkoutProgressOrderByWithRelationInput | WorkoutProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutProgresses.
     */
    cursor?: WorkoutProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutProgresses.
     */
    distinct?: WorkoutProgressScalarFieldEnum | WorkoutProgressScalarFieldEnum[]
  }

  /**
   * WorkoutProgress findMany
   */
  export type WorkoutProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutProgresses to fetch.
     */
    where?: WorkoutProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutProgresses to fetch.
     */
    orderBy?: WorkoutProgressOrderByWithRelationInput | WorkoutProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutProgresses.
     */
    cursor?: WorkoutProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutProgresses.
     */
    skip?: number
    distinct?: WorkoutProgressScalarFieldEnum | WorkoutProgressScalarFieldEnum[]
  }

  /**
   * WorkoutProgress create
   */
  export type WorkoutProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutProgress.
     */
    data: XOR<WorkoutProgressCreateInput, WorkoutProgressUncheckedCreateInput>
  }

  /**
   * WorkoutProgress createMany
   */
  export type WorkoutProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutProgresses.
     */
    data: WorkoutProgressCreateManyInput | WorkoutProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutProgress createManyAndReturn
   */
  export type WorkoutProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutProgresses.
     */
    data: WorkoutProgressCreateManyInput | WorkoutProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutProgress update
   */
  export type WorkoutProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutProgress.
     */
    data: XOR<WorkoutProgressUpdateInput, WorkoutProgressUncheckedUpdateInput>
    /**
     * Choose, which WorkoutProgress to update.
     */
    where: WorkoutProgressWhereUniqueInput
  }

  /**
   * WorkoutProgress updateMany
   */
  export type WorkoutProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutProgresses.
     */
    data: XOR<WorkoutProgressUpdateManyMutationInput, WorkoutProgressUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutProgresses to update
     */
    where?: WorkoutProgressWhereInput
    /**
     * Limit how many WorkoutProgresses to update.
     */
    limit?: number
  }

  /**
   * WorkoutProgress updateManyAndReturn
   */
  export type WorkoutProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutProgresses.
     */
    data: XOR<WorkoutProgressUpdateManyMutationInput, WorkoutProgressUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutProgresses to update
     */
    where?: WorkoutProgressWhereInput
    /**
     * Limit how many WorkoutProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutProgress upsert
   */
  export type WorkoutProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutProgress to update in case it exists.
     */
    where: WorkoutProgressWhereUniqueInput
    /**
     * In case the WorkoutProgress found by the `where` argument doesn't exist, create a new WorkoutProgress with this data.
     */
    create: XOR<WorkoutProgressCreateInput, WorkoutProgressUncheckedCreateInput>
    /**
     * In case the WorkoutProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutProgressUpdateInput, WorkoutProgressUncheckedUpdateInput>
  }

  /**
   * WorkoutProgress delete
   */
  export type WorkoutProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
    /**
     * Filter which WorkoutProgress to delete.
     */
    where: WorkoutProgressWhereUniqueInput
  }

  /**
   * WorkoutProgress deleteMany
   */
  export type WorkoutProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutProgresses to delete
     */
    where?: WorkoutProgressWhereInput
    /**
     * Limit how many WorkoutProgresses to delete.
     */
    limit?: number
  }

  /**
   * WorkoutProgress without action
   */
  export type WorkoutProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutProgress
     */
    select?: WorkoutProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutProgress
     */
    omit?: WorkoutProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutProgressInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutHistory
   */

  export type AggregateWorkoutHistory = {
    _count: WorkoutHistoryCountAggregateOutputType | null
    _avg: WorkoutHistoryAvgAggregateOutputType | null
    _sum: WorkoutHistorySumAggregateOutputType | null
    _min: WorkoutHistoryMinAggregateOutputType | null
    _max: WorkoutHistoryMaxAggregateOutputType | null
  }

  export type WorkoutHistoryAvgAggregateOutputType = {
    duration: number | null
    totalVolume: number | null
  }

  export type WorkoutHistorySumAggregateOutputType = {
    duration: number | null
    totalVolume: number | null
  }

  export type WorkoutHistoryMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    workoutId: string | null
    date: Date | null
    duration: number | null
    totalVolume: number | null
    overallFeedback: string | null
    bodyPartsFatigued: string | null
    createdAt: Date | null
  }

  export type WorkoutHistoryMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    workoutId: string | null
    date: Date | null
    duration: number | null
    totalVolume: number | null
    overallFeedback: string | null
    bodyPartsFatigued: string | null
    createdAt: Date | null
  }

  export type WorkoutHistoryCountAggregateOutputType = {
    id: number
    studentId: number
    workoutId: number
    date: number
    duration: number
    totalVolume: number
    overallFeedback: number
    bodyPartsFatigued: number
    createdAt: number
    _all: number
  }


  export type WorkoutHistoryAvgAggregateInputType = {
    duration?: true
    totalVolume?: true
  }

  export type WorkoutHistorySumAggregateInputType = {
    duration?: true
    totalVolume?: true
  }

  export type WorkoutHistoryMinAggregateInputType = {
    id?: true
    studentId?: true
    workoutId?: true
    date?: true
    duration?: true
    totalVolume?: true
    overallFeedback?: true
    bodyPartsFatigued?: true
    createdAt?: true
  }

  export type WorkoutHistoryMaxAggregateInputType = {
    id?: true
    studentId?: true
    workoutId?: true
    date?: true
    duration?: true
    totalVolume?: true
    overallFeedback?: true
    bodyPartsFatigued?: true
    createdAt?: true
  }

  export type WorkoutHistoryCountAggregateInputType = {
    id?: true
    studentId?: true
    workoutId?: true
    date?: true
    duration?: true
    totalVolume?: true
    overallFeedback?: true
    bodyPartsFatigued?: true
    createdAt?: true
    _all?: true
  }

  export type WorkoutHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutHistory to aggregate.
     */
    where?: WorkoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutHistories to fetch.
     */
    orderBy?: WorkoutHistoryOrderByWithRelationInput | WorkoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutHistories
    **/
    _count?: true | WorkoutHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutHistoryMaxAggregateInputType
  }

  export type GetWorkoutHistoryAggregateType<T extends WorkoutHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutHistory[P]>
      : GetScalarType<T[P], AggregateWorkoutHistory[P]>
  }




  export type WorkoutHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutHistoryWhereInput
    orderBy?: WorkoutHistoryOrderByWithAggregationInput | WorkoutHistoryOrderByWithAggregationInput[]
    by: WorkoutHistoryScalarFieldEnum[] | WorkoutHistoryScalarFieldEnum
    having?: WorkoutHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutHistoryCountAggregateInputType | true
    _avg?: WorkoutHistoryAvgAggregateInputType
    _sum?: WorkoutHistorySumAggregateInputType
    _min?: WorkoutHistoryMinAggregateInputType
    _max?: WorkoutHistoryMaxAggregateInputType
  }

  export type WorkoutHistoryGroupByOutputType = {
    id: string
    studentId: string
    workoutId: string | null
    date: Date
    duration: number
    totalVolume: number | null
    overallFeedback: string | null
    bodyPartsFatigued: string | null
    createdAt: Date
    _count: WorkoutHistoryCountAggregateOutputType | null
    _avg: WorkoutHistoryAvgAggregateOutputType | null
    _sum: WorkoutHistorySumAggregateOutputType | null
    _min: WorkoutHistoryMinAggregateOutputType | null
    _max: WorkoutHistoryMaxAggregateOutputType | null
  }

  type GetWorkoutHistoryGroupByPayload<T extends WorkoutHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutHistoryGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    date?: boolean
    duration?: boolean
    totalVolume?: boolean
    overallFeedback?: boolean
    bodyPartsFatigued?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutHistory$workoutArgs<ExtArgs>
    exercises?: boolean | WorkoutHistory$exercisesArgs<ExtArgs>
    records?: boolean | WorkoutHistory$recordsArgs<ExtArgs>
    _count?: boolean | WorkoutHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutHistory"]>

  export type WorkoutHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    date?: boolean
    duration?: boolean
    totalVolume?: boolean
    overallFeedback?: boolean
    bodyPartsFatigued?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutHistory$workoutArgs<ExtArgs>
  }, ExtArgs["result"]["workoutHistory"]>

  export type WorkoutHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    date?: boolean
    duration?: boolean
    totalVolume?: boolean
    overallFeedback?: boolean
    bodyPartsFatigued?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutHistory$workoutArgs<ExtArgs>
  }, ExtArgs["result"]["workoutHistory"]>

  export type WorkoutHistorySelectScalar = {
    id?: boolean
    studentId?: boolean
    workoutId?: boolean
    date?: boolean
    duration?: boolean
    totalVolume?: boolean
    overallFeedback?: boolean
    bodyPartsFatigued?: boolean
    createdAt?: boolean
  }

  export type WorkoutHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "workoutId" | "date" | "duration" | "totalVolume" | "overallFeedback" | "bodyPartsFatigued" | "createdAt", ExtArgs["result"]["workoutHistory"]>
  export type WorkoutHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutHistory$workoutArgs<ExtArgs>
    exercises?: boolean | WorkoutHistory$exercisesArgs<ExtArgs>
    records?: boolean | WorkoutHistory$recordsArgs<ExtArgs>
    _count?: boolean | WorkoutHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutHistory$workoutArgs<ExtArgs>
  }
  export type WorkoutHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workout?: boolean | WorkoutHistory$workoutArgs<ExtArgs>
  }

  export type $WorkoutHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutHistory"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      workout: Prisma.$WorkoutPayload<ExtArgs> | null
      exercises: Prisma.$ExerciseLogPayload<ExtArgs>[]
      records: Prisma.$PersonalRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      workoutId: string | null
      date: Date
      duration: number
      totalVolume: number | null
      overallFeedback: string | null
      bodyPartsFatigued: string | null
      createdAt: Date
    }, ExtArgs["result"]["workoutHistory"]>
    composites: {}
  }

  type WorkoutHistoryGetPayload<S extends boolean | null | undefined | WorkoutHistoryDefaultArgs> = $Result.GetResult<Prisma.$WorkoutHistoryPayload, S>

  type WorkoutHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutHistoryCountAggregateInputType | true
    }

  export interface WorkoutHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutHistory'], meta: { name: 'WorkoutHistory' } }
    /**
     * Find zero or one WorkoutHistory that matches the filter.
     * @param {WorkoutHistoryFindUniqueArgs} args - Arguments to find a WorkoutHistory
     * @example
     * // Get one WorkoutHistory
     * const workoutHistory = await prisma.workoutHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutHistoryFindUniqueArgs>(args: SelectSubset<T, WorkoutHistoryFindUniqueArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutHistoryFindUniqueOrThrowArgs} args - Arguments to find a WorkoutHistory
     * @example
     * // Get one WorkoutHistory
     * const workoutHistory = await prisma.workoutHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryFindFirstArgs} args - Arguments to find a WorkoutHistory
     * @example
     * // Get one WorkoutHistory
     * const workoutHistory = await prisma.workoutHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutHistoryFindFirstArgs>(args?: SelectSubset<T, WorkoutHistoryFindFirstArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryFindFirstOrThrowArgs} args - Arguments to find a WorkoutHistory
     * @example
     * // Get one WorkoutHistory
     * const workoutHistory = await prisma.workoutHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutHistories
     * const workoutHistories = await prisma.workoutHistory.findMany()
     * 
     * // Get first 10 WorkoutHistories
     * const workoutHistories = await prisma.workoutHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutHistoryWithIdOnly = await prisma.workoutHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutHistoryFindManyArgs>(args?: SelectSubset<T, WorkoutHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutHistory.
     * @param {WorkoutHistoryCreateArgs} args - Arguments to create a WorkoutHistory.
     * @example
     * // Create one WorkoutHistory
     * const WorkoutHistory = await prisma.workoutHistory.create({
     *   data: {
     *     // ... data to create a WorkoutHistory
     *   }
     * })
     * 
     */
    create<T extends WorkoutHistoryCreateArgs>(args: SelectSubset<T, WorkoutHistoryCreateArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutHistories.
     * @param {WorkoutHistoryCreateManyArgs} args - Arguments to create many WorkoutHistories.
     * @example
     * // Create many WorkoutHistories
     * const workoutHistory = await prisma.workoutHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutHistoryCreateManyArgs>(args?: SelectSubset<T, WorkoutHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutHistories and returns the data saved in the database.
     * @param {WorkoutHistoryCreateManyAndReturnArgs} args - Arguments to create many WorkoutHistories.
     * @example
     * // Create many WorkoutHistories
     * const workoutHistory = await prisma.workoutHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutHistories and only return the `id`
     * const workoutHistoryWithIdOnly = await prisma.workoutHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutHistory.
     * @param {WorkoutHistoryDeleteArgs} args - Arguments to delete one WorkoutHistory.
     * @example
     * // Delete one WorkoutHistory
     * const WorkoutHistory = await prisma.workoutHistory.delete({
     *   where: {
     *     // ... filter to delete one WorkoutHistory
     *   }
     * })
     * 
     */
    delete<T extends WorkoutHistoryDeleteArgs>(args: SelectSubset<T, WorkoutHistoryDeleteArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutHistory.
     * @param {WorkoutHistoryUpdateArgs} args - Arguments to update one WorkoutHistory.
     * @example
     * // Update one WorkoutHistory
     * const workoutHistory = await prisma.workoutHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutHistoryUpdateArgs>(args: SelectSubset<T, WorkoutHistoryUpdateArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutHistories.
     * @param {WorkoutHistoryDeleteManyArgs} args - Arguments to filter WorkoutHistories to delete.
     * @example
     * // Delete a few WorkoutHistories
     * const { count } = await prisma.workoutHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutHistoryDeleteManyArgs>(args?: SelectSubset<T, WorkoutHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutHistories
     * const workoutHistory = await prisma.workoutHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutHistoryUpdateManyArgs>(args: SelectSubset<T, WorkoutHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutHistories and returns the data updated in the database.
     * @param {WorkoutHistoryUpdateManyAndReturnArgs} args - Arguments to update many WorkoutHistories.
     * @example
     * // Update many WorkoutHistories
     * const workoutHistory = await prisma.workoutHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutHistories and only return the `id`
     * const workoutHistoryWithIdOnly = await prisma.workoutHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutHistory.
     * @param {WorkoutHistoryUpsertArgs} args - Arguments to update or create a WorkoutHistory.
     * @example
     * // Update or create a WorkoutHistory
     * const workoutHistory = await prisma.workoutHistory.upsert({
     *   create: {
     *     // ... data to create a WorkoutHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutHistory we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutHistoryUpsertArgs>(args: SelectSubset<T, WorkoutHistoryUpsertArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryCountArgs} args - Arguments to filter WorkoutHistories to count.
     * @example
     * // Count the number of WorkoutHistories
     * const count = await prisma.workoutHistory.count({
     *   where: {
     *     // ... the filter for the WorkoutHistories we want to count
     *   }
     * })
    **/
    count<T extends WorkoutHistoryCountArgs>(
      args?: Subset<T, WorkoutHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutHistoryAggregateArgs>(args: Subset<T, WorkoutHistoryAggregateArgs>): Prisma.PrismaPromise<GetWorkoutHistoryAggregateType<T>>

    /**
     * Group by WorkoutHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutHistoryGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutHistory model
   */
  readonly fields: WorkoutHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workout<T extends WorkoutHistory$workoutArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutHistory$workoutArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    exercises<T extends WorkoutHistory$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutHistory$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    records<T extends WorkoutHistory$recordsArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutHistory$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutHistory model
   */
  interface WorkoutHistoryFieldRefs {
    readonly id: FieldRef<"WorkoutHistory", 'String'>
    readonly studentId: FieldRef<"WorkoutHistory", 'String'>
    readonly workoutId: FieldRef<"WorkoutHistory", 'String'>
    readonly date: FieldRef<"WorkoutHistory", 'DateTime'>
    readonly duration: FieldRef<"WorkoutHistory", 'Int'>
    readonly totalVolume: FieldRef<"WorkoutHistory", 'Float'>
    readonly overallFeedback: FieldRef<"WorkoutHistory", 'String'>
    readonly bodyPartsFatigued: FieldRef<"WorkoutHistory", 'String'>
    readonly createdAt: FieldRef<"WorkoutHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutHistory findUnique
   */
  export type WorkoutHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutHistory to fetch.
     */
    where: WorkoutHistoryWhereUniqueInput
  }

  /**
   * WorkoutHistory findUniqueOrThrow
   */
  export type WorkoutHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutHistory to fetch.
     */
    where: WorkoutHistoryWhereUniqueInput
  }

  /**
   * WorkoutHistory findFirst
   */
  export type WorkoutHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutHistory to fetch.
     */
    where?: WorkoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutHistories to fetch.
     */
    orderBy?: WorkoutHistoryOrderByWithRelationInput | WorkoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutHistories.
     */
    cursor?: WorkoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutHistories.
     */
    distinct?: WorkoutHistoryScalarFieldEnum | WorkoutHistoryScalarFieldEnum[]
  }

  /**
   * WorkoutHistory findFirstOrThrow
   */
  export type WorkoutHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutHistory to fetch.
     */
    where?: WorkoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutHistories to fetch.
     */
    orderBy?: WorkoutHistoryOrderByWithRelationInput | WorkoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutHistories.
     */
    cursor?: WorkoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutHistories.
     */
    distinct?: WorkoutHistoryScalarFieldEnum | WorkoutHistoryScalarFieldEnum[]
  }

  /**
   * WorkoutHistory findMany
   */
  export type WorkoutHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutHistories to fetch.
     */
    where?: WorkoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutHistories to fetch.
     */
    orderBy?: WorkoutHistoryOrderByWithRelationInput | WorkoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutHistories.
     */
    cursor?: WorkoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutHistories.
     */
    skip?: number
    distinct?: WorkoutHistoryScalarFieldEnum | WorkoutHistoryScalarFieldEnum[]
  }

  /**
   * WorkoutHistory create
   */
  export type WorkoutHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutHistory.
     */
    data: XOR<WorkoutHistoryCreateInput, WorkoutHistoryUncheckedCreateInput>
  }

  /**
   * WorkoutHistory createMany
   */
  export type WorkoutHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutHistories.
     */
    data: WorkoutHistoryCreateManyInput | WorkoutHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutHistory createManyAndReturn
   */
  export type WorkoutHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutHistories.
     */
    data: WorkoutHistoryCreateManyInput | WorkoutHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutHistory update
   */
  export type WorkoutHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutHistory.
     */
    data: XOR<WorkoutHistoryUpdateInput, WorkoutHistoryUncheckedUpdateInput>
    /**
     * Choose, which WorkoutHistory to update.
     */
    where: WorkoutHistoryWhereUniqueInput
  }

  /**
   * WorkoutHistory updateMany
   */
  export type WorkoutHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutHistories.
     */
    data: XOR<WorkoutHistoryUpdateManyMutationInput, WorkoutHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutHistories to update
     */
    where?: WorkoutHistoryWhereInput
    /**
     * Limit how many WorkoutHistories to update.
     */
    limit?: number
  }

  /**
   * WorkoutHistory updateManyAndReturn
   */
  export type WorkoutHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutHistories.
     */
    data: XOR<WorkoutHistoryUpdateManyMutationInput, WorkoutHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutHistories to update
     */
    where?: WorkoutHistoryWhereInput
    /**
     * Limit how many WorkoutHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutHistory upsert
   */
  export type WorkoutHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutHistory to update in case it exists.
     */
    where: WorkoutHistoryWhereUniqueInput
    /**
     * In case the WorkoutHistory found by the `where` argument doesn't exist, create a new WorkoutHistory with this data.
     */
    create: XOR<WorkoutHistoryCreateInput, WorkoutHistoryUncheckedCreateInput>
    /**
     * In case the WorkoutHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutHistoryUpdateInput, WorkoutHistoryUncheckedUpdateInput>
  }

  /**
   * WorkoutHistory delete
   */
  export type WorkoutHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    /**
     * Filter which WorkoutHistory to delete.
     */
    where: WorkoutHistoryWhereUniqueInput
  }

  /**
   * WorkoutHistory deleteMany
   */
  export type WorkoutHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutHistories to delete
     */
    where?: WorkoutHistoryWhereInput
    /**
     * Limit how many WorkoutHistories to delete.
     */
    limit?: number
  }

  /**
   * WorkoutHistory.workout
   */
  export type WorkoutHistory$workoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workout
     */
    omit?: WorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    where?: WorkoutWhereInput
  }

  /**
   * WorkoutHistory.exercises
   */
  export type WorkoutHistory$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    where?: ExerciseLogWhereInput
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    cursor?: ExerciseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * WorkoutHistory.records
   */
  export type WorkoutHistory$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    where?: PersonalRecordWhereInput
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    cursor?: PersonalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * WorkoutHistory without action
   */
  export type WorkoutHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseLog
   */

  export type AggregateExerciseLog = {
    _count: ExerciseLogCountAggregateOutputType | null
    _avg: ExerciseLogAvgAggregateOutputType | null
    _sum: ExerciseLogSumAggregateOutputType | null
    _min: ExerciseLogMinAggregateOutputType | null
    _max: ExerciseLogMaxAggregateOutputType | null
  }

  export type ExerciseLogAvgAggregateOutputType = {
    formCheckScore: number | null
  }

  export type ExerciseLogSumAggregateOutputType = {
    formCheckScore: number | null
  }

  export type ExerciseLogMinAggregateOutputType = {
    id: string | null
    workoutHistoryId: string | null
    exerciseId: string | null
    exerciseName: string | null
    sets: string | null
    notes: string | null
    formCheckScore: number | null
    difficulty: string | null
  }

  export type ExerciseLogMaxAggregateOutputType = {
    id: string | null
    workoutHistoryId: string | null
    exerciseId: string | null
    exerciseName: string | null
    sets: string | null
    notes: string | null
    formCheckScore: number | null
    difficulty: string | null
  }

  export type ExerciseLogCountAggregateOutputType = {
    id: number
    workoutHistoryId: number
    exerciseId: number
    exerciseName: number
    sets: number
    notes: number
    formCheckScore: number
    difficulty: number
    _all: number
  }


  export type ExerciseLogAvgAggregateInputType = {
    formCheckScore?: true
  }

  export type ExerciseLogSumAggregateInputType = {
    formCheckScore?: true
  }

  export type ExerciseLogMinAggregateInputType = {
    id?: true
    workoutHistoryId?: true
    exerciseId?: true
    exerciseName?: true
    sets?: true
    notes?: true
    formCheckScore?: true
    difficulty?: true
  }

  export type ExerciseLogMaxAggregateInputType = {
    id?: true
    workoutHistoryId?: true
    exerciseId?: true
    exerciseName?: true
    sets?: true
    notes?: true
    formCheckScore?: true
    difficulty?: true
  }

  export type ExerciseLogCountAggregateInputType = {
    id?: true
    workoutHistoryId?: true
    exerciseId?: true
    exerciseName?: true
    sets?: true
    notes?: true
    formCheckScore?: true
    difficulty?: true
    _all?: true
  }

  export type ExerciseLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseLog to aggregate.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseLogs
    **/
    _count?: true | ExerciseLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseLogMaxAggregateInputType
  }

  export type GetExerciseLogAggregateType<T extends ExerciseLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseLog[P]>
      : GetScalarType<T[P], AggregateExerciseLog[P]>
  }




  export type ExerciseLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseLogWhereInput
    orderBy?: ExerciseLogOrderByWithAggregationInput | ExerciseLogOrderByWithAggregationInput[]
    by: ExerciseLogScalarFieldEnum[] | ExerciseLogScalarFieldEnum
    having?: ExerciseLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseLogCountAggregateInputType | true
    _avg?: ExerciseLogAvgAggregateInputType
    _sum?: ExerciseLogSumAggregateInputType
    _min?: ExerciseLogMinAggregateInputType
    _max?: ExerciseLogMaxAggregateInputType
  }

  export type ExerciseLogGroupByOutputType = {
    id: string
    workoutHistoryId: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes: string | null
    formCheckScore: number | null
    difficulty: string | null
    _count: ExerciseLogCountAggregateOutputType | null
    _avg: ExerciseLogAvgAggregateOutputType | null
    _sum: ExerciseLogSumAggregateOutputType | null
    _min: ExerciseLogMinAggregateOutputType | null
    _max: ExerciseLogMaxAggregateOutputType | null
  }

  type GetExerciseLogGroupByPayload<T extends ExerciseLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseLogGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    sets?: boolean
    notes?: boolean
    formCheckScore?: boolean
    difficulty?: boolean
    workoutHistory?: boolean | WorkoutHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseLog"]>

  export type ExerciseLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    sets?: boolean
    notes?: boolean
    formCheckScore?: boolean
    difficulty?: boolean
    workoutHistory?: boolean | WorkoutHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseLog"]>

  export type ExerciseLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    sets?: boolean
    notes?: boolean
    formCheckScore?: boolean
    difficulty?: boolean
    workoutHistory?: boolean | WorkoutHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseLog"]>

  export type ExerciseLogSelectScalar = {
    id?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    sets?: boolean
    notes?: boolean
    formCheckScore?: boolean
    difficulty?: boolean
  }

  export type ExerciseLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workoutHistoryId" | "exerciseId" | "exerciseName" | "sets" | "notes" | "formCheckScore" | "difficulty", ExtArgs["result"]["exerciseLog"]>
  export type ExerciseLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutHistory?: boolean | WorkoutHistoryDefaultArgs<ExtArgs>
  }
  export type ExerciseLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutHistory?: boolean | WorkoutHistoryDefaultArgs<ExtArgs>
  }
  export type ExerciseLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutHistory?: boolean | WorkoutHistoryDefaultArgs<ExtArgs>
  }

  export type $ExerciseLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseLog"
    objects: {
      workoutHistory: Prisma.$WorkoutHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workoutHistoryId: string
      exerciseId: string
      exerciseName: string
      sets: string
      notes: string | null
      formCheckScore: number | null
      difficulty: string | null
    }, ExtArgs["result"]["exerciseLog"]>
    composites: {}
  }

  type ExerciseLogGetPayload<S extends boolean | null | undefined | ExerciseLogDefaultArgs> = $Result.GetResult<Prisma.$ExerciseLogPayload, S>

  type ExerciseLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseLogCountAggregateInputType | true
    }

  export interface ExerciseLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseLog'], meta: { name: 'ExerciseLog' } }
    /**
     * Find zero or one ExerciseLog that matches the filter.
     * @param {ExerciseLogFindUniqueArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseLogFindUniqueArgs>(args: SelectSubset<T, ExerciseLogFindUniqueArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseLogFindUniqueOrThrowArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindFirstArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseLogFindFirstArgs>(args?: SelectSubset<T, ExerciseLogFindFirstArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindFirstOrThrowArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExerciseLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseLogs
     * const exerciseLogs = await prisma.exerciseLog.findMany()
     * 
     * // Get first 10 ExerciseLogs
     * const exerciseLogs = await prisma.exerciseLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseLogWithIdOnly = await prisma.exerciseLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseLogFindManyArgs>(args?: SelectSubset<T, ExerciseLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseLog.
     * @param {ExerciseLogCreateArgs} args - Arguments to create a ExerciseLog.
     * @example
     * // Create one ExerciseLog
     * const ExerciseLog = await prisma.exerciseLog.create({
     *   data: {
     *     // ... data to create a ExerciseLog
     *   }
     * })
     * 
     */
    create<T extends ExerciseLogCreateArgs>(args: SelectSubset<T, ExerciseLogCreateArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExerciseLogs.
     * @param {ExerciseLogCreateManyArgs} args - Arguments to create many ExerciseLogs.
     * @example
     * // Create many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseLogCreateManyArgs>(args?: SelectSubset<T, ExerciseLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseLogs and returns the data saved in the database.
     * @param {ExerciseLogCreateManyAndReturnArgs} args - Arguments to create many ExerciseLogs.
     * @example
     * // Create many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseLogs and only return the `id`
     * const exerciseLogWithIdOnly = await prisma.exerciseLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseLog.
     * @param {ExerciseLogDeleteArgs} args - Arguments to delete one ExerciseLog.
     * @example
     * // Delete one ExerciseLog
     * const ExerciseLog = await prisma.exerciseLog.delete({
     *   where: {
     *     // ... filter to delete one ExerciseLog
     *   }
     * })
     * 
     */
    delete<T extends ExerciseLogDeleteArgs>(args: SelectSubset<T, ExerciseLogDeleteArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseLog.
     * @param {ExerciseLogUpdateArgs} args - Arguments to update one ExerciseLog.
     * @example
     * // Update one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseLogUpdateArgs>(args: SelectSubset<T, ExerciseLogUpdateArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExerciseLogs.
     * @param {ExerciseLogDeleteManyArgs} args - Arguments to filter ExerciseLogs to delete.
     * @example
     * // Delete a few ExerciseLogs
     * const { count } = await prisma.exerciseLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseLogDeleteManyArgs>(args?: SelectSubset<T, ExerciseLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseLogUpdateManyArgs>(args: SelectSubset<T, ExerciseLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseLogs and returns the data updated in the database.
     * @param {ExerciseLogUpdateManyAndReturnArgs} args - Arguments to update many ExerciseLogs.
     * @example
     * // Update many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciseLogs and only return the `id`
     * const exerciseLogWithIdOnly = await prisma.exerciseLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseLog.
     * @param {ExerciseLogUpsertArgs} args - Arguments to update or create a ExerciseLog.
     * @example
     * // Update or create a ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.upsert({
     *   create: {
     *     // ... data to create a ExerciseLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseLog we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseLogUpsertArgs>(args: SelectSubset<T, ExerciseLogUpsertArgs<ExtArgs>>): Prisma__ExerciseLogClient<$Result.GetResult<Prisma.$ExerciseLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExerciseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogCountArgs} args - Arguments to filter ExerciseLogs to count.
     * @example
     * // Count the number of ExerciseLogs
     * const count = await prisma.exerciseLog.count({
     *   where: {
     *     // ... the filter for the ExerciseLogs we want to count
     *   }
     * })
    **/
    count<T extends ExerciseLogCountArgs>(
      args?: Subset<T, ExerciseLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseLogAggregateArgs>(args: Subset<T, ExerciseLogAggregateArgs>): Prisma.PrismaPromise<GetExerciseLogAggregateType<T>>

    /**
     * Group by ExerciseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseLogGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseLog model
   */
  readonly fields: ExerciseLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workoutHistory<T extends WorkoutHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutHistoryDefaultArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseLog model
   */
  interface ExerciseLogFieldRefs {
    readonly id: FieldRef<"ExerciseLog", 'String'>
    readonly workoutHistoryId: FieldRef<"ExerciseLog", 'String'>
    readonly exerciseId: FieldRef<"ExerciseLog", 'String'>
    readonly exerciseName: FieldRef<"ExerciseLog", 'String'>
    readonly sets: FieldRef<"ExerciseLog", 'String'>
    readonly notes: FieldRef<"ExerciseLog", 'String'>
    readonly formCheckScore: FieldRef<"ExerciseLog", 'Int'>
    readonly difficulty: FieldRef<"ExerciseLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseLog findUnique
   */
  export type ExerciseLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog findUniqueOrThrow
   */
  export type ExerciseLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog findFirst
   */
  export type ExerciseLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseLogs.
     */
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * ExerciseLog findFirstOrThrow
   */
  export type ExerciseLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseLogs.
     */
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * ExerciseLog findMany
   */
  export type ExerciseLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseLogs to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: ExerciseLogOrderByWithRelationInput | ExerciseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    distinct?: ExerciseLogScalarFieldEnum | ExerciseLogScalarFieldEnum[]
  }

  /**
   * ExerciseLog create
   */
  export type ExerciseLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseLog.
     */
    data: XOR<ExerciseLogCreateInput, ExerciseLogUncheckedCreateInput>
  }

  /**
   * ExerciseLog createMany
   */
  export type ExerciseLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseLogs.
     */
    data: ExerciseLogCreateManyInput | ExerciseLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseLog createManyAndReturn
   */
  export type ExerciseLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciseLogs.
     */
    data: ExerciseLogCreateManyInput | ExerciseLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseLog update
   */
  export type ExerciseLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseLog.
     */
    data: XOR<ExerciseLogUpdateInput, ExerciseLogUncheckedUpdateInput>
    /**
     * Choose, which ExerciseLog to update.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog updateMany
   */
  export type ExerciseLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseLogs.
     */
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseLogs to update
     */
    where?: ExerciseLogWhereInput
    /**
     * Limit how many ExerciseLogs to update.
     */
    limit?: number
  }

  /**
   * ExerciseLog updateManyAndReturn
   */
  export type ExerciseLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * The data used to update ExerciseLogs.
     */
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseLogs to update
     */
    where?: ExerciseLogWhereInput
    /**
     * Limit how many ExerciseLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseLog upsert
   */
  export type ExerciseLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseLog to update in case it exists.
     */
    where: ExerciseLogWhereUniqueInput
    /**
     * In case the ExerciseLog found by the `where` argument doesn't exist, create a new ExerciseLog with this data.
     */
    create: XOR<ExerciseLogCreateInput, ExerciseLogUncheckedCreateInput>
    /**
     * In case the ExerciseLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseLogUpdateInput, ExerciseLogUncheckedUpdateInput>
  }

  /**
   * ExerciseLog delete
   */
  export type ExerciseLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
    /**
     * Filter which ExerciseLog to delete.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog deleteMany
   */
  export type ExerciseLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseLogs to delete
     */
    where?: ExerciseLogWhereInput
    /**
     * Limit how many ExerciseLogs to delete.
     */
    limit?: number
  }

  /**
   * ExerciseLog without action
   */
  export type ExerciseLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseLog
     */
    omit?: ExerciseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseLogInclude<ExtArgs> | null
  }


  /**
   * Model PersonalRecord
   */

  export type AggregatePersonalRecord = {
    _count: PersonalRecordCountAggregateOutputType | null
    _avg: PersonalRecordAvgAggregateOutputType | null
    _sum: PersonalRecordSumAggregateOutputType | null
    _min: PersonalRecordMinAggregateOutputType | null
    _max: PersonalRecordMaxAggregateOutputType | null
  }

  export type PersonalRecordAvgAggregateOutputType = {
    value: number | null
    previousBest: number | null
  }

  export type PersonalRecordSumAggregateOutputType = {
    value: number | null
    previousBest: number | null
  }

  export type PersonalRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    workoutHistoryId: string | null
    exerciseId: string | null
    exerciseName: string | null
    type: string | null
    value: number | null
    date: Date | null
    previousBest: number | null
  }

  export type PersonalRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    workoutHistoryId: string | null
    exerciseId: string | null
    exerciseName: string | null
    type: string | null
    value: number | null
    date: Date | null
    previousBest: number | null
  }

  export type PersonalRecordCountAggregateOutputType = {
    id: number
    studentId: number
    workoutHistoryId: number
    exerciseId: number
    exerciseName: number
    type: number
    value: number
    date: number
    previousBest: number
    _all: number
  }


  export type PersonalRecordAvgAggregateInputType = {
    value?: true
    previousBest?: true
  }

  export type PersonalRecordSumAggregateInputType = {
    value?: true
    previousBest?: true
  }

  export type PersonalRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    workoutHistoryId?: true
    exerciseId?: true
    exerciseName?: true
    type?: true
    value?: true
    date?: true
    previousBest?: true
  }

  export type PersonalRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    workoutHistoryId?: true
    exerciseId?: true
    exerciseName?: true
    type?: true
    value?: true
    date?: true
    previousBest?: true
  }

  export type PersonalRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    workoutHistoryId?: true
    exerciseId?: true
    exerciseName?: true
    type?: true
    value?: true
    date?: true
    previousBest?: true
    _all?: true
  }

  export type PersonalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalRecord to aggregate.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalRecords
    **/
    _count?: true | PersonalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalRecordMaxAggregateInputType
  }

  export type GetPersonalRecordAggregateType<T extends PersonalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalRecord[P]>
      : GetScalarType<T[P], AggregatePersonalRecord[P]>
  }




  export type PersonalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalRecordWhereInput
    orderBy?: PersonalRecordOrderByWithAggregationInput | PersonalRecordOrderByWithAggregationInput[]
    by: PersonalRecordScalarFieldEnum[] | PersonalRecordScalarFieldEnum
    having?: PersonalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalRecordCountAggregateInputType | true
    _avg?: PersonalRecordAvgAggregateInputType
    _sum?: PersonalRecordSumAggregateInputType
    _min?: PersonalRecordMinAggregateInputType
    _max?: PersonalRecordMaxAggregateInputType
  }

  export type PersonalRecordGroupByOutputType = {
    id: string
    studentId: string
    workoutHistoryId: string | null
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date: Date
    previousBest: number | null
    _count: PersonalRecordCountAggregateOutputType | null
    _avg: PersonalRecordAvgAggregateOutputType | null
    _sum: PersonalRecordSumAggregateOutputType | null
    _min: PersonalRecordMinAggregateOutputType | null
    _max: PersonalRecordMaxAggregateOutputType | null
  }

  type GetPersonalRecordGroupByPayload<T extends PersonalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalRecordGroupByOutputType[P]>
        }
      >
    >


  export type PersonalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    type?: boolean
    value?: boolean
    date?: boolean
    previousBest?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workoutHistory?: boolean | PersonalRecord$workoutHistoryArgs<ExtArgs>
  }, ExtArgs["result"]["personalRecord"]>

  export type PersonalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    type?: boolean
    value?: boolean
    date?: boolean
    previousBest?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workoutHistory?: boolean | PersonalRecord$workoutHistoryArgs<ExtArgs>
  }, ExtArgs["result"]["personalRecord"]>

  export type PersonalRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    type?: boolean
    value?: boolean
    date?: boolean
    previousBest?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workoutHistory?: boolean | PersonalRecord$workoutHistoryArgs<ExtArgs>
  }, ExtArgs["result"]["personalRecord"]>

  export type PersonalRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    workoutHistoryId?: boolean
    exerciseId?: boolean
    exerciseName?: boolean
    type?: boolean
    value?: boolean
    date?: boolean
    previousBest?: boolean
  }

  export type PersonalRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "workoutHistoryId" | "exerciseId" | "exerciseName" | "type" | "value" | "date" | "previousBest", ExtArgs["result"]["personalRecord"]>
  export type PersonalRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workoutHistory?: boolean | PersonalRecord$workoutHistoryArgs<ExtArgs>
  }
  export type PersonalRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workoutHistory?: boolean | PersonalRecord$workoutHistoryArgs<ExtArgs>
  }
  export type PersonalRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    workoutHistory?: boolean | PersonalRecord$workoutHistoryArgs<ExtArgs>
  }

  export type $PersonalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      workoutHistory: Prisma.$WorkoutHistoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      workoutHistoryId: string | null
      exerciseId: string
      exerciseName: string
      type: string
      value: number
      date: Date
      previousBest: number | null
    }, ExtArgs["result"]["personalRecord"]>
    composites: {}
  }

  type PersonalRecordGetPayload<S extends boolean | null | undefined | PersonalRecordDefaultArgs> = $Result.GetResult<Prisma.$PersonalRecordPayload, S>

  type PersonalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalRecordCountAggregateInputType | true
    }

  export interface PersonalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalRecord'], meta: { name: 'PersonalRecord' } }
    /**
     * Find zero or one PersonalRecord that matches the filter.
     * @param {PersonalRecordFindUniqueArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalRecordFindUniqueArgs>(args: SelectSubset<T, PersonalRecordFindUniqueArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalRecordFindUniqueOrThrowArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordFindFirstArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalRecordFindFirstArgs>(args?: SelectSubset<T, PersonalRecordFindFirstArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordFindFirstOrThrowArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalRecords
     * const personalRecords = await prisma.personalRecord.findMany()
     * 
     * // Get first 10 PersonalRecords
     * const personalRecords = await prisma.personalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalRecordWithIdOnly = await prisma.personalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalRecordFindManyArgs>(args?: SelectSubset<T, PersonalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalRecord.
     * @param {PersonalRecordCreateArgs} args - Arguments to create a PersonalRecord.
     * @example
     * // Create one PersonalRecord
     * const PersonalRecord = await prisma.personalRecord.create({
     *   data: {
     *     // ... data to create a PersonalRecord
     *   }
     * })
     * 
     */
    create<T extends PersonalRecordCreateArgs>(args: SelectSubset<T, PersonalRecordCreateArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalRecords.
     * @param {PersonalRecordCreateManyArgs} args - Arguments to create many PersonalRecords.
     * @example
     * // Create many PersonalRecords
     * const personalRecord = await prisma.personalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalRecordCreateManyArgs>(args?: SelectSubset<T, PersonalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalRecords and returns the data saved in the database.
     * @param {PersonalRecordCreateManyAndReturnArgs} args - Arguments to create many PersonalRecords.
     * @example
     * // Create many PersonalRecords
     * const personalRecord = await prisma.personalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalRecords and only return the `id`
     * const personalRecordWithIdOnly = await prisma.personalRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalRecord.
     * @param {PersonalRecordDeleteArgs} args - Arguments to delete one PersonalRecord.
     * @example
     * // Delete one PersonalRecord
     * const PersonalRecord = await prisma.personalRecord.delete({
     *   where: {
     *     // ... filter to delete one PersonalRecord
     *   }
     * })
     * 
     */
    delete<T extends PersonalRecordDeleteArgs>(args: SelectSubset<T, PersonalRecordDeleteArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalRecord.
     * @param {PersonalRecordUpdateArgs} args - Arguments to update one PersonalRecord.
     * @example
     * // Update one PersonalRecord
     * const personalRecord = await prisma.personalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalRecordUpdateArgs>(args: SelectSubset<T, PersonalRecordUpdateArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalRecords.
     * @param {PersonalRecordDeleteManyArgs} args - Arguments to filter PersonalRecords to delete.
     * @example
     * // Delete a few PersonalRecords
     * const { count } = await prisma.personalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalRecordDeleteManyArgs>(args?: SelectSubset<T, PersonalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalRecords
     * const personalRecord = await prisma.personalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalRecordUpdateManyArgs>(args: SelectSubset<T, PersonalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalRecords and returns the data updated in the database.
     * @param {PersonalRecordUpdateManyAndReturnArgs} args - Arguments to update many PersonalRecords.
     * @example
     * // Update many PersonalRecords
     * const personalRecord = await prisma.personalRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalRecords and only return the `id`
     * const personalRecordWithIdOnly = await prisma.personalRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalRecord.
     * @param {PersonalRecordUpsertArgs} args - Arguments to update or create a PersonalRecord.
     * @example
     * // Update or create a PersonalRecord
     * const personalRecord = await prisma.personalRecord.upsert({
     *   create: {
     *     // ... data to create a PersonalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalRecord we want to update
     *   }
     * })
     */
    upsert<T extends PersonalRecordUpsertArgs>(args: SelectSubset<T, PersonalRecordUpsertArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordCountArgs} args - Arguments to filter PersonalRecords to count.
     * @example
     * // Count the number of PersonalRecords
     * const count = await prisma.personalRecord.count({
     *   where: {
     *     // ... the filter for the PersonalRecords we want to count
     *   }
     * })
    **/
    count<T extends PersonalRecordCountArgs>(
      args?: Subset<T, PersonalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalRecordAggregateArgs>(args: Subset<T, PersonalRecordAggregateArgs>): Prisma.PrismaPromise<GetPersonalRecordAggregateType<T>>

    /**
     * Group by PersonalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalRecordGroupByArgs['orderBy'] }
        : { orderBy?: PersonalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalRecord model
   */
  readonly fields: PersonalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workoutHistory<T extends PersonalRecord$workoutHistoryArgs<ExtArgs> = {}>(args?: Subset<T, PersonalRecord$workoutHistoryArgs<ExtArgs>>): Prisma__WorkoutHistoryClient<$Result.GetResult<Prisma.$WorkoutHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalRecord model
   */
  interface PersonalRecordFieldRefs {
    readonly id: FieldRef<"PersonalRecord", 'String'>
    readonly studentId: FieldRef<"PersonalRecord", 'String'>
    readonly workoutHistoryId: FieldRef<"PersonalRecord", 'String'>
    readonly exerciseId: FieldRef<"PersonalRecord", 'String'>
    readonly exerciseName: FieldRef<"PersonalRecord", 'String'>
    readonly type: FieldRef<"PersonalRecord", 'String'>
    readonly value: FieldRef<"PersonalRecord", 'Float'>
    readonly date: FieldRef<"PersonalRecord", 'DateTime'>
    readonly previousBest: FieldRef<"PersonalRecord", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PersonalRecord findUnique
   */
  export type PersonalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord findUniqueOrThrow
   */
  export type PersonalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord findFirst
   */
  export type PersonalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalRecords.
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalRecords.
     */
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * PersonalRecord findFirstOrThrow
   */
  export type PersonalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalRecords.
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalRecords.
     */
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * PersonalRecord findMany
   */
  export type PersonalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecords to fetch.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalRecords.
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * PersonalRecord create
   */
  export type PersonalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalRecord.
     */
    data: XOR<PersonalRecordCreateInput, PersonalRecordUncheckedCreateInput>
  }

  /**
   * PersonalRecord createMany
   */
  export type PersonalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalRecords.
     */
    data: PersonalRecordCreateManyInput | PersonalRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalRecord createManyAndReturn
   */
  export type PersonalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalRecords.
     */
    data: PersonalRecordCreateManyInput | PersonalRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalRecord update
   */
  export type PersonalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalRecord.
     */
    data: XOR<PersonalRecordUpdateInput, PersonalRecordUncheckedUpdateInput>
    /**
     * Choose, which PersonalRecord to update.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord updateMany
   */
  export type PersonalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalRecords.
     */
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyInput>
    /**
     * Filter which PersonalRecords to update
     */
    where?: PersonalRecordWhereInput
    /**
     * Limit how many PersonalRecords to update.
     */
    limit?: number
  }

  /**
   * PersonalRecord updateManyAndReturn
   */
  export type PersonalRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * The data used to update PersonalRecords.
     */
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyInput>
    /**
     * Filter which PersonalRecords to update
     */
    where?: PersonalRecordWhereInput
    /**
     * Limit how many PersonalRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalRecord upsert
   */
  export type PersonalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalRecord to update in case it exists.
     */
    where: PersonalRecordWhereUniqueInput
    /**
     * In case the PersonalRecord found by the `where` argument doesn't exist, create a new PersonalRecord with this data.
     */
    create: XOR<PersonalRecordCreateInput, PersonalRecordUncheckedCreateInput>
    /**
     * In case the PersonalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalRecordUpdateInput, PersonalRecordUncheckedUpdateInput>
  }

  /**
   * PersonalRecord delete
   */
  export type PersonalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter which PersonalRecord to delete.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord deleteMany
   */
  export type PersonalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalRecords to delete
     */
    where?: PersonalRecordWhereInput
    /**
     * Limit how many PersonalRecords to delete.
     */
    limit?: number
  }

  /**
   * PersonalRecord.workoutHistory
   */
  export type PersonalRecord$workoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutHistory
     */
    select?: WorkoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutHistory
     */
    omit?: WorkoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutHistoryInclude<ExtArgs> | null
    where?: WorkoutHistoryWhereInput
  }

  /**
   * PersonalRecord without action
   */
  export type PersonalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalRecord
     */
    omit?: PersonalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
  }


  /**
   * Model DietPlan
   */

  export type AggregateDietPlan = {
    _count: DietPlanCountAggregateOutputType | null
    _avg: DietPlanAvgAggregateOutputType | null
    _sum: DietPlanSumAggregateOutputType | null
    _min: DietPlanMinAggregateOutputType | null
    _max: DietPlanMaxAggregateOutputType | null
  }

  export type DietPlanAvgAggregateOutputType = {
    totalCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    xpReward: number | null
    order: number | null
  }

  export type DietPlanSumAggregateOutputType = {
    totalCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    xpReward: number | null
    order: number | null
  }

  export type DietPlanMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    totalCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    xpReward: number | null
    locked: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DietPlanMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    totalCalories: number | null
    targetProtein: number | null
    targetCarbs: number | null
    targetFats: number | null
    xpReward: number | null
    locked: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DietPlanCountAggregateOutputType = {
    id: number
    title: number
    description: number
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward: number
    locked: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DietPlanAvgAggregateInputType = {
    totalCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    xpReward?: true
    order?: true
  }

  export type DietPlanSumAggregateInputType = {
    totalCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    xpReward?: true
    order?: true
  }

  export type DietPlanMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    totalCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    xpReward?: true
    locked?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DietPlanMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    totalCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    xpReward?: true
    locked?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DietPlanCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    totalCalories?: true
    targetProtein?: true
    targetCarbs?: true
    targetFats?: true
    xpReward?: true
    locked?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DietPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietPlan to aggregate.
     */
    where?: DietPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlans to fetch.
     */
    orderBy?: DietPlanOrderByWithRelationInput | DietPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DietPlans
    **/
    _count?: true | DietPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DietPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DietPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietPlanMaxAggregateInputType
  }

  export type GetDietPlanAggregateType<T extends DietPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateDietPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDietPlan[P]>
      : GetScalarType<T[P], AggregateDietPlan[P]>
  }




  export type DietPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietPlanWhereInput
    orderBy?: DietPlanOrderByWithAggregationInput | DietPlanOrderByWithAggregationInput[]
    by: DietPlanScalarFieldEnum[] | DietPlanScalarFieldEnum
    having?: DietPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietPlanCountAggregateInputType | true
    _avg?: DietPlanAvgAggregateInputType
    _sum?: DietPlanSumAggregateInputType
    _min?: DietPlanMinAggregateInputType
    _max?: DietPlanMaxAggregateInputType
  }

  export type DietPlanGroupByOutputType = {
    id: string
    title: string
    description: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward: number
    locked: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: DietPlanCountAggregateOutputType | null
    _avg: DietPlanAvgAggregateOutputType | null
    _sum: DietPlanSumAggregateOutputType | null
    _min: DietPlanMinAggregateOutputType | null
    _max: DietPlanMaxAggregateOutputType | null
  }

  type GetDietPlanGroupByPayload<T extends DietPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietPlanGroupByOutputType[P]>
            : GetScalarType<T[P], DietPlanGroupByOutputType[P]>
        }
      >
    >


  export type DietPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    totalCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    xpReward?: boolean
    locked?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meals?: boolean | DietPlan$mealsArgs<ExtArgs>
    completions?: boolean | DietPlan$completionsArgs<ExtArgs>
    _count?: boolean | DietPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietPlan"]>

  export type DietPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    totalCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    xpReward?: boolean
    locked?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dietPlan"]>

  export type DietPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    totalCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    xpReward?: boolean
    locked?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dietPlan"]>

  export type DietPlanSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    totalCalories?: boolean
    targetProtein?: boolean
    targetCarbs?: boolean
    targetFats?: boolean
    xpReward?: boolean
    locked?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DietPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "totalCalories" | "targetProtein" | "targetCarbs" | "targetFats" | "xpReward" | "locked" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["dietPlan"]>
  export type DietPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meals?: boolean | DietPlan$mealsArgs<ExtArgs>
    completions?: boolean | DietPlan$completionsArgs<ExtArgs>
    _count?: boolean | DietPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DietPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DietPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DietPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DietPlan"
    objects: {
      meals: Prisma.$MealPayload<ExtArgs>[]
      completions: Prisma.$DietPlanCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      totalCalories: number
      targetProtein: number
      targetCarbs: number
      targetFats: number
      xpReward: number
      locked: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dietPlan"]>
    composites: {}
  }

  type DietPlanGetPayload<S extends boolean | null | undefined | DietPlanDefaultArgs> = $Result.GetResult<Prisma.$DietPlanPayload, S>

  type DietPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DietPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DietPlanCountAggregateInputType | true
    }

  export interface DietPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DietPlan'], meta: { name: 'DietPlan' } }
    /**
     * Find zero or one DietPlan that matches the filter.
     * @param {DietPlanFindUniqueArgs} args - Arguments to find a DietPlan
     * @example
     * // Get one DietPlan
     * const dietPlan = await prisma.dietPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietPlanFindUniqueArgs>(args: SelectSubset<T, DietPlanFindUniqueArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DietPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DietPlanFindUniqueOrThrowArgs} args - Arguments to find a DietPlan
     * @example
     * // Get one DietPlan
     * const dietPlan = await prisma.dietPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, DietPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanFindFirstArgs} args - Arguments to find a DietPlan
     * @example
     * // Get one DietPlan
     * const dietPlan = await prisma.dietPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietPlanFindFirstArgs>(args?: SelectSubset<T, DietPlanFindFirstArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanFindFirstOrThrowArgs} args - Arguments to find a DietPlan
     * @example
     * // Get one DietPlan
     * const dietPlan = await prisma.dietPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, DietPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DietPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DietPlans
     * const dietPlans = await prisma.dietPlan.findMany()
     * 
     * // Get first 10 DietPlans
     * const dietPlans = await prisma.dietPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dietPlanWithIdOnly = await prisma.dietPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DietPlanFindManyArgs>(args?: SelectSubset<T, DietPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DietPlan.
     * @param {DietPlanCreateArgs} args - Arguments to create a DietPlan.
     * @example
     * // Create one DietPlan
     * const DietPlan = await prisma.dietPlan.create({
     *   data: {
     *     // ... data to create a DietPlan
     *   }
     * })
     * 
     */
    create<T extends DietPlanCreateArgs>(args: SelectSubset<T, DietPlanCreateArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DietPlans.
     * @param {DietPlanCreateManyArgs} args - Arguments to create many DietPlans.
     * @example
     * // Create many DietPlans
     * const dietPlan = await prisma.dietPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietPlanCreateManyArgs>(args?: SelectSubset<T, DietPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DietPlans and returns the data saved in the database.
     * @param {DietPlanCreateManyAndReturnArgs} args - Arguments to create many DietPlans.
     * @example
     * // Create many DietPlans
     * const dietPlan = await prisma.dietPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DietPlans and only return the `id`
     * const dietPlanWithIdOnly = await prisma.dietPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, DietPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DietPlan.
     * @param {DietPlanDeleteArgs} args - Arguments to delete one DietPlan.
     * @example
     * // Delete one DietPlan
     * const DietPlan = await prisma.dietPlan.delete({
     *   where: {
     *     // ... filter to delete one DietPlan
     *   }
     * })
     * 
     */
    delete<T extends DietPlanDeleteArgs>(args: SelectSubset<T, DietPlanDeleteArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DietPlan.
     * @param {DietPlanUpdateArgs} args - Arguments to update one DietPlan.
     * @example
     * // Update one DietPlan
     * const dietPlan = await prisma.dietPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietPlanUpdateArgs>(args: SelectSubset<T, DietPlanUpdateArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DietPlans.
     * @param {DietPlanDeleteManyArgs} args - Arguments to filter DietPlans to delete.
     * @example
     * // Delete a few DietPlans
     * const { count } = await prisma.dietPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietPlanDeleteManyArgs>(args?: SelectSubset<T, DietPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DietPlans
     * const dietPlan = await prisma.dietPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietPlanUpdateManyArgs>(args: SelectSubset<T, DietPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietPlans and returns the data updated in the database.
     * @param {DietPlanUpdateManyAndReturnArgs} args - Arguments to update many DietPlans.
     * @example
     * // Update many DietPlans
     * const dietPlan = await prisma.dietPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DietPlans and only return the `id`
     * const dietPlanWithIdOnly = await prisma.dietPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DietPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, DietPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DietPlan.
     * @param {DietPlanUpsertArgs} args - Arguments to update or create a DietPlan.
     * @example
     * // Update or create a DietPlan
     * const dietPlan = await prisma.dietPlan.upsert({
     *   create: {
     *     // ... data to create a DietPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DietPlan we want to update
     *   }
     * })
     */
    upsert<T extends DietPlanUpsertArgs>(args: SelectSubset<T, DietPlanUpsertArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DietPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCountArgs} args - Arguments to filter DietPlans to count.
     * @example
     * // Count the number of DietPlans
     * const count = await prisma.dietPlan.count({
     *   where: {
     *     // ... the filter for the DietPlans we want to count
     *   }
     * })
    **/
    count<T extends DietPlanCountArgs>(
      args?: Subset<T, DietPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DietPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietPlanAggregateArgs>(args: Subset<T, DietPlanAggregateArgs>): Prisma.PrismaPromise<GetDietPlanAggregateType<T>>

    /**
     * Group by DietPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietPlanGroupByArgs['orderBy'] }
        : { orderBy?: DietPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DietPlan model
   */
  readonly fields: DietPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DietPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meals<T extends DietPlan$mealsArgs<ExtArgs> = {}>(args?: Subset<T, DietPlan$mealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completions<T extends DietPlan$completionsArgs<ExtArgs> = {}>(args?: Subset<T, DietPlan$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DietPlan model
   */
  interface DietPlanFieldRefs {
    readonly id: FieldRef<"DietPlan", 'String'>
    readonly title: FieldRef<"DietPlan", 'String'>
    readonly description: FieldRef<"DietPlan", 'String'>
    readonly totalCalories: FieldRef<"DietPlan", 'Int'>
    readonly targetProtein: FieldRef<"DietPlan", 'Float'>
    readonly targetCarbs: FieldRef<"DietPlan", 'Float'>
    readonly targetFats: FieldRef<"DietPlan", 'Float'>
    readonly xpReward: FieldRef<"DietPlan", 'Int'>
    readonly locked: FieldRef<"DietPlan", 'Boolean'>
    readonly order: FieldRef<"DietPlan", 'Int'>
    readonly createdAt: FieldRef<"DietPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"DietPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DietPlan findUnique
   */
  export type DietPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * Filter, which DietPlan to fetch.
     */
    where: DietPlanWhereUniqueInput
  }

  /**
   * DietPlan findUniqueOrThrow
   */
  export type DietPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * Filter, which DietPlan to fetch.
     */
    where: DietPlanWhereUniqueInput
  }

  /**
   * DietPlan findFirst
   */
  export type DietPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * Filter, which DietPlan to fetch.
     */
    where?: DietPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlans to fetch.
     */
    orderBy?: DietPlanOrderByWithRelationInput | DietPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietPlans.
     */
    cursor?: DietPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietPlans.
     */
    distinct?: DietPlanScalarFieldEnum | DietPlanScalarFieldEnum[]
  }

  /**
   * DietPlan findFirstOrThrow
   */
  export type DietPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * Filter, which DietPlan to fetch.
     */
    where?: DietPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlans to fetch.
     */
    orderBy?: DietPlanOrderByWithRelationInput | DietPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietPlans.
     */
    cursor?: DietPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietPlans.
     */
    distinct?: DietPlanScalarFieldEnum | DietPlanScalarFieldEnum[]
  }

  /**
   * DietPlan findMany
   */
  export type DietPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * Filter, which DietPlans to fetch.
     */
    where?: DietPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlans to fetch.
     */
    orderBy?: DietPlanOrderByWithRelationInput | DietPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DietPlans.
     */
    cursor?: DietPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlans.
     */
    skip?: number
    distinct?: DietPlanScalarFieldEnum | DietPlanScalarFieldEnum[]
  }

  /**
   * DietPlan create
   */
  export type DietPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a DietPlan.
     */
    data: XOR<DietPlanCreateInput, DietPlanUncheckedCreateInput>
  }

  /**
   * DietPlan createMany
   */
  export type DietPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DietPlans.
     */
    data: DietPlanCreateManyInput | DietPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietPlan createManyAndReturn
   */
  export type DietPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * The data used to create many DietPlans.
     */
    data: DietPlanCreateManyInput | DietPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietPlan update
   */
  export type DietPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a DietPlan.
     */
    data: XOR<DietPlanUpdateInput, DietPlanUncheckedUpdateInput>
    /**
     * Choose, which DietPlan to update.
     */
    where: DietPlanWhereUniqueInput
  }

  /**
   * DietPlan updateMany
   */
  export type DietPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DietPlans.
     */
    data: XOR<DietPlanUpdateManyMutationInput, DietPlanUncheckedUpdateManyInput>
    /**
     * Filter which DietPlans to update
     */
    where?: DietPlanWhereInput
    /**
     * Limit how many DietPlans to update.
     */
    limit?: number
  }

  /**
   * DietPlan updateManyAndReturn
   */
  export type DietPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * The data used to update DietPlans.
     */
    data: XOR<DietPlanUpdateManyMutationInput, DietPlanUncheckedUpdateManyInput>
    /**
     * Filter which DietPlans to update
     */
    where?: DietPlanWhereInput
    /**
     * Limit how many DietPlans to update.
     */
    limit?: number
  }

  /**
   * DietPlan upsert
   */
  export type DietPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the DietPlan to update in case it exists.
     */
    where: DietPlanWhereUniqueInput
    /**
     * In case the DietPlan found by the `where` argument doesn't exist, create a new DietPlan with this data.
     */
    create: XOR<DietPlanCreateInput, DietPlanUncheckedCreateInput>
    /**
     * In case the DietPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietPlanUpdateInput, DietPlanUncheckedUpdateInput>
  }

  /**
   * DietPlan delete
   */
  export type DietPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
    /**
     * Filter which DietPlan to delete.
     */
    where: DietPlanWhereUniqueInput
  }

  /**
   * DietPlan deleteMany
   */
  export type DietPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietPlans to delete
     */
    where?: DietPlanWhereInput
    /**
     * Limit how many DietPlans to delete.
     */
    limit?: number
  }

  /**
   * DietPlan.meals
   */
  export type DietPlan$mealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    where?: MealWhereInput
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    cursor?: MealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * DietPlan.completions
   */
  export type DietPlan$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    where?: DietPlanCompletionWhereInput
    orderBy?: DietPlanCompletionOrderByWithRelationInput | DietPlanCompletionOrderByWithRelationInput[]
    cursor?: DietPlanCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DietPlanCompletionScalarFieldEnum | DietPlanCompletionScalarFieldEnum[]
  }

  /**
   * DietPlan without action
   */
  export type DietPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlan
     */
    select?: DietPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlan
     */
    omit?: DietPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanInclude<ExtArgs> | null
  }


  /**
   * Model Meal
   */

  export type AggregateMeal = {
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  export type MealAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    order: number | null
  }

  export type MealSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    order: number | null
  }

  export type MealMinAggregateOutputType = {
    id: string | null
    dietPlanId: string | null
    name: string | null
    type: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    time: string | null
    image: string | null
    ingredients: string | null
    order: number | null
  }

  export type MealMaxAggregateOutputType = {
    id: string | null
    dietPlanId: string | null
    name: string | null
    type: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    time: string | null
    image: string | null
    ingredients: string | null
    order: number | null
  }

  export type MealCountAggregateOutputType = {
    id: number
    dietPlanId: number
    name: number
    type: number
    calories: number
    protein: number
    carbs: number
    fats: number
    time: number
    image: number
    ingredients: number
    order: number
    _all: number
  }


  export type MealAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    order?: true
  }

  export type MealSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    order?: true
  }

  export type MealMinAggregateInputType = {
    id?: true
    dietPlanId?: true
    name?: true
    type?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    time?: true
    image?: true
    ingredients?: true
    order?: true
  }

  export type MealMaxAggregateInputType = {
    id?: true
    dietPlanId?: true
    name?: true
    type?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    time?: true
    image?: true
    ingredients?: true
    order?: true
  }

  export type MealCountAggregateInputType = {
    id?: true
    dietPlanId?: true
    name?: true
    type?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    time?: true
    image?: true
    ingredients?: true
    order?: true
    _all?: true
  }

  export type MealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meal to aggregate.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meals
    **/
    _count?: true | MealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealMaxAggregateInputType
  }

  export type GetMealAggregateType<T extends MealAggregateArgs> = {
        [P in keyof T & keyof AggregateMeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeal[P]>
      : GetScalarType<T[P], AggregateMeal[P]>
  }




  export type MealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
    orderBy?: MealOrderByWithAggregationInput | MealOrderByWithAggregationInput[]
    by: MealScalarFieldEnum[] | MealScalarFieldEnum
    having?: MealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealCountAggregateInputType | true
    _avg?: MealAvgAggregateInputType
    _sum?: MealSumAggregateInputType
    _min?: MealMinAggregateInputType
    _max?: MealMaxAggregateInputType
  }

  export type MealGroupByOutputType = {
    id: string
    dietPlanId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time: string | null
    image: string | null
    ingredients: string | null
    order: number
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  type GetMealGroupByPayload<T extends MealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealGroupByOutputType[P]>
            : GetScalarType<T[P], MealGroupByOutputType[P]>
        }
      >
    >


  export type MealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dietPlanId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    image?: boolean
    ingredients?: boolean
    order?: boolean
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dietPlanId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    image?: boolean
    ingredients?: boolean
    order?: boolean
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dietPlanId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    image?: boolean
    ingredients?: boolean
    order?: boolean
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectScalar = {
    id?: boolean
    dietPlanId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    image?: boolean
    ingredients?: boolean
    order?: boolean
  }

  export type MealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dietPlanId" | "name" | "type" | "calories" | "protein" | "carbs" | "fats" | "time" | "image" | "ingredients" | "order", ExtArgs["result"]["meal"]>
  export type MealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }
  export type MealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }
  export type MealIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }

  export type $MealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meal"
    objects: {
      dietPlan: Prisma.$DietPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dietPlanId: string
      name: string
      type: string
      calories: number
      protein: number
      carbs: number
      fats: number
      time: string | null
      image: string | null
      ingredients: string | null
      order: number
    }, ExtArgs["result"]["meal"]>
    composites: {}
  }

  type MealGetPayload<S extends boolean | null | undefined | MealDefaultArgs> = $Result.GetResult<Prisma.$MealPayload, S>

  type MealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MealCountAggregateInputType | true
    }

  export interface MealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meal'], meta: { name: 'Meal' } }
    /**
     * Find zero or one Meal that matches the filter.
     * @param {MealFindUniqueArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealFindUniqueArgs>(args: SelectSubset<T, MealFindUniqueArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MealFindUniqueOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealFindUniqueOrThrowArgs>(args: SelectSubset<T, MealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealFindFirstArgs>(args?: SelectSubset<T, MealFindFirstArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealFindFirstOrThrowArgs>(args?: SelectSubset<T, MealFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meals
     * const meals = await prisma.meal.findMany()
     * 
     * // Get first 10 Meals
     * const meals = await prisma.meal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealWithIdOnly = await prisma.meal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealFindManyArgs>(args?: SelectSubset<T, MealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meal.
     * @param {MealCreateArgs} args - Arguments to create a Meal.
     * @example
     * // Create one Meal
     * const Meal = await prisma.meal.create({
     *   data: {
     *     // ... data to create a Meal
     *   }
     * })
     * 
     */
    create<T extends MealCreateArgs>(args: SelectSubset<T, MealCreateArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meals.
     * @param {MealCreateManyArgs} args - Arguments to create many Meals.
     * @example
     * // Create many Meals
     * const meal = await prisma.meal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealCreateManyArgs>(args?: SelectSubset<T, MealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meals and returns the data saved in the database.
     * @param {MealCreateManyAndReturnArgs} args - Arguments to create many Meals.
     * @example
     * // Create many Meals
     * const meal = await prisma.meal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meals and only return the `id`
     * const mealWithIdOnly = await prisma.meal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealCreateManyAndReturnArgs>(args?: SelectSubset<T, MealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Meal.
     * @param {MealDeleteArgs} args - Arguments to delete one Meal.
     * @example
     * // Delete one Meal
     * const Meal = await prisma.meal.delete({
     *   where: {
     *     // ... filter to delete one Meal
     *   }
     * })
     * 
     */
    delete<T extends MealDeleteArgs>(args: SelectSubset<T, MealDeleteArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meal.
     * @param {MealUpdateArgs} args - Arguments to update one Meal.
     * @example
     * // Update one Meal
     * const meal = await prisma.meal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealUpdateArgs>(args: SelectSubset<T, MealUpdateArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meals.
     * @param {MealDeleteManyArgs} args - Arguments to filter Meals to delete.
     * @example
     * // Delete a few Meals
     * const { count } = await prisma.meal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealDeleteManyArgs>(args?: SelectSubset<T, MealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meals
     * const meal = await prisma.meal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealUpdateManyArgs>(args: SelectSubset<T, MealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meals and returns the data updated in the database.
     * @param {MealUpdateManyAndReturnArgs} args - Arguments to update many Meals.
     * @example
     * // Update many Meals
     * const meal = await prisma.meal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Meals and only return the `id`
     * const mealWithIdOnly = await prisma.meal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MealUpdateManyAndReturnArgs>(args: SelectSubset<T, MealUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Meal.
     * @param {MealUpsertArgs} args - Arguments to update or create a Meal.
     * @example
     * // Update or create a Meal
     * const meal = await prisma.meal.upsert({
     *   create: {
     *     // ... data to create a Meal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meal we want to update
     *   }
     * })
     */
    upsert<T extends MealUpsertArgs>(args: SelectSubset<T, MealUpsertArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealCountArgs} args - Arguments to filter Meals to count.
     * @example
     * // Count the number of Meals
     * const count = await prisma.meal.count({
     *   where: {
     *     // ... the filter for the Meals we want to count
     *   }
     * })
    **/
    count<T extends MealCountArgs>(
      args?: Subset<T, MealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealAggregateArgs>(args: Subset<T, MealAggregateArgs>): Prisma.PrismaPromise<GetMealAggregateType<T>>

    /**
     * Group by Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealGroupByArgs['orderBy'] }
        : { orderBy?: MealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meal model
   */
  readonly fields: MealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dietPlan<T extends DietPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DietPlanDefaultArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meal model
   */
  interface MealFieldRefs {
    readonly id: FieldRef<"Meal", 'String'>
    readonly dietPlanId: FieldRef<"Meal", 'String'>
    readonly name: FieldRef<"Meal", 'String'>
    readonly type: FieldRef<"Meal", 'String'>
    readonly calories: FieldRef<"Meal", 'Int'>
    readonly protein: FieldRef<"Meal", 'Float'>
    readonly carbs: FieldRef<"Meal", 'Float'>
    readonly fats: FieldRef<"Meal", 'Float'>
    readonly time: FieldRef<"Meal", 'String'>
    readonly image: FieldRef<"Meal", 'String'>
    readonly ingredients: FieldRef<"Meal", 'String'>
    readonly order: FieldRef<"Meal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Meal findUnique
   */
  export type MealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findUniqueOrThrow
   */
  export type MealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findFirst
   */
  export type MealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal findFirstOrThrow
   */
  export type MealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal findMany
   */
  export type MealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meals to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal create
   */
  export type MealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The data needed to create a Meal.
     */
    data: XOR<MealCreateInput, MealUncheckedCreateInput>
  }

  /**
   * Meal createMany
   */
  export type MealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meals.
     */
    data: MealCreateManyInput | MealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meal createManyAndReturn
   */
  export type MealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * The data used to create many Meals.
     */
    data: MealCreateManyInput | MealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meal update
   */
  export type MealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The data needed to update a Meal.
     */
    data: XOR<MealUpdateInput, MealUncheckedUpdateInput>
    /**
     * Choose, which Meal to update.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal updateMany
   */
  export type MealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meals.
     */
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyInput>
    /**
     * Filter which Meals to update
     */
    where?: MealWhereInput
    /**
     * Limit how many Meals to update.
     */
    limit?: number
  }

  /**
   * Meal updateManyAndReturn
   */
  export type MealUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * The data used to update Meals.
     */
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyInput>
    /**
     * Filter which Meals to update
     */
    where?: MealWhereInput
    /**
     * Limit how many Meals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meal upsert
   */
  export type MealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The filter to search for the Meal to update in case it exists.
     */
    where: MealWhereUniqueInput
    /**
     * In case the Meal found by the `where` argument doesn't exist, create a new Meal with this data.
     */
    create: XOR<MealCreateInput, MealUncheckedCreateInput>
    /**
     * In case the Meal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealUpdateInput, MealUncheckedUpdateInput>
  }

  /**
   * Meal delete
   */
  export type MealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter which Meal to delete.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal deleteMany
   */
  export type MealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meals to delete
     */
    where?: MealWhereInput
    /**
     * Limit how many Meals to delete.
     */
    limit?: number
  }

  /**
   * Meal without action
   */
  export type MealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meal
     */
    omit?: MealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
  }


  /**
   * Model DietPlanCompletion
   */

  export type AggregateDietPlanCompletion = {
    _count: DietPlanCompletionCountAggregateOutputType | null
    _min: DietPlanCompletionMinAggregateOutputType | null
    _max: DietPlanCompletionMaxAggregateOutputType | null
  }

  export type DietPlanCompletionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    dietPlanId: string | null
    date: Date | null
    completed: boolean | null
  }

  export type DietPlanCompletionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    dietPlanId: string | null
    date: Date | null
    completed: boolean | null
  }

  export type DietPlanCompletionCountAggregateOutputType = {
    id: number
    studentId: number
    dietPlanId: number
    date: number
    completed: number
    _all: number
  }


  export type DietPlanCompletionMinAggregateInputType = {
    id?: true
    studentId?: true
    dietPlanId?: true
    date?: true
    completed?: true
  }

  export type DietPlanCompletionMaxAggregateInputType = {
    id?: true
    studentId?: true
    dietPlanId?: true
    date?: true
    completed?: true
  }

  export type DietPlanCompletionCountAggregateInputType = {
    id?: true
    studentId?: true
    dietPlanId?: true
    date?: true
    completed?: true
    _all?: true
  }

  export type DietPlanCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietPlanCompletion to aggregate.
     */
    where?: DietPlanCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlanCompletions to fetch.
     */
    orderBy?: DietPlanCompletionOrderByWithRelationInput | DietPlanCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietPlanCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlanCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlanCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DietPlanCompletions
    **/
    _count?: true | DietPlanCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietPlanCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietPlanCompletionMaxAggregateInputType
  }

  export type GetDietPlanCompletionAggregateType<T extends DietPlanCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateDietPlanCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDietPlanCompletion[P]>
      : GetScalarType<T[P], AggregateDietPlanCompletion[P]>
  }




  export type DietPlanCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietPlanCompletionWhereInput
    orderBy?: DietPlanCompletionOrderByWithAggregationInput | DietPlanCompletionOrderByWithAggregationInput[]
    by: DietPlanCompletionScalarFieldEnum[] | DietPlanCompletionScalarFieldEnum
    having?: DietPlanCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietPlanCompletionCountAggregateInputType | true
    _min?: DietPlanCompletionMinAggregateInputType
    _max?: DietPlanCompletionMaxAggregateInputType
  }

  export type DietPlanCompletionGroupByOutputType = {
    id: string
    studentId: string
    dietPlanId: string
    date: Date
    completed: boolean
    _count: DietPlanCompletionCountAggregateOutputType | null
    _min: DietPlanCompletionMinAggregateOutputType | null
    _max: DietPlanCompletionMaxAggregateOutputType | null
  }

  type GetDietPlanCompletionGroupByPayload<T extends DietPlanCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietPlanCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietPlanCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietPlanCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], DietPlanCompletionGroupByOutputType[P]>
        }
      >
    >


  export type DietPlanCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    dietPlanId?: boolean
    date?: boolean
    completed?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietPlanCompletion"]>

  export type DietPlanCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    dietPlanId?: boolean
    date?: boolean
    completed?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietPlanCompletion"]>

  export type DietPlanCompletionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    dietPlanId?: boolean
    date?: boolean
    completed?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietPlanCompletion"]>

  export type DietPlanCompletionSelectScalar = {
    id?: boolean
    studentId?: boolean
    dietPlanId?: boolean
    date?: boolean
    completed?: boolean
  }

  export type DietPlanCompletionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "dietPlanId" | "date" | "completed", ExtArgs["result"]["dietPlanCompletion"]>
  export type DietPlanCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }
  export type DietPlanCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }
  export type DietPlanCompletionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    dietPlan?: boolean | DietPlanDefaultArgs<ExtArgs>
  }

  export type $DietPlanCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DietPlanCompletion"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      dietPlan: Prisma.$DietPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      dietPlanId: string
      date: Date
      completed: boolean
    }, ExtArgs["result"]["dietPlanCompletion"]>
    composites: {}
  }

  type DietPlanCompletionGetPayload<S extends boolean | null | undefined | DietPlanCompletionDefaultArgs> = $Result.GetResult<Prisma.$DietPlanCompletionPayload, S>

  type DietPlanCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DietPlanCompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DietPlanCompletionCountAggregateInputType | true
    }

  export interface DietPlanCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DietPlanCompletion'], meta: { name: 'DietPlanCompletion' } }
    /**
     * Find zero or one DietPlanCompletion that matches the filter.
     * @param {DietPlanCompletionFindUniqueArgs} args - Arguments to find a DietPlanCompletion
     * @example
     * // Get one DietPlanCompletion
     * const dietPlanCompletion = await prisma.dietPlanCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietPlanCompletionFindUniqueArgs>(args: SelectSubset<T, DietPlanCompletionFindUniqueArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DietPlanCompletion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DietPlanCompletionFindUniqueOrThrowArgs} args - Arguments to find a DietPlanCompletion
     * @example
     * // Get one DietPlanCompletion
     * const dietPlanCompletion = await prisma.dietPlanCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietPlanCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, DietPlanCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietPlanCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionFindFirstArgs} args - Arguments to find a DietPlanCompletion
     * @example
     * // Get one DietPlanCompletion
     * const dietPlanCompletion = await prisma.dietPlanCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietPlanCompletionFindFirstArgs>(args?: SelectSubset<T, DietPlanCompletionFindFirstArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietPlanCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionFindFirstOrThrowArgs} args - Arguments to find a DietPlanCompletion
     * @example
     * // Get one DietPlanCompletion
     * const dietPlanCompletion = await prisma.dietPlanCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietPlanCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, DietPlanCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DietPlanCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DietPlanCompletions
     * const dietPlanCompletions = await prisma.dietPlanCompletion.findMany()
     * 
     * // Get first 10 DietPlanCompletions
     * const dietPlanCompletions = await prisma.dietPlanCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dietPlanCompletionWithIdOnly = await prisma.dietPlanCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DietPlanCompletionFindManyArgs>(args?: SelectSubset<T, DietPlanCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DietPlanCompletion.
     * @param {DietPlanCompletionCreateArgs} args - Arguments to create a DietPlanCompletion.
     * @example
     * // Create one DietPlanCompletion
     * const DietPlanCompletion = await prisma.dietPlanCompletion.create({
     *   data: {
     *     // ... data to create a DietPlanCompletion
     *   }
     * })
     * 
     */
    create<T extends DietPlanCompletionCreateArgs>(args: SelectSubset<T, DietPlanCompletionCreateArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DietPlanCompletions.
     * @param {DietPlanCompletionCreateManyArgs} args - Arguments to create many DietPlanCompletions.
     * @example
     * // Create many DietPlanCompletions
     * const dietPlanCompletion = await prisma.dietPlanCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietPlanCompletionCreateManyArgs>(args?: SelectSubset<T, DietPlanCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DietPlanCompletions and returns the data saved in the database.
     * @param {DietPlanCompletionCreateManyAndReturnArgs} args - Arguments to create many DietPlanCompletions.
     * @example
     * // Create many DietPlanCompletions
     * const dietPlanCompletion = await prisma.dietPlanCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DietPlanCompletions and only return the `id`
     * const dietPlanCompletionWithIdOnly = await prisma.dietPlanCompletion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietPlanCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, DietPlanCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DietPlanCompletion.
     * @param {DietPlanCompletionDeleteArgs} args - Arguments to delete one DietPlanCompletion.
     * @example
     * // Delete one DietPlanCompletion
     * const DietPlanCompletion = await prisma.dietPlanCompletion.delete({
     *   where: {
     *     // ... filter to delete one DietPlanCompletion
     *   }
     * })
     * 
     */
    delete<T extends DietPlanCompletionDeleteArgs>(args: SelectSubset<T, DietPlanCompletionDeleteArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DietPlanCompletion.
     * @param {DietPlanCompletionUpdateArgs} args - Arguments to update one DietPlanCompletion.
     * @example
     * // Update one DietPlanCompletion
     * const dietPlanCompletion = await prisma.dietPlanCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietPlanCompletionUpdateArgs>(args: SelectSubset<T, DietPlanCompletionUpdateArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DietPlanCompletions.
     * @param {DietPlanCompletionDeleteManyArgs} args - Arguments to filter DietPlanCompletions to delete.
     * @example
     * // Delete a few DietPlanCompletions
     * const { count } = await prisma.dietPlanCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietPlanCompletionDeleteManyArgs>(args?: SelectSubset<T, DietPlanCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietPlanCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DietPlanCompletions
     * const dietPlanCompletion = await prisma.dietPlanCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietPlanCompletionUpdateManyArgs>(args: SelectSubset<T, DietPlanCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietPlanCompletions and returns the data updated in the database.
     * @param {DietPlanCompletionUpdateManyAndReturnArgs} args - Arguments to update many DietPlanCompletions.
     * @example
     * // Update many DietPlanCompletions
     * const dietPlanCompletion = await prisma.dietPlanCompletion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DietPlanCompletions and only return the `id`
     * const dietPlanCompletionWithIdOnly = await prisma.dietPlanCompletion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DietPlanCompletionUpdateManyAndReturnArgs>(args: SelectSubset<T, DietPlanCompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DietPlanCompletion.
     * @param {DietPlanCompletionUpsertArgs} args - Arguments to update or create a DietPlanCompletion.
     * @example
     * // Update or create a DietPlanCompletion
     * const dietPlanCompletion = await prisma.dietPlanCompletion.upsert({
     *   create: {
     *     // ... data to create a DietPlanCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DietPlanCompletion we want to update
     *   }
     * })
     */
    upsert<T extends DietPlanCompletionUpsertArgs>(args: SelectSubset<T, DietPlanCompletionUpsertArgs<ExtArgs>>): Prisma__DietPlanCompletionClient<$Result.GetResult<Prisma.$DietPlanCompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DietPlanCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionCountArgs} args - Arguments to filter DietPlanCompletions to count.
     * @example
     * // Count the number of DietPlanCompletions
     * const count = await prisma.dietPlanCompletion.count({
     *   where: {
     *     // ... the filter for the DietPlanCompletions we want to count
     *   }
     * })
    **/
    count<T extends DietPlanCompletionCountArgs>(
      args?: Subset<T, DietPlanCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietPlanCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DietPlanCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietPlanCompletionAggregateArgs>(args: Subset<T, DietPlanCompletionAggregateArgs>): Prisma.PrismaPromise<GetDietPlanCompletionAggregateType<T>>

    /**
     * Group by DietPlanCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietPlanCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietPlanCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietPlanCompletionGroupByArgs['orderBy'] }
        : { orderBy?: DietPlanCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietPlanCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietPlanCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DietPlanCompletion model
   */
  readonly fields: DietPlanCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DietPlanCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietPlanCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dietPlan<T extends DietPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DietPlanDefaultArgs<ExtArgs>>): Prisma__DietPlanClient<$Result.GetResult<Prisma.$DietPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DietPlanCompletion model
   */
  interface DietPlanCompletionFieldRefs {
    readonly id: FieldRef<"DietPlanCompletion", 'String'>
    readonly studentId: FieldRef<"DietPlanCompletion", 'String'>
    readonly dietPlanId: FieldRef<"DietPlanCompletion", 'String'>
    readonly date: FieldRef<"DietPlanCompletion", 'DateTime'>
    readonly completed: FieldRef<"DietPlanCompletion", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DietPlanCompletion findUnique
   */
  export type DietPlanCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * Filter, which DietPlanCompletion to fetch.
     */
    where: DietPlanCompletionWhereUniqueInput
  }

  /**
   * DietPlanCompletion findUniqueOrThrow
   */
  export type DietPlanCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * Filter, which DietPlanCompletion to fetch.
     */
    where: DietPlanCompletionWhereUniqueInput
  }

  /**
   * DietPlanCompletion findFirst
   */
  export type DietPlanCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * Filter, which DietPlanCompletion to fetch.
     */
    where?: DietPlanCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlanCompletions to fetch.
     */
    orderBy?: DietPlanCompletionOrderByWithRelationInput | DietPlanCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietPlanCompletions.
     */
    cursor?: DietPlanCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlanCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlanCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietPlanCompletions.
     */
    distinct?: DietPlanCompletionScalarFieldEnum | DietPlanCompletionScalarFieldEnum[]
  }

  /**
   * DietPlanCompletion findFirstOrThrow
   */
  export type DietPlanCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * Filter, which DietPlanCompletion to fetch.
     */
    where?: DietPlanCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlanCompletions to fetch.
     */
    orderBy?: DietPlanCompletionOrderByWithRelationInput | DietPlanCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietPlanCompletions.
     */
    cursor?: DietPlanCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlanCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlanCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietPlanCompletions.
     */
    distinct?: DietPlanCompletionScalarFieldEnum | DietPlanCompletionScalarFieldEnum[]
  }

  /**
   * DietPlanCompletion findMany
   */
  export type DietPlanCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * Filter, which DietPlanCompletions to fetch.
     */
    where?: DietPlanCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietPlanCompletions to fetch.
     */
    orderBy?: DietPlanCompletionOrderByWithRelationInput | DietPlanCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DietPlanCompletions.
     */
    cursor?: DietPlanCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietPlanCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietPlanCompletions.
     */
    skip?: number
    distinct?: DietPlanCompletionScalarFieldEnum | DietPlanCompletionScalarFieldEnum[]
  }

  /**
   * DietPlanCompletion create
   */
  export type DietPlanCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a DietPlanCompletion.
     */
    data: XOR<DietPlanCompletionCreateInput, DietPlanCompletionUncheckedCreateInput>
  }

  /**
   * DietPlanCompletion createMany
   */
  export type DietPlanCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DietPlanCompletions.
     */
    data: DietPlanCompletionCreateManyInput | DietPlanCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DietPlanCompletion createManyAndReturn
   */
  export type DietPlanCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * The data used to create many DietPlanCompletions.
     */
    data: DietPlanCompletionCreateManyInput | DietPlanCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DietPlanCompletion update
   */
  export type DietPlanCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a DietPlanCompletion.
     */
    data: XOR<DietPlanCompletionUpdateInput, DietPlanCompletionUncheckedUpdateInput>
    /**
     * Choose, which DietPlanCompletion to update.
     */
    where: DietPlanCompletionWhereUniqueInput
  }

  /**
   * DietPlanCompletion updateMany
   */
  export type DietPlanCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DietPlanCompletions.
     */
    data: XOR<DietPlanCompletionUpdateManyMutationInput, DietPlanCompletionUncheckedUpdateManyInput>
    /**
     * Filter which DietPlanCompletions to update
     */
    where?: DietPlanCompletionWhereInput
    /**
     * Limit how many DietPlanCompletions to update.
     */
    limit?: number
  }

  /**
   * DietPlanCompletion updateManyAndReturn
   */
  export type DietPlanCompletionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * The data used to update DietPlanCompletions.
     */
    data: XOR<DietPlanCompletionUpdateManyMutationInput, DietPlanCompletionUncheckedUpdateManyInput>
    /**
     * Filter which DietPlanCompletions to update
     */
    where?: DietPlanCompletionWhereInput
    /**
     * Limit how many DietPlanCompletions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DietPlanCompletion upsert
   */
  export type DietPlanCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the DietPlanCompletion to update in case it exists.
     */
    where: DietPlanCompletionWhereUniqueInput
    /**
     * In case the DietPlanCompletion found by the `where` argument doesn't exist, create a new DietPlanCompletion with this data.
     */
    create: XOR<DietPlanCompletionCreateInput, DietPlanCompletionUncheckedCreateInput>
    /**
     * In case the DietPlanCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietPlanCompletionUpdateInput, DietPlanCompletionUncheckedUpdateInput>
  }

  /**
   * DietPlanCompletion delete
   */
  export type DietPlanCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
    /**
     * Filter which DietPlanCompletion to delete.
     */
    where: DietPlanCompletionWhereUniqueInput
  }

  /**
   * DietPlanCompletion deleteMany
   */
  export type DietPlanCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietPlanCompletions to delete
     */
    where?: DietPlanCompletionWhereInput
    /**
     * Limit how many DietPlanCompletions to delete.
     */
    limit?: number
  }

  /**
   * DietPlanCompletion without action
   */
  export type DietPlanCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietPlanCompletion
     */
    select?: DietPlanCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietPlanCompletion
     */
    omit?: DietPlanCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietPlanCompletionInclude<ExtArgs> | null
  }


  /**
   * Model DailyNutrition
   */

  export type AggregateDailyNutrition = {
    _count: DailyNutritionCountAggregateOutputType | null
    _avg: DailyNutritionAvgAggregateOutputType | null
    _sum: DailyNutritionSumAggregateOutputType | null
    _min: DailyNutritionMinAggregateOutputType | null
    _max: DailyNutritionMaxAggregateOutputType | null
  }

  export type DailyNutritionAvgAggregateOutputType = {
    waterIntake: number | null
  }

  export type DailyNutritionSumAggregateOutputType = {
    waterIntake: number | null
  }

  export type DailyNutritionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    waterIntake: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyNutritionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    waterIntake: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyNutritionCountAggregateOutputType = {
    id: number
    studentId: number
    date: number
    waterIntake: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyNutritionAvgAggregateInputType = {
    waterIntake?: true
  }

  export type DailyNutritionSumAggregateInputType = {
    waterIntake?: true
  }

  export type DailyNutritionMinAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    waterIntake?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyNutritionMaxAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    waterIntake?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyNutritionCountAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    waterIntake?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyNutritionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyNutrition to aggregate.
     */
    where?: DailyNutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyNutritions to fetch.
     */
    orderBy?: DailyNutritionOrderByWithRelationInput | DailyNutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyNutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyNutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyNutritions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyNutritions
    **/
    _count?: true | DailyNutritionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyNutritionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyNutritionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyNutritionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyNutritionMaxAggregateInputType
  }

  export type GetDailyNutritionAggregateType<T extends DailyNutritionAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyNutrition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyNutrition[P]>
      : GetScalarType<T[P], AggregateDailyNutrition[P]>
  }




  export type DailyNutritionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyNutritionWhereInput
    orderBy?: DailyNutritionOrderByWithAggregationInput | DailyNutritionOrderByWithAggregationInput[]
    by: DailyNutritionScalarFieldEnum[] | DailyNutritionScalarFieldEnum
    having?: DailyNutritionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyNutritionCountAggregateInputType | true
    _avg?: DailyNutritionAvgAggregateInputType
    _sum?: DailyNutritionSumAggregateInputType
    _min?: DailyNutritionMinAggregateInputType
    _max?: DailyNutritionMaxAggregateInputType
  }

  export type DailyNutritionGroupByOutputType = {
    id: string
    studentId: string
    date: Date
    waterIntake: number
    createdAt: Date
    updatedAt: Date
    _count: DailyNutritionCountAggregateOutputType | null
    _avg: DailyNutritionAvgAggregateOutputType | null
    _sum: DailyNutritionSumAggregateOutputType | null
    _min: DailyNutritionMinAggregateOutputType | null
    _max: DailyNutritionMaxAggregateOutputType | null
  }

  type GetDailyNutritionGroupByPayload<T extends DailyNutritionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyNutritionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyNutritionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyNutritionGroupByOutputType[P]>
            : GetScalarType<T[P], DailyNutritionGroupByOutputType[P]>
        }
      >
    >


  export type DailyNutritionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    waterIntake?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    meals?: boolean | DailyNutrition$mealsArgs<ExtArgs>
    _count?: boolean | DailyNutritionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyNutrition"]>

  export type DailyNutritionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    waterIntake?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyNutrition"]>

  export type DailyNutritionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    waterIntake?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyNutrition"]>

  export type DailyNutritionSelectScalar = {
    id?: boolean
    studentId?: boolean
    date?: boolean
    waterIntake?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyNutritionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "date" | "waterIntake" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyNutrition"]>
  export type DailyNutritionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    meals?: boolean | DailyNutrition$mealsArgs<ExtArgs>
    _count?: boolean | DailyNutritionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailyNutritionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type DailyNutritionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $DailyNutritionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyNutrition"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      meals: Prisma.$NutritionMealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      date: Date
      waterIntake: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyNutrition"]>
    composites: {}
  }

  type DailyNutritionGetPayload<S extends boolean | null | undefined | DailyNutritionDefaultArgs> = $Result.GetResult<Prisma.$DailyNutritionPayload, S>

  type DailyNutritionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyNutritionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyNutritionCountAggregateInputType | true
    }

  export interface DailyNutritionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyNutrition'], meta: { name: 'DailyNutrition' } }
    /**
     * Find zero or one DailyNutrition that matches the filter.
     * @param {DailyNutritionFindUniqueArgs} args - Arguments to find a DailyNutrition
     * @example
     * // Get one DailyNutrition
     * const dailyNutrition = await prisma.dailyNutrition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyNutritionFindUniqueArgs>(args: SelectSubset<T, DailyNutritionFindUniqueArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyNutrition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyNutritionFindUniqueOrThrowArgs} args - Arguments to find a DailyNutrition
     * @example
     * // Get one DailyNutrition
     * const dailyNutrition = await prisma.dailyNutrition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyNutritionFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyNutritionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyNutrition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionFindFirstArgs} args - Arguments to find a DailyNutrition
     * @example
     * // Get one DailyNutrition
     * const dailyNutrition = await prisma.dailyNutrition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyNutritionFindFirstArgs>(args?: SelectSubset<T, DailyNutritionFindFirstArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyNutrition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionFindFirstOrThrowArgs} args - Arguments to find a DailyNutrition
     * @example
     * // Get one DailyNutrition
     * const dailyNutrition = await prisma.dailyNutrition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyNutritionFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyNutritionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyNutritions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyNutritions
     * const dailyNutritions = await prisma.dailyNutrition.findMany()
     * 
     * // Get first 10 DailyNutritions
     * const dailyNutritions = await prisma.dailyNutrition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyNutritionWithIdOnly = await prisma.dailyNutrition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyNutritionFindManyArgs>(args?: SelectSubset<T, DailyNutritionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyNutrition.
     * @param {DailyNutritionCreateArgs} args - Arguments to create a DailyNutrition.
     * @example
     * // Create one DailyNutrition
     * const DailyNutrition = await prisma.dailyNutrition.create({
     *   data: {
     *     // ... data to create a DailyNutrition
     *   }
     * })
     * 
     */
    create<T extends DailyNutritionCreateArgs>(args: SelectSubset<T, DailyNutritionCreateArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyNutritions.
     * @param {DailyNutritionCreateManyArgs} args - Arguments to create many DailyNutritions.
     * @example
     * // Create many DailyNutritions
     * const dailyNutrition = await prisma.dailyNutrition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyNutritionCreateManyArgs>(args?: SelectSubset<T, DailyNutritionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyNutritions and returns the data saved in the database.
     * @param {DailyNutritionCreateManyAndReturnArgs} args - Arguments to create many DailyNutritions.
     * @example
     * // Create many DailyNutritions
     * const dailyNutrition = await prisma.dailyNutrition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyNutritions and only return the `id`
     * const dailyNutritionWithIdOnly = await prisma.dailyNutrition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyNutritionCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyNutritionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyNutrition.
     * @param {DailyNutritionDeleteArgs} args - Arguments to delete one DailyNutrition.
     * @example
     * // Delete one DailyNutrition
     * const DailyNutrition = await prisma.dailyNutrition.delete({
     *   where: {
     *     // ... filter to delete one DailyNutrition
     *   }
     * })
     * 
     */
    delete<T extends DailyNutritionDeleteArgs>(args: SelectSubset<T, DailyNutritionDeleteArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyNutrition.
     * @param {DailyNutritionUpdateArgs} args - Arguments to update one DailyNutrition.
     * @example
     * // Update one DailyNutrition
     * const dailyNutrition = await prisma.dailyNutrition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyNutritionUpdateArgs>(args: SelectSubset<T, DailyNutritionUpdateArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyNutritions.
     * @param {DailyNutritionDeleteManyArgs} args - Arguments to filter DailyNutritions to delete.
     * @example
     * // Delete a few DailyNutritions
     * const { count } = await prisma.dailyNutrition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyNutritionDeleteManyArgs>(args?: SelectSubset<T, DailyNutritionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyNutritions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyNutritions
     * const dailyNutrition = await prisma.dailyNutrition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyNutritionUpdateManyArgs>(args: SelectSubset<T, DailyNutritionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyNutritions and returns the data updated in the database.
     * @param {DailyNutritionUpdateManyAndReturnArgs} args - Arguments to update many DailyNutritions.
     * @example
     * // Update many DailyNutritions
     * const dailyNutrition = await prisma.dailyNutrition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyNutritions and only return the `id`
     * const dailyNutritionWithIdOnly = await prisma.dailyNutrition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyNutritionUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyNutritionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyNutrition.
     * @param {DailyNutritionUpsertArgs} args - Arguments to update or create a DailyNutrition.
     * @example
     * // Update or create a DailyNutrition
     * const dailyNutrition = await prisma.dailyNutrition.upsert({
     *   create: {
     *     // ... data to create a DailyNutrition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyNutrition we want to update
     *   }
     * })
     */
    upsert<T extends DailyNutritionUpsertArgs>(args: SelectSubset<T, DailyNutritionUpsertArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyNutritions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionCountArgs} args - Arguments to filter DailyNutritions to count.
     * @example
     * // Count the number of DailyNutritions
     * const count = await prisma.dailyNutrition.count({
     *   where: {
     *     // ... the filter for the DailyNutritions we want to count
     *   }
     * })
    **/
    count<T extends DailyNutritionCountArgs>(
      args?: Subset<T, DailyNutritionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyNutritionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyNutrition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyNutritionAggregateArgs>(args: Subset<T, DailyNutritionAggregateArgs>): Prisma.PrismaPromise<GetDailyNutritionAggregateType<T>>

    /**
     * Group by DailyNutrition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyNutritionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyNutritionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyNutritionGroupByArgs['orderBy'] }
        : { orderBy?: DailyNutritionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyNutritionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyNutritionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyNutrition model
   */
  readonly fields: DailyNutritionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyNutrition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyNutritionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    meals<T extends DailyNutrition$mealsArgs<ExtArgs> = {}>(args?: Subset<T, DailyNutrition$mealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyNutrition model
   */
  interface DailyNutritionFieldRefs {
    readonly id: FieldRef<"DailyNutrition", 'String'>
    readonly studentId: FieldRef<"DailyNutrition", 'String'>
    readonly date: FieldRef<"DailyNutrition", 'DateTime'>
    readonly waterIntake: FieldRef<"DailyNutrition", 'Int'>
    readonly createdAt: FieldRef<"DailyNutrition", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyNutrition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyNutrition findUnique
   */
  export type DailyNutritionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * Filter, which DailyNutrition to fetch.
     */
    where: DailyNutritionWhereUniqueInput
  }

  /**
   * DailyNutrition findUniqueOrThrow
   */
  export type DailyNutritionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * Filter, which DailyNutrition to fetch.
     */
    where: DailyNutritionWhereUniqueInput
  }

  /**
   * DailyNutrition findFirst
   */
  export type DailyNutritionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * Filter, which DailyNutrition to fetch.
     */
    where?: DailyNutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyNutritions to fetch.
     */
    orderBy?: DailyNutritionOrderByWithRelationInput | DailyNutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyNutritions.
     */
    cursor?: DailyNutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyNutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyNutritions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyNutritions.
     */
    distinct?: DailyNutritionScalarFieldEnum | DailyNutritionScalarFieldEnum[]
  }

  /**
   * DailyNutrition findFirstOrThrow
   */
  export type DailyNutritionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * Filter, which DailyNutrition to fetch.
     */
    where?: DailyNutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyNutritions to fetch.
     */
    orderBy?: DailyNutritionOrderByWithRelationInput | DailyNutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyNutritions.
     */
    cursor?: DailyNutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyNutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyNutritions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyNutritions.
     */
    distinct?: DailyNutritionScalarFieldEnum | DailyNutritionScalarFieldEnum[]
  }

  /**
   * DailyNutrition findMany
   */
  export type DailyNutritionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * Filter, which DailyNutritions to fetch.
     */
    where?: DailyNutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyNutritions to fetch.
     */
    orderBy?: DailyNutritionOrderByWithRelationInput | DailyNutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyNutritions.
     */
    cursor?: DailyNutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyNutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyNutritions.
     */
    skip?: number
    distinct?: DailyNutritionScalarFieldEnum | DailyNutritionScalarFieldEnum[]
  }

  /**
   * DailyNutrition create
   */
  export type DailyNutritionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyNutrition.
     */
    data: XOR<DailyNutritionCreateInput, DailyNutritionUncheckedCreateInput>
  }

  /**
   * DailyNutrition createMany
   */
  export type DailyNutritionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyNutritions.
     */
    data: DailyNutritionCreateManyInput | DailyNutritionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyNutrition createManyAndReturn
   */
  export type DailyNutritionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * The data used to create many DailyNutritions.
     */
    data: DailyNutritionCreateManyInput | DailyNutritionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyNutrition update
   */
  export type DailyNutritionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyNutrition.
     */
    data: XOR<DailyNutritionUpdateInput, DailyNutritionUncheckedUpdateInput>
    /**
     * Choose, which DailyNutrition to update.
     */
    where: DailyNutritionWhereUniqueInput
  }

  /**
   * DailyNutrition updateMany
   */
  export type DailyNutritionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyNutritions.
     */
    data: XOR<DailyNutritionUpdateManyMutationInput, DailyNutritionUncheckedUpdateManyInput>
    /**
     * Filter which DailyNutritions to update
     */
    where?: DailyNutritionWhereInput
    /**
     * Limit how many DailyNutritions to update.
     */
    limit?: number
  }

  /**
   * DailyNutrition updateManyAndReturn
   */
  export type DailyNutritionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * The data used to update DailyNutritions.
     */
    data: XOR<DailyNutritionUpdateManyMutationInput, DailyNutritionUncheckedUpdateManyInput>
    /**
     * Filter which DailyNutritions to update
     */
    where?: DailyNutritionWhereInput
    /**
     * Limit how many DailyNutritions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyNutrition upsert
   */
  export type DailyNutritionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyNutrition to update in case it exists.
     */
    where: DailyNutritionWhereUniqueInput
    /**
     * In case the DailyNutrition found by the `where` argument doesn't exist, create a new DailyNutrition with this data.
     */
    create: XOR<DailyNutritionCreateInput, DailyNutritionUncheckedCreateInput>
    /**
     * In case the DailyNutrition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyNutritionUpdateInput, DailyNutritionUncheckedUpdateInput>
  }

  /**
   * DailyNutrition delete
   */
  export type DailyNutritionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
    /**
     * Filter which DailyNutrition to delete.
     */
    where: DailyNutritionWhereUniqueInput
  }

  /**
   * DailyNutrition deleteMany
   */
  export type DailyNutritionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyNutritions to delete
     */
    where?: DailyNutritionWhereInput
    /**
     * Limit how many DailyNutritions to delete.
     */
    limit?: number
  }

  /**
   * DailyNutrition.meals
   */
  export type DailyNutrition$mealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    where?: NutritionMealWhereInput
    orderBy?: NutritionMealOrderByWithRelationInput | NutritionMealOrderByWithRelationInput[]
    cursor?: NutritionMealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutritionMealScalarFieldEnum | NutritionMealScalarFieldEnum[]
  }

  /**
   * DailyNutrition without action
   */
  export type DailyNutritionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyNutrition
     */
    select?: DailyNutritionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyNutrition
     */
    omit?: DailyNutritionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyNutritionInclude<ExtArgs> | null
  }


  /**
   * Model NutritionMeal
   */

  export type AggregateNutritionMeal = {
    _count: NutritionMealCountAggregateOutputType | null
    _avg: NutritionMealAvgAggregateOutputType | null
    _sum: NutritionMealSumAggregateOutputType | null
    _min: NutritionMealMinAggregateOutputType | null
    _max: NutritionMealMaxAggregateOutputType | null
  }

  export type NutritionMealAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    order: number | null
  }

  export type NutritionMealSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    order: number | null
  }

  export type NutritionMealMinAggregateOutputType = {
    id: string | null
    dailyNutritionId: string | null
    name: string | null
    type: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    time: string | null
    completed: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionMealMaxAggregateOutputType = {
    id: string | null
    dailyNutritionId: string | null
    name: string | null
    type: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    time: string | null
    completed: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionMealCountAggregateOutputType = {
    id: number
    dailyNutritionId: number
    name: number
    type: number
    calories: number
    protein: number
    carbs: number
    fats: number
    time: number
    completed: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NutritionMealAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    order?: true
  }

  export type NutritionMealSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    order?: true
  }

  export type NutritionMealMinAggregateInputType = {
    id?: true
    dailyNutritionId?: true
    name?: true
    type?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    time?: true
    completed?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionMealMaxAggregateInputType = {
    id?: true
    dailyNutritionId?: true
    name?: true
    type?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    time?: true
    completed?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionMealCountAggregateInputType = {
    id?: true
    dailyNutritionId?: true
    name?: true
    type?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    time?: true
    completed?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NutritionMealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionMeal to aggregate.
     */
    where?: NutritionMealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionMeals to fetch.
     */
    orderBy?: NutritionMealOrderByWithRelationInput | NutritionMealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionMealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionMeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionMeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionMeals
    **/
    _count?: true | NutritionMealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionMealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionMealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionMealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionMealMaxAggregateInputType
  }

  export type GetNutritionMealAggregateType<T extends NutritionMealAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionMeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionMeal[P]>
      : GetScalarType<T[P], AggregateNutritionMeal[P]>
  }




  export type NutritionMealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionMealWhereInput
    orderBy?: NutritionMealOrderByWithAggregationInput | NutritionMealOrderByWithAggregationInput[]
    by: NutritionMealScalarFieldEnum[] | NutritionMealScalarFieldEnum
    having?: NutritionMealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionMealCountAggregateInputType | true
    _avg?: NutritionMealAvgAggregateInputType
    _sum?: NutritionMealSumAggregateInputType
    _min?: NutritionMealMinAggregateInputType
    _max?: NutritionMealMaxAggregateInputType
  }

  export type NutritionMealGroupByOutputType = {
    id: string
    dailyNutritionId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time: string | null
    completed: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: NutritionMealCountAggregateOutputType | null
    _avg: NutritionMealAvgAggregateOutputType | null
    _sum: NutritionMealSumAggregateOutputType | null
    _min: NutritionMealMinAggregateOutputType | null
    _max: NutritionMealMaxAggregateOutputType | null
  }

  type GetNutritionMealGroupByPayload<T extends NutritionMealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionMealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionMealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionMealGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionMealGroupByOutputType[P]>
        }
      >
    >


  export type NutritionMealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyNutritionId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    completed?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dailyNutrition?: boolean | DailyNutritionDefaultArgs<ExtArgs>
    foods?: boolean | NutritionMeal$foodsArgs<ExtArgs>
    _count?: boolean | NutritionMealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionMeal"]>

  export type NutritionMealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyNutritionId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    completed?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dailyNutrition?: boolean | DailyNutritionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionMeal"]>

  export type NutritionMealSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyNutritionId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    completed?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dailyNutrition?: boolean | DailyNutritionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionMeal"]>

  export type NutritionMealSelectScalar = {
    id?: boolean
    dailyNutritionId?: boolean
    name?: boolean
    type?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    time?: boolean
    completed?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NutritionMealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dailyNutritionId" | "name" | "type" | "calories" | "protein" | "carbs" | "fats" | "time" | "completed" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["nutritionMeal"]>
  export type NutritionMealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyNutrition?: boolean | DailyNutritionDefaultArgs<ExtArgs>
    foods?: boolean | NutritionMeal$foodsArgs<ExtArgs>
    _count?: boolean | NutritionMealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NutritionMealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyNutrition?: boolean | DailyNutritionDefaultArgs<ExtArgs>
  }
  export type NutritionMealIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyNutrition?: boolean | DailyNutritionDefaultArgs<ExtArgs>
  }

  export type $NutritionMealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionMeal"
    objects: {
      dailyNutrition: Prisma.$DailyNutritionPayload<ExtArgs>
      foods: Prisma.$NutritionFoodItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dailyNutritionId: string
      name: string
      type: string
      calories: number
      protein: number
      carbs: number
      fats: number
      time: string | null
      completed: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nutritionMeal"]>
    composites: {}
  }

  type NutritionMealGetPayload<S extends boolean | null | undefined | NutritionMealDefaultArgs> = $Result.GetResult<Prisma.$NutritionMealPayload, S>

  type NutritionMealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutritionMealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionMealCountAggregateInputType | true
    }

  export interface NutritionMealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionMeal'], meta: { name: 'NutritionMeal' } }
    /**
     * Find zero or one NutritionMeal that matches the filter.
     * @param {NutritionMealFindUniqueArgs} args - Arguments to find a NutritionMeal
     * @example
     * // Get one NutritionMeal
     * const nutritionMeal = await prisma.nutritionMeal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionMealFindUniqueArgs>(args: SelectSubset<T, NutritionMealFindUniqueArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionMeal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutritionMealFindUniqueOrThrowArgs} args - Arguments to find a NutritionMeal
     * @example
     * // Get one NutritionMeal
     * const nutritionMeal = await prisma.nutritionMeal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionMealFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionMealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionMeal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealFindFirstArgs} args - Arguments to find a NutritionMeal
     * @example
     * // Get one NutritionMeal
     * const nutritionMeal = await prisma.nutritionMeal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionMealFindFirstArgs>(args?: SelectSubset<T, NutritionMealFindFirstArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionMeal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealFindFirstOrThrowArgs} args - Arguments to find a NutritionMeal
     * @example
     * // Get one NutritionMeal
     * const nutritionMeal = await prisma.nutritionMeal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionMealFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionMealFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionMeals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionMeals
     * const nutritionMeals = await prisma.nutritionMeal.findMany()
     * 
     * // Get first 10 NutritionMeals
     * const nutritionMeals = await prisma.nutritionMeal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionMealWithIdOnly = await prisma.nutritionMeal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionMealFindManyArgs>(args?: SelectSubset<T, NutritionMealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionMeal.
     * @param {NutritionMealCreateArgs} args - Arguments to create a NutritionMeal.
     * @example
     * // Create one NutritionMeal
     * const NutritionMeal = await prisma.nutritionMeal.create({
     *   data: {
     *     // ... data to create a NutritionMeal
     *   }
     * })
     * 
     */
    create<T extends NutritionMealCreateArgs>(args: SelectSubset<T, NutritionMealCreateArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionMeals.
     * @param {NutritionMealCreateManyArgs} args - Arguments to create many NutritionMeals.
     * @example
     * // Create many NutritionMeals
     * const nutritionMeal = await prisma.nutritionMeal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionMealCreateManyArgs>(args?: SelectSubset<T, NutritionMealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionMeals and returns the data saved in the database.
     * @param {NutritionMealCreateManyAndReturnArgs} args - Arguments to create many NutritionMeals.
     * @example
     * // Create many NutritionMeals
     * const nutritionMeal = await prisma.nutritionMeal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionMeals and only return the `id`
     * const nutritionMealWithIdOnly = await prisma.nutritionMeal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionMealCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionMealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionMeal.
     * @param {NutritionMealDeleteArgs} args - Arguments to delete one NutritionMeal.
     * @example
     * // Delete one NutritionMeal
     * const NutritionMeal = await prisma.nutritionMeal.delete({
     *   where: {
     *     // ... filter to delete one NutritionMeal
     *   }
     * })
     * 
     */
    delete<T extends NutritionMealDeleteArgs>(args: SelectSubset<T, NutritionMealDeleteArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionMeal.
     * @param {NutritionMealUpdateArgs} args - Arguments to update one NutritionMeal.
     * @example
     * // Update one NutritionMeal
     * const nutritionMeal = await prisma.nutritionMeal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionMealUpdateArgs>(args: SelectSubset<T, NutritionMealUpdateArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionMeals.
     * @param {NutritionMealDeleteManyArgs} args - Arguments to filter NutritionMeals to delete.
     * @example
     * // Delete a few NutritionMeals
     * const { count } = await prisma.nutritionMeal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionMealDeleteManyArgs>(args?: SelectSubset<T, NutritionMealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionMeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionMeals
     * const nutritionMeal = await prisma.nutritionMeal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionMealUpdateManyArgs>(args: SelectSubset<T, NutritionMealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionMeals and returns the data updated in the database.
     * @param {NutritionMealUpdateManyAndReturnArgs} args - Arguments to update many NutritionMeals.
     * @example
     * // Update many NutritionMeals
     * const nutritionMeal = await prisma.nutritionMeal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionMeals and only return the `id`
     * const nutritionMealWithIdOnly = await prisma.nutritionMeal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutritionMealUpdateManyAndReturnArgs>(args: SelectSubset<T, NutritionMealUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionMeal.
     * @param {NutritionMealUpsertArgs} args - Arguments to update or create a NutritionMeal.
     * @example
     * // Update or create a NutritionMeal
     * const nutritionMeal = await prisma.nutritionMeal.upsert({
     *   create: {
     *     // ... data to create a NutritionMeal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionMeal we want to update
     *   }
     * })
     */
    upsert<T extends NutritionMealUpsertArgs>(args: SelectSubset<T, NutritionMealUpsertArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionMeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealCountArgs} args - Arguments to filter NutritionMeals to count.
     * @example
     * // Count the number of NutritionMeals
     * const count = await prisma.nutritionMeal.count({
     *   where: {
     *     // ... the filter for the NutritionMeals we want to count
     *   }
     * })
    **/
    count<T extends NutritionMealCountArgs>(
      args?: Subset<T, NutritionMealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionMealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionMeal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionMealAggregateArgs>(args: Subset<T, NutritionMealAggregateArgs>): Prisma.PrismaPromise<GetNutritionMealAggregateType<T>>

    /**
     * Group by NutritionMeal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionMealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionMealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionMealGroupByArgs['orderBy'] }
        : { orderBy?: NutritionMealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionMealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionMealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionMeal model
   */
  readonly fields: NutritionMealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionMeal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionMealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailyNutrition<T extends DailyNutritionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyNutritionDefaultArgs<ExtArgs>>): Prisma__DailyNutritionClient<$Result.GetResult<Prisma.$DailyNutritionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    foods<T extends NutritionMeal$foodsArgs<ExtArgs> = {}>(args?: Subset<T, NutritionMeal$foodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionMeal model
   */
  interface NutritionMealFieldRefs {
    readonly id: FieldRef<"NutritionMeal", 'String'>
    readonly dailyNutritionId: FieldRef<"NutritionMeal", 'String'>
    readonly name: FieldRef<"NutritionMeal", 'String'>
    readonly type: FieldRef<"NutritionMeal", 'String'>
    readonly calories: FieldRef<"NutritionMeal", 'Int'>
    readonly protein: FieldRef<"NutritionMeal", 'Float'>
    readonly carbs: FieldRef<"NutritionMeal", 'Float'>
    readonly fats: FieldRef<"NutritionMeal", 'Float'>
    readonly time: FieldRef<"NutritionMeal", 'String'>
    readonly completed: FieldRef<"NutritionMeal", 'Boolean'>
    readonly order: FieldRef<"NutritionMeal", 'Int'>
    readonly createdAt: FieldRef<"NutritionMeal", 'DateTime'>
    readonly updatedAt: FieldRef<"NutritionMeal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NutritionMeal findUnique
   */
  export type NutritionMealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * Filter, which NutritionMeal to fetch.
     */
    where: NutritionMealWhereUniqueInput
  }

  /**
   * NutritionMeal findUniqueOrThrow
   */
  export type NutritionMealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * Filter, which NutritionMeal to fetch.
     */
    where: NutritionMealWhereUniqueInput
  }

  /**
   * NutritionMeal findFirst
   */
  export type NutritionMealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * Filter, which NutritionMeal to fetch.
     */
    where?: NutritionMealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionMeals to fetch.
     */
    orderBy?: NutritionMealOrderByWithRelationInput | NutritionMealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionMeals.
     */
    cursor?: NutritionMealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionMeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionMeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionMeals.
     */
    distinct?: NutritionMealScalarFieldEnum | NutritionMealScalarFieldEnum[]
  }

  /**
   * NutritionMeal findFirstOrThrow
   */
  export type NutritionMealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * Filter, which NutritionMeal to fetch.
     */
    where?: NutritionMealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionMeals to fetch.
     */
    orderBy?: NutritionMealOrderByWithRelationInput | NutritionMealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionMeals.
     */
    cursor?: NutritionMealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionMeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionMeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionMeals.
     */
    distinct?: NutritionMealScalarFieldEnum | NutritionMealScalarFieldEnum[]
  }

  /**
   * NutritionMeal findMany
   */
  export type NutritionMealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * Filter, which NutritionMeals to fetch.
     */
    where?: NutritionMealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionMeals to fetch.
     */
    orderBy?: NutritionMealOrderByWithRelationInput | NutritionMealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionMeals.
     */
    cursor?: NutritionMealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionMeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionMeals.
     */
    skip?: number
    distinct?: NutritionMealScalarFieldEnum | NutritionMealScalarFieldEnum[]
  }

  /**
   * NutritionMeal create
   */
  export type NutritionMealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionMeal.
     */
    data: XOR<NutritionMealCreateInput, NutritionMealUncheckedCreateInput>
  }

  /**
   * NutritionMeal createMany
   */
  export type NutritionMealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionMeals.
     */
    data: NutritionMealCreateManyInput | NutritionMealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionMeal createManyAndReturn
   */
  export type NutritionMealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * The data used to create many NutritionMeals.
     */
    data: NutritionMealCreateManyInput | NutritionMealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionMeal update
   */
  export type NutritionMealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionMeal.
     */
    data: XOR<NutritionMealUpdateInput, NutritionMealUncheckedUpdateInput>
    /**
     * Choose, which NutritionMeal to update.
     */
    where: NutritionMealWhereUniqueInput
  }

  /**
   * NutritionMeal updateMany
   */
  export type NutritionMealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionMeals.
     */
    data: XOR<NutritionMealUpdateManyMutationInput, NutritionMealUncheckedUpdateManyInput>
    /**
     * Filter which NutritionMeals to update
     */
    where?: NutritionMealWhereInput
    /**
     * Limit how many NutritionMeals to update.
     */
    limit?: number
  }

  /**
   * NutritionMeal updateManyAndReturn
   */
  export type NutritionMealUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * The data used to update NutritionMeals.
     */
    data: XOR<NutritionMealUpdateManyMutationInput, NutritionMealUncheckedUpdateManyInput>
    /**
     * Filter which NutritionMeals to update
     */
    where?: NutritionMealWhereInput
    /**
     * Limit how many NutritionMeals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionMeal upsert
   */
  export type NutritionMealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionMeal to update in case it exists.
     */
    where: NutritionMealWhereUniqueInput
    /**
     * In case the NutritionMeal found by the `where` argument doesn't exist, create a new NutritionMeal with this data.
     */
    create: XOR<NutritionMealCreateInput, NutritionMealUncheckedCreateInput>
    /**
     * In case the NutritionMeal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionMealUpdateInput, NutritionMealUncheckedUpdateInput>
  }

  /**
   * NutritionMeal delete
   */
  export type NutritionMealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
    /**
     * Filter which NutritionMeal to delete.
     */
    where: NutritionMealWhereUniqueInput
  }

  /**
   * NutritionMeal deleteMany
   */
  export type NutritionMealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionMeals to delete
     */
    where?: NutritionMealWhereInput
    /**
     * Limit how many NutritionMeals to delete.
     */
    limit?: number
  }

  /**
   * NutritionMeal.foods
   */
  export type NutritionMeal$foodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    where?: NutritionFoodItemWhereInput
    orderBy?: NutritionFoodItemOrderByWithRelationInput | NutritionFoodItemOrderByWithRelationInput[]
    cursor?: NutritionFoodItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutritionFoodItemScalarFieldEnum | NutritionFoodItemScalarFieldEnum[]
  }

  /**
   * NutritionMeal without action
   */
  export type NutritionMealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionMeal
     */
    select?: NutritionMealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionMeal
     */
    omit?: NutritionMealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionMealInclude<ExtArgs> | null
  }


  /**
   * Model NutritionFoodItem
   */

  export type AggregateNutritionFoodItem = {
    _count: NutritionFoodItemCountAggregateOutputType | null
    _avg: NutritionFoodItemAvgAggregateOutputType | null
    _sum: NutritionFoodItemSumAggregateOutputType | null
    _min: NutritionFoodItemMinAggregateOutputType | null
    _max: NutritionFoodItemMaxAggregateOutputType | null
  }

  export type NutritionFoodItemAvgAggregateOutputType = {
    servings: number | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type NutritionFoodItemSumAggregateOutputType = {
    servings: number | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type NutritionFoodItemMinAggregateOutputType = {
    id: string | null
    nutritionMealId: string | null
    foodId: string | null
    foodName: string | null
    servings: number | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    servingSize: string | null
    createdAt: Date | null
  }

  export type NutritionFoodItemMaxAggregateOutputType = {
    id: string | null
    nutritionMealId: string | null
    foodId: string | null
    foodName: string | null
    servings: number | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    servingSize: string | null
    createdAt: Date | null
  }

  export type NutritionFoodItemCountAggregateOutputType = {
    id: number
    nutritionMealId: number
    foodId: number
    foodName: number
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: number
    createdAt: number
    _all: number
  }


  export type NutritionFoodItemAvgAggregateInputType = {
    servings?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type NutritionFoodItemSumAggregateInputType = {
    servings?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type NutritionFoodItemMinAggregateInputType = {
    id?: true
    nutritionMealId?: true
    foodId?: true
    foodName?: true
    servings?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    servingSize?: true
    createdAt?: true
  }

  export type NutritionFoodItemMaxAggregateInputType = {
    id?: true
    nutritionMealId?: true
    foodId?: true
    foodName?: true
    servings?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    servingSize?: true
    createdAt?: true
  }

  export type NutritionFoodItemCountAggregateInputType = {
    id?: true
    nutritionMealId?: true
    foodId?: true
    foodName?: true
    servings?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    servingSize?: true
    createdAt?: true
    _all?: true
  }

  export type NutritionFoodItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionFoodItem to aggregate.
     */
    where?: NutritionFoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFoodItems to fetch.
     */
    orderBy?: NutritionFoodItemOrderByWithRelationInput | NutritionFoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionFoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionFoodItems
    **/
    _count?: true | NutritionFoodItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionFoodItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionFoodItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionFoodItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionFoodItemMaxAggregateInputType
  }

  export type GetNutritionFoodItemAggregateType<T extends NutritionFoodItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionFoodItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionFoodItem[P]>
      : GetScalarType<T[P], AggregateNutritionFoodItem[P]>
  }




  export type NutritionFoodItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionFoodItemWhereInput
    orderBy?: NutritionFoodItemOrderByWithAggregationInput | NutritionFoodItemOrderByWithAggregationInput[]
    by: NutritionFoodItemScalarFieldEnum[] | NutritionFoodItemScalarFieldEnum
    having?: NutritionFoodItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionFoodItemCountAggregateInputType | true
    _avg?: NutritionFoodItemAvgAggregateInputType
    _sum?: NutritionFoodItemSumAggregateInputType
    _min?: NutritionFoodItemMinAggregateInputType
    _max?: NutritionFoodItemMaxAggregateInputType
  }

  export type NutritionFoodItemGroupByOutputType = {
    id: string
    nutritionMealId: string
    foodId: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt: Date
    _count: NutritionFoodItemCountAggregateOutputType | null
    _avg: NutritionFoodItemAvgAggregateOutputType | null
    _sum: NutritionFoodItemSumAggregateOutputType | null
    _min: NutritionFoodItemMinAggregateOutputType | null
    _max: NutritionFoodItemMaxAggregateOutputType | null
  }

  type GetNutritionFoodItemGroupByPayload<T extends NutritionFoodItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionFoodItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionFoodItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionFoodItemGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionFoodItemGroupByOutputType[P]>
        }
      >
    >


  export type NutritionFoodItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nutritionMealId?: boolean
    foodId?: boolean
    foodName?: boolean
    servings?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    createdAt?: boolean
    nutritionMeal?: boolean | NutritionMealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionFoodItem"]>

  export type NutritionFoodItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nutritionMealId?: boolean
    foodId?: boolean
    foodName?: boolean
    servings?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    createdAt?: boolean
    nutritionMeal?: boolean | NutritionMealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionFoodItem"]>

  export type NutritionFoodItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nutritionMealId?: boolean
    foodId?: boolean
    foodName?: boolean
    servings?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    createdAt?: boolean
    nutritionMeal?: boolean | NutritionMealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionFoodItem"]>

  export type NutritionFoodItemSelectScalar = {
    id?: boolean
    nutritionMealId?: boolean
    foodId?: boolean
    foodName?: boolean
    servings?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    createdAt?: boolean
  }

  export type NutritionFoodItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nutritionMealId" | "foodId" | "foodName" | "servings" | "calories" | "protein" | "carbs" | "fats" | "servingSize" | "createdAt", ExtArgs["result"]["nutritionFoodItem"]>
  export type NutritionFoodItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionMeal?: boolean | NutritionMealDefaultArgs<ExtArgs>
  }
  export type NutritionFoodItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionMeal?: boolean | NutritionMealDefaultArgs<ExtArgs>
  }
  export type NutritionFoodItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nutritionMeal?: boolean | NutritionMealDefaultArgs<ExtArgs>
  }

  export type $NutritionFoodItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionFoodItem"
    objects: {
      nutritionMeal: Prisma.$NutritionMealPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nutritionMealId: string
      foodId: string | null
      foodName: string
      servings: number
      calories: number
      protein: number
      carbs: number
      fats: number
      servingSize: string
      createdAt: Date
    }, ExtArgs["result"]["nutritionFoodItem"]>
    composites: {}
  }

  type NutritionFoodItemGetPayload<S extends boolean | null | undefined | NutritionFoodItemDefaultArgs> = $Result.GetResult<Prisma.$NutritionFoodItemPayload, S>

  type NutritionFoodItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutritionFoodItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionFoodItemCountAggregateInputType | true
    }

  export interface NutritionFoodItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionFoodItem'], meta: { name: 'NutritionFoodItem' } }
    /**
     * Find zero or one NutritionFoodItem that matches the filter.
     * @param {NutritionFoodItemFindUniqueArgs} args - Arguments to find a NutritionFoodItem
     * @example
     * // Get one NutritionFoodItem
     * const nutritionFoodItem = await prisma.nutritionFoodItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionFoodItemFindUniqueArgs>(args: SelectSubset<T, NutritionFoodItemFindUniqueArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionFoodItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutritionFoodItemFindUniqueOrThrowArgs} args - Arguments to find a NutritionFoodItem
     * @example
     * // Get one NutritionFoodItem
     * const nutritionFoodItem = await prisma.nutritionFoodItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionFoodItemFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionFoodItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionFoodItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemFindFirstArgs} args - Arguments to find a NutritionFoodItem
     * @example
     * // Get one NutritionFoodItem
     * const nutritionFoodItem = await prisma.nutritionFoodItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionFoodItemFindFirstArgs>(args?: SelectSubset<T, NutritionFoodItemFindFirstArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionFoodItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemFindFirstOrThrowArgs} args - Arguments to find a NutritionFoodItem
     * @example
     * // Get one NutritionFoodItem
     * const nutritionFoodItem = await prisma.nutritionFoodItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionFoodItemFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionFoodItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionFoodItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionFoodItems
     * const nutritionFoodItems = await prisma.nutritionFoodItem.findMany()
     * 
     * // Get first 10 NutritionFoodItems
     * const nutritionFoodItems = await prisma.nutritionFoodItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionFoodItemWithIdOnly = await prisma.nutritionFoodItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionFoodItemFindManyArgs>(args?: SelectSubset<T, NutritionFoodItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionFoodItem.
     * @param {NutritionFoodItemCreateArgs} args - Arguments to create a NutritionFoodItem.
     * @example
     * // Create one NutritionFoodItem
     * const NutritionFoodItem = await prisma.nutritionFoodItem.create({
     *   data: {
     *     // ... data to create a NutritionFoodItem
     *   }
     * })
     * 
     */
    create<T extends NutritionFoodItemCreateArgs>(args: SelectSubset<T, NutritionFoodItemCreateArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionFoodItems.
     * @param {NutritionFoodItemCreateManyArgs} args - Arguments to create many NutritionFoodItems.
     * @example
     * // Create many NutritionFoodItems
     * const nutritionFoodItem = await prisma.nutritionFoodItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionFoodItemCreateManyArgs>(args?: SelectSubset<T, NutritionFoodItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionFoodItems and returns the data saved in the database.
     * @param {NutritionFoodItemCreateManyAndReturnArgs} args - Arguments to create many NutritionFoodItems.
     * @example
     * // Create many NutritionFoodItems
     * const nutritionFoodItem = await prisma.nutritionFoodItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionFoodItems and only return the `id`
     * const nutritionFoodItemWithIdOnly = await prisma.nutritionFoodItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionFoodItemCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionFoodItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionFoodItem.
     * @param {NutritionFoodItemDeleteArgs} args - Arguments to delete one NutritionFoodItem.
     * @example
     * // Delete one NutritionFoodItem
     * const NutritionFoodItem = await prisma.nutritionFoodItem.delete({
     *   where: {
     *     // ... filter to delete one NutritionFoodItem
     *   }
     * })
     * 
     */
    delete<T extends NutritionFoodItemDeleteArgs>(args: SelectSubset<T, NutritionFoodItemDeleteArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionFoodItem.
     * @param {NutritionFoodItemUpdateArgs} args - Arguments to update one NutritionFoodItem.
     * @example
     * // Update one NutritionFoodItem
     * const nutritionFoodItem = await prisma.nutritionFoodItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionFoodItemUpdateArgs>(args: SelectSubset<T, NutritionFoodItemUpdateArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionFoodItems.
     * @param {NutritionFoodItemDeleteManyArgs} args - Arguments to filter NutritionFoodItems to delete.
     * @example
     * // Delete a few NutritionFoodItems
     * const { count } = await prisma.nutritionFoodItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionFoodItemDeleteManyArgs>(args?: SelectSubset<T, NutritionFoodItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionFoodItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionFoodItems
     * const nutritionFoodItem = await prisma.nutritionFoodItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionFoodItemUpdateManyArgs>(args: SelectSubset<T, NutritionFoodItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionFoodItems and returns the data updated in the database.
     * @param {NutritionFoodItemUpdateManyAndReturnArgs} args - Arguments to update many NutritionFoodItems.
     * @example
     * // Update many NutritionFoodItems
     * const nutritionFoodItem = await prisma.nutritionFoodItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionFoodItems and only return the `id`
     * const nutritionFoodItemWithIdOnly = await prisma.nutritionFoodItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutritionFoodItemUpdateManyAndReturnArgs>(args: SelectSubset<T, NutritionFoodItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionFoodItem.
     * @param {NutritionFoodItemUpsertArgs} args - Arguments to update or create a NutritionFoodItem.
     * @example
     * // Update or create a NutritionFoodItem
     * const nutritionFoodItem = await prisma.nutritionFoodItem.upsert({
     *   create: {
     *     // ... data to create a NutritionFoodItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionFoodItem we want to update
     *   }
     * })
     */
    upsert<T extends NutritionFoodItemUpsertArgs>(args: SelectSubset<T, NutritionFoodItemUpsertArgs<ExtArgs>>): Prisma__NutritionFoodItemClient<$Result.GetResult<Prisma.$NutritionFoodItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionFoodItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemCountArgs} args - Arguments to filter NutritionFoodItems to count.
     * @example
     * // Count the number of NutritionFoodItems
     * const count = await prisma.nutritionFoodItem.count({
     *   where: {
     *     // ... the filter for the NutritionFoodItems we want to count
     *   }
     * })
    **/
    count<T extends NutritionFoodItemCountArgs>(
      args?: Subset<T, NutritionFoodItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionFoodItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionFoodItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionFoodItemAggregateArgs>(args: Subset<T, NutritionFoodItemAggregateArgs>): Prisma.PrismaPromise<GetNutritionFoodItemAggregateType<T>>

    /**
     * Group by NutritionFoodItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFoodItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionFoodItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionFoodItemGroupByArgs['orderBy'] }
        : { orderBy?: NutritionFoodItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionFoodItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionFoodItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionFoodItem model
   */
  readonly fields: NutritionFoodItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionFoodItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionFoodItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nutritionMeal<T extends NutritionMealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NutritionMealDefaultArgs<ExtArgs>>): Prisma__NutritionMealClient<$Result.GetResult<Prisma.$NutritionMealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionFoodItem model
   */
  interface NutritionFoodItemFieldRefs {
    readonly id: FieldRef<"NutritionFoodItem", 'String'>
    readonly nutritionMealId: FieldRef<"NutritionFoodItem", 'String'>
    readonly foodId: FieldRef<"NutritionFoodItem", 'String'>
    readonly foodName: FieldRef<"NutritionFoodItem", 'String'>
    readonly servings: FieldRef<"NutritionFoodItem", 'Float'>
    readonly calories: FieldRef<"NutritionFoodItem", 'Int'>
    readonly protein: FieldRef<"NutritionFoodItem", 'Float'>
    readonly carbs: FieldRef<"NutritionFoodItem", 'Float'>
    readonly fats: FieldRef<"NutritionFoodItem", 'Float'>
    readonly servingSize: FieldRef<"NutritionFoodItem", 'String'>
    readonly createdAt: FieldRef<"NutritionFoodItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NutritionFoodItem findUnique
   */
  export type NutritionFoodItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * Filter, which NutritionFoodItem to fetch.
     */
    where: NutritionFoodItemWhereUniqueInput
  }

  /**
   * NutritionFoodItem findUniqueOrThrow
   */
  export type NutritionFoodItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * Filter, which NutritionFoodItem to fetch.
     */
    where: NutritionFoodItemWhereUniqueInput
  }

  /**
   * NutritionFoodItem findFirst
   */
  export type NutritionFoodItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * Filter, which NutritionFoodItem to fetch.
     */
    where?: NutritionFoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFoodItems to fetch.
     */
    orderBy?: NutritionFoodItemOrderByWithRelationInput | NutritionFoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionFoodItems.
     */
    cursor?: NutritionFoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionFoodItems.
     */
    distinct?: NutritionFoodItemScalarFieldEnum | NutritionFoodItemScalarFieldEnum[]
  }

  /**
   * NutritionFoodItem findFirstOrThrow
   */
  export type NutritionFoodItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * Filter, which NutritionFoodItem to fetch.
     */
    where?: NutritionFoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFoodItems to fetch.
     */
    orderBy?: NutritionFoodItemOrderByWithRelationInput | NutritionFoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionFoodItems.
     */
    cursor?: NutritionFoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionFoodItems.
     */
    distinct?: NutritionFoodItemScalarFieldEnum | NutritionFoodItemScalarFieldEnum[]
  }

  /**
   * NutritionFoodItem findMany
   */
  export type NutritionFoodItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * Filter, which NutritionFoodItems to fetch.
     */
    where?: NutritionFoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFoodItems to fetch.
     */
    orderBy?: NutritionFoodItemOrderByWithRelationInput | NutritionFoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionFoodItems.
     */
    cursor?: NutritionFoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFoodItems.
     */
    skip?: number
    distinct?: NutritionFoodItemScalarFieldEnum | NutritionFoodItemScalarFieldEnum[]
  }

  /**
   * NutritionFoodItem create
   */
  export type NutritionFoodItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionFoodItem.
     */
    data: XOR<NutritionFoodItemCreateInput, NutritionFoodItemUncheckedCreateInput>
  }

  /**
   * NutritionFoodItem createMany
   */
  export type NutritionFoodItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionFoodItems.
     */
    data: NutritionFoodItemCreateManyInput | NutritionFoodItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionFoodItem createManyAndReturn
   */
  export type NutritionFoodItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * The data used to create many NutritionFoodItems.
     */
    data: NutritionFoodItemCreateManyInput | NutritionFoodItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionFoodItem update
   */
  export type NutritionFoodItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionFoodItem.
     */
    data: XOR<NutritionFoodItemUpdateInput, NutritionFoodItemUncheckedUpdateInput>
    /**
     * Choose, which NutritionFoodItem to update.
     */
    where: NutritionFoodItemWhereUniqueInput
  }

  /**
   * NutritionFoodItem updateMany
   */
  export type NutritionFoodItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionFoodItems.
     */
    data: XOR<NutritionFoodItemUpdateManyMutationInput, NutritionFoodItemUncheckedUpdateManyInput>
    /**
     * Filter which NutritionFoodItems to update
     */
    where?: NutritionFoodItemWhereInput
    /**
     * Limit how many NutritionFoodItems to update.
     */
    limit?: number
  }

  /**
   * NutritionFoodItem updateManyAndReturn
   */
  export type NutritionFoodItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * The data used to update NutritionFoodItems.
     */
    data: XOR<NutritionFoodItemUpdateManyMutationInput, NutritionFoodItemUncheckedUpdateManyInput>
    /**
     * Filter which NutritionFoodItems to update
     */
    where?: NutritionFoodItemWhereInput
    /**
     * Limit how many NutritionFoodItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionFoodItem upsert
   */
  export type NutritionFoodItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionFoodItem to update in case it exists.
     */
    where: NutritionFoodItemWhereUniqueInput
    /**
     * In case the NutritionFoodItem found by the `where` argument doesn't exist, create a new NutritionFoodItem with this data.
     */
    create: XOR<NutritionFoodItemCreateInput, NutritionFoodItemUncheckedCreateInput>
    /**
     * In case the NutritionFoodItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionFoodItemUpdateInput, NutritionFoodItemUncheckedUpdateInput>
  }

  /**
   * NutritionFoodItem delete
   */
  export type NutritionFoodItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
    /**
     * Filter which NutritionFoodItem to delete.
     */
    where: NutritionFoodItemWhereUniqueInput
  }

  /**
   * NutritionFoodItem deleteMany
   */
  export type NutritionFoodItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionFoodItems to delete
     */
    where?: NutritionFoodItemWhereInput
    /**
     * Limit how many NutritionFoodItems to delete.
     */
    limit?: number
  }

  /**
   * NutritionFoodItem without action
   */
  export type NutritionFoodItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionFoodItem
     */
    select?: NutritionFoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionFoodItem
     */
    omit?: NutritionFoodItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionFoodItemInclude<ExtArgs> | null
  }


  /**
   * Model NutritionChatUsage
   */

  export type AggregateNutritionChatUsage = {
    _count: NutritionChatUsageCountAggregateOutputType | null
    _avg: NutritionChatUsageAvgAggregateOutputType | null
    _sum: NutritionChatUsageSumAggregateOutputType | null
    _min: NutritionChatUsageMinAggregateOutputType | null
    _max: NutritionChatUsageMaxAggregateOutputType | null
  }

  export type NutritionChatUsageAvgAggregateOutputType = {
    messageCount: number | null
  }

  export type NutritionChatUsageSumAggregateOutputType = {
    messageCount: number | null
  }

  export type NutritionChatUsageMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    messageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionChatUsageMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    messageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionChatUsageCountAggregateOutputType = {
    id: number
    studentId: number
    date: number
    messageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NutritionChatUsageAvgAggregateInputType = {
    messageCount?: true
  }

  export type NutritionChatUsageSumAggregateInputType = {
    messageCount?: true
  }

  export type NutritionChatUsageMinAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    messageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionChatUsageMaxAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    messageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionChatUsageCountAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    messageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NutritionChatUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionChatUsage to aggregate.
     */
    where?: NutritionChatUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionChatUsages to fetch.
     */
    orderBy?: NutritionChatUsageOrderByWithRelationInput | NutritionChatUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionChatUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionChatUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionChatUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionChatUsages
    **/
    _count?: true | NutritionChatUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionChatUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionChatUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionChatUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionChatUsageMaxAggregateInputType
  }

  export type GetNutritionChatUsageAggregateType<T extends NutritionChatUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionChatUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionChatUsage[P]>
      : GetScalarType<T[P], AggregateNutritionChatUsage[P]>
  }




  export type NutritionChatUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionChatUsageWhereInput
    orderBy?: NutritionChatUsageOrderByWithAggregationInput | NutritionChatUsageOrderByWithAggregationInput[]
    by: NutritionChatUsageScalarFieldEnum[] | NutritionChatUsageScalarFieldEnum
    having?: NutritionChatUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionChatUsageCountAggregateInputType | true
    _avg?: NutritionChatUsageAvgAggregateInputType
    _sum?: NutritionChatUsageSumAggregateInputType
    _min?: NutritionChatUsageMinAggregateInputType
    _max?: NutritionChatUsageMaxAggregateInputType
  }

  export type NutritionChatUsageGroupByOutputType = {
    id: string
    studentId: string
    date: Date
    messageCount: number
    createdAt: Date
    updatedAt: Date
    _count: NutritionChatUsageCountAggregateOutputType | null
    _avg: NutritionChatUsageAvgAggregateOutputType | null
    _sum: NutritionChatUsageSumAggregateOutputType | null
    _min: NutritionChatUsageMinAggregateOutputType | null
    _max: NutritionChatUsageMaxAggregateOutputType | null
  }

  type GetNutritionChatUsageGroupByPayload<T extends NutritionChatUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionChatUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionChatUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionChatUsageGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionChatUsageGroupByOutputType[P]>
        }
      >
    >


  export type NutritionChatUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionChatUsage"]>

  export type NutritionChatUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionChatUsage"]>

  export type NutritionChatUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionChatUsage"]>

  export type NutritionChatUsageSelectScalar = {
    id?: boolean
    studentId?: boolean
    date?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NutritionChatUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "date" | "messageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["nutritionChatUsage"]>
  export type NutritionChatUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type NutritionChatUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type NutritionChatUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $NutritionChatUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionChatUsage"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      date: Date
      messageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nutritionChatUsage"]>
    composites: {}
  }

  type NutritionChatUsageGetPayload<S extends boolean | null | undefined | NutritionChatUsageDefaultArgs> = $Result.GetResult<Prisma.$NutritionChatUsagePayload, S>

  type NutritionChatUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutritionChatUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionChatUsageCountAggregateInputType | true
    }

  export interface NutritionChatUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionChatUsage'], meta: { name: 'NutritionChatUsage' } }
    /**
     * Find zero or one NutritionChatUsage that matches the filter.
     * @param {NutritionChatUsageFindUniqueArgs} args - Arguments to find a NutritionChatUsage
     * @example
     * // Get one NutritionChatUsage
     * const nutritionChatUsage = await prisma.nutritionChatUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionChatUsageFindUniqueArgs>(args: SelectSubset<T, NutritionChatUsageFindUniqueArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionChatUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutritionChatUsageFindUniqueOrThrowArgs} args - Arguments to find a NutritionChatUsage
     * @example
     * // Get one NutritionChatUsage
     * const nutritionChatUsage = await prisma.nutritionChatUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionChatUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionChatUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionChatUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageFindFirstArgs} args - Arguments to find a NutritionChatUsage
     * @example
     * // Get one NutritionChatUsage
     * const nutritionChatUsage = await prisma.nutritionChatUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionChatUsageFindFirstArgs>(args?: SelectSubset<T, NutritionChatUsageFindFirstArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionChatUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageFindFirstOrThrowArgs} args - Arguments to find a NutritionChatUsage
     * @example
     * // Get one NutritionChatUsage
     * const nutritionChatUsage = await prisma.nutritionChatUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionChatUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionChatUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionChatUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionChatUsages
     * const nutritionChatUsages = await prisma.nutritionChatUsage.findMany()
     * 
     * // Get first 10 NutritionChatUsages
     * const nutritionChatUsages = await prisma.nutritionChatUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionChatUsageWithIdOnly = await prisma.nutritionChatUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionChatUsageFindManyArgs>(args?: SelectSubset<T, NutritionChatUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionChatUsage.
     * @param {NutritionChatUsageCreateArgs} args - Arguments to create a NutritionChatUsage.
     * @example
     * // Create one NutritionChatUsage
     * const NutritionChatUsage = await prisma.nutritionChatUsage.create({
     *   data: {
     *     // ... data to create a NutritionChatUsage
     *   }
     * })
     * 
     */
    create<T extends NutritionChatUsageCreateArgs>(args: SelectSubset<T, NutritionChatUsageCreateArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionChatUsages.
     * @param {NutritionChatUsageCreateManyArgs} args - Arguments to create many NutritionChatUsages.
     * @example
     * // Create many NutritionChatUsages
     * const nutritionChatUsage = await prisma.nutritionChatUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionChatUsageCreateManyArgs>(args?: SelectSubset<T, NutritionChatUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionChatUsages and returns the data saved in the database.
     * @param {NutritionChatUsageCreateManyAndReturnArgs} args - Arguments to create many NutritionChatUsages.
     * @example
     * // Create many NutritionChatUsages
     * const nutritionChatUsage = await prisma.nutritionChatUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionChatUsages and only return the `id`
     * const nutritionChatUsageWithIdOnly = await prisma.nutritionChatUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionChatUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionChatUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionChatUsage.
     * @param {NutritionChatUsageDeleteArgs} args - Arguments to delete one NutritionChatUsage.
     * @example
     * // Delete one NutritionChatUsage
     * const NutritionChatUsage = await prisma.nutritionChatUsage.delete({
     *   where: {
     *     // ... filter to delete one NutritionChatUsage
     *   }
     * })
     * 
     */
    delete<T extends NutritionChatUsageDeleteArgs>(args: SelectSubset<T, NutritionChatUsageDeleteArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionChatUsage.
     * @param {NutritionChatUsageUpdateArgs} args - Arguments to update one NutritionChatUsage.
     * @example
     * // Update one NutritionChatUsage
     * const nutritionChatUsage = await prisma.nutritionChatUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionChatUsageUpdateArgs>(args: SelectSubset<T, NutritionChatUsageUpdateArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionChatUsages.
     * @param {NutritionChatUsageDeleteManyArgs} args - Arguments to filter NutritionChatUsages to delete.
     * @example
     * // Delete a few NutritionChatUsages
     * const { count } = await prisma.nutritionChatUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionChatUsageDeleteManyArgs>(args?: SelectSubset<T, NutritionChatUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionChatUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionChatUsages
     * const nutritionChatUsage = await prisma.nutritionChatUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionChatUsageUpdateManyArgs>(args: SelectSubset<T, NutritionChatUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionChatUsages and returns the data updated in the database.
     * @param {NutritionChatUsageUpdateManyAndReturnArgs} args - Arguments to update many NutritionChatUsages.
     * @example
     * // Update many NutritionChatUsages
     * const nutritionChatUsage = await prisma.nutritionChatUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionChatUsages and only return the `id`
     * const nutritionChatUsageWithIdOnly = await prisma.nutritionChatUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutritionChatUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, NutritionChatUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionChatUsage.
     * @param {NutritionChatUsageUpsertArgs} args - Arguments to update or create a NutritionChatUsage.
     * @example
     * // Update or create a NutritionChatUsage
     * const nutritionChatUsage = await prisma.nutritionChatUsage.upsert({
     *   create: {
     *     // ... data to create a NutritionChatUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionChatUsage we want to update
     *   }
     * })
     */
    upsert<T extends NutritionChatUsageUpsertArgs>(args: SelectSubset<T, NutritionChatUsageUpsertArgs<ExtArgs>>): Prisma__NutritionChatUsageClient<$Result.GetResult<Prisma.$NutritionChatUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionChatUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageCountArgs} args - Arguments to filter NutritionChatUsages to count.
     * @example
     * // Count the number of NutritionChatUsages
     * const count = await prisma.nutritionChatUsage.count({
     *   where: {
     *     // ... the filter for the NutritionChatUsages we want to count
     *   }
     * })
    **/
    count<T extends NutritionChatUsageCountArgs>(
      args?: Subset<T, NutritionChatUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionChatUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionChatUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionChatUsageAggregateArgs>(args: Subset<T, NutritionChatUsageAggregateArgs>): Prisma.PrismaPromise<GetNutritionChatUsageAggregateType<T>>

    /**
     * Group by NutritionChatUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionChatUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionChatUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionChatUsageGroupByArgs['orderBy'] }
        : { orderBy?: NutritionChatUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionChatUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionChatUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionChatUsage model
   */
  readonly fields: NutritionChatUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionChatUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionChatUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionChatUsage model
   */
  interface NutritionChatUsageFieldRefs {
    readonly id: FieldRef<"NutritionChatUsage", 'String'>
    readonly studentId: FieldRef<"NutritionChatUsage", 'String'>
    readonly date: FieldRef<"NutritionChatUsage", 'DateTime'>
    readonly messageCount: FieldRef<"NutritionChatUsage", 'Int'>
    readonly createdAt: FieldRef<"NutritionChatUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"NutritionChatUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NutritionChatUsage findUnique
   */
  export type NutritionChatUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * Filter, which NutritionChatUsage to fetch.
     */
    where: NutritionChatUsageWhereUniqueInput
  }

  /**
   * NutritionChatUsage findUniqueOrThrow
   */
  export type NutritionChatUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * Filter, which NutritionChatUsage to fetch.
     */
    where: NutritionChatUsageWhereUniqueInput
  }

  /**
   * NutritionChatUsage findFirst
   */
  export type NutritionChatUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * Filter, which NutritionChatUsage to fetch.
     */
    where?: NutritionChatUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionChatUsages to fetch.
     */
    orderBy?: NutritionChatUsageOrderByWithRelationInput | NutritionChatUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionChatUsages.
     */
    cursor?: NutritionChatUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionChatUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionChatUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionChatUsages.
     */
    distinct?: NutritionChatUsageScalarFieldEnum | NutritionChatUsageScalarFieldEnum[]
  }

  /**
   * NutritionChatUsage findFirstOrThrow
   */
  export type NutritionChatUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * Filter, which NutritionChatUsage to fetch.
     */
    where?: NutritionChatUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionChatUsages to fetch.
     */
    orderBy?: NutritionChatUsageOrderByWithRelationInput | NutritionChatUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionChatUsages.
     */
    cursor?: NutritionChatUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionChatUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionChatUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionChatUsages.
     */
    distinct?: NutritionChatUsageScalarFieldEnum | NutritionChatUsageScalarFieldEnum[]
  }

  /**
   * NutritionChatUsage findMany
   */
  export type NutritionChatUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * Filter, which NutritionChatUsages to fetch.
     */
    where?: NutritionChatUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionChatUsages to fetch.
     */
    orderBy?: NutritionChatUsageOrderByWithRelationInput | NutritionChatUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionChatUsages.
     */
    cursor?: NutritionChatUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionChatUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionChatUsages.
     */
    skip?: number
    distinct?: NutritionChatUsageScalarFieldEnum | NutritionChatUsageScalarFieldEnum[]
  }

  /**
   * NutritionChatUsage create
   */
  export type NutritionChatUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionChatUsage.
     */
    data: XOR<NutritionChatUsageCreateInput, NutritionChatUsageUncheckedCreateInput>
  }

  /**
   * NutritionChatUsage createMany
   */
  export type NutritionChatUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionChatUsages.
     */
    data: NutritionChatUsageCreateManyInput | NutritionChatUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionChatUsage createManyAndReturn
   */
  export type NutritionChatUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * The data used to create many NutritionChatUsages.
     */
    data: NutritionChatUsageCreateManyInput | NutritionChatUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionChatUsage update
   */
  export type NutritionChatUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionChatUsage.
     */
    data: XOR<NutritionChatUsageUpdateInput, NutritionChatUsageUncheckedUpdateInput>
    /**
     * Choose, which NutritionChatUsage to update.
     */
    where: NutritionChatUsageWhereUniqueInput
  }

  /**
   * NutritionChatUsage updateMany
   */
  export type NutritionChatUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionChatUsages.
     */
    data: XOR<NutritionChatUsageUpdateManyMutationInput, NutritionChatUsageUncheckedUpdateManyInput>
    /**
     * Filter which NutritionChatUsages to update
     */
    where?: NutritionChatUsageWhereInput
    /**
     * Limit how many NutritionChatUsages to update.
     */
    limit?: number
  }

  /**
   * NutritionChatUsage updateManyAndReturn
   */
  export type NutritionChatUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * The data used to update NutritionChatUsages.
     */
    data: XOR<NutritionChatUsageUpdateManyMutationInput, NutritionChatUsageUncheckedUpdateManyInput>
    /**
     * Filter which NutritionChatUsages to update
     */
    where?: NutritionChatUsageWhereInput
    /**
     * Limit how many NutritionChatUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionChatUsage upsert
   */
  export type NutritionChatUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionChatUsage to update in case it exists.
     */
    where: NutritionChatUsageWhereUniqueInput
    /**
     * In case the NutritionChatUsage found by the `where` argument doesn't exist, create a new NutritionChatUsage with this data.
     */
    create: XOR<NutritionChatUsageCreateInput, NutritionChatUsageUncheckedCreateInput>
    /**
     * In case the NutritionChatUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionChatUsageUpdateInput, NutritionChatUsageUncheckedUpdateInput>
  }

  /**
   * NutritionChatUsage delete
   */
  export type NutritionChatUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
    /**
     * Filter which NutritionChatUsage to delete.
     */
    where: NutritionChatUsageWhereUniqueInput
  }

  /**
   * NutritionChatUsage deleteMany
   */
  export type NutritionChatUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionChatUsages to delete
     */
    where?: NutritionChatUsageWhereInput
    /**
     * Limit how many NutritionChatUsages to delete.
     */
    limit?: number
  }

  /**
   * NutritionChatUsage without action
   */
  export type NutritionChatUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionChatUsage
     */
    select?: NutritionChatUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionChatUsage
     */
    omit?: NutritionChatUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionChatUsageInclude<ExtArgs> | null
  }


  /**
   * Model FoodItem
   */

  export type AggregateFoodItem = {
    _count: FoodItemCountAggregateOutputType | null
    _avg: FoodItemAvgAggregateOutputType | null
    _sum: FoodItemSumAggregateOutputType | null
    _min: FoodItemMinAggregateOutputType | null
    _max: FoodItemMaxAggregateOutputType | null
  }

  export type FoodItemAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type FoodItemSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type FoodItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    servingSize: string | null
    category: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    servingSize: string | null
    category: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodItemCountAggregateOutputType = {
    id: number
    name: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: number
    category: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodItemAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type FoodItemSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type FoodItemMinAggregateInputType = {
    id?: true
    name?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    servingSize?: true
    category?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodItemMaxAggregateInputType = {
    id?: true
    name?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    servingSize?: true
    category?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodItemCountAggregateInputType = {
    id?: true
    name?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    servingSize?: true
    category?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodItem to aggregate.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodItems
    **/
    _count?: true | FoodItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodItemMaxAggregateInputType
  }

  export type GetFoodItemAggregateType<T extends FoodItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodItem[P]>
      : GetScalarType<T[P], AggregateFoodItem[P]>
  }




  export type FoodItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodItemWhereInput
    orderBy?: FoodItemOrderByWithAggregationInput | FoodItemOrderByWithAggregationInput[]
    by: FoodItemScalarFieldEnum[] | FoodItemScalarFieldEnum
    having?: FoodItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodItemCountAggregateInputType | true
    _avg?: FoodItemAvgAggregateInputType
    _sum?: FoodItemSumAggregateInputType
    _min?: FoodItemMinAggregateInputType
    _max?: FoodItemMaxAggregateInputType
  }

  export type FoodItemGroupByOutputType = {
    id: string
    name: string
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    category: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodItemCountAggregateOutputType | null
    _avg: FoodItemAvgAggregateOutputType | null
    _sum: FoodItemSumAggregateOutputType | null
    _min: FoodItemMinAggregateOutputType | null
    _max: FoodItemMaxAggregateOutputType | null
  }

  type GetFoodItemGroupByPayload<T extends FoodItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodItemGroupByOutputType[P]>
            : GetScalarType<T[P], FoodItemGroupByOutputType[P]>
        }
      >
    >


  export type FoodItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    category?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodItem"]>

  export type FoodItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    category?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodItem"]>

  export type FoodItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    category?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodItem"]>

  export type FoodItemSelectScalar = {
    id?: boolean
    name?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    servingSize?: boolean
    category?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "calories" | "protein" | "carbs" | "fats" | "servingSize" | "category" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["foodItem"]>

  export type $FoodItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      calories: number
      protein: number
      carbs: number
      fats: number
      servingSize: string
      category: string
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodItem"]>
    composites: {}
  }

  type FoodItemGetPayload<S extends boolean | null | undefined | FoodItemDefaultArgs> = $Result.GetResult<Prisma.$FoodItemPayload, S>

  type FoodItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodItemCountAggregateInputType | true
    }

  export interface FoodItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodItem'], meta: { name: 'FoodItem' } }
    /**
     * Find zero or one FoodItem that matches the filter.
     * @param {FoodItemFindUniqueArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodItemFindUniqueArgs>(args: SelectSubset<T, FoodItemFindUniqueArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodItemFindUniqueOrThrowArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemFindFirstArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodItemFindFirstArgs>(args?: SelectSubset<T, FoodItemFindFirstArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemFindFirstOrThrowArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodItems
     * const foodItems = await prisma.foodItem.findMany()
     * 
     * // Get first 10 FoodItems
     * const foodItems = await prisma.foodItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodItemWithIdOnly = await prisma.foodItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodItemFindManyArgs>(args?: SelectSubset<T, FoodItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodItem.
     * @param {FoodItemCreateArgs} args - Arguments to create a FoodItem.
     * @example
     * // Create one FoodItem
     * const FoodItem = await prisma.foodItem.create({
     *   data: {
     *     // ... data to create a FoodItem
     *   }
     * })
     * 
     */
    create<T extends FoodItemCreateArgs>(args: SelectSubset<T, FoodItemCreateArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodItems.
     * @param {FoodItemCreateManyArgs} args - Arguments to create many FoodItems.
     * @example
     * // Create many FoodItems
     * const foodItem = await prisma.foodItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodItemCreateManyArgs>(args?: SelectSubset<T, FoodItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodItems and returns the data saved in the database.
     * @param {FoodItemCreateManyAndReturnArgs} args - Arguments to create many FoodItems.
     * @example
     * // Create many FoodItems
     * const foodItem = await prisma.foodItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodItems and only return the `id`
     * const foodItemWithIdOnly = await prisma.foodItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodItem.
     * @param {FoodItemDeleteArgs} args - Arguments to delete one FoodItem.
     * @example
     * // Delete one FoodItem
     * const FoodItem = await prisma.foodItem.delete({
     *   where: {
     *     // ... filter to delete one FoodItem
     *   }
     * })
     * 
     */
    delete<T extends FoodItemDeleteArgs>(args: SelectSubset<T, FoodItemDeleteArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodItem.
     * @param {FoodItemUpdateArgs} args - Arguments to update one FoodItem.
     * @example
     * // Update one FoodItem
     * const foodItem = await prisma.foodItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodItemUpdateArgs>(args: SelectSubset<T, FoodItemUpdateArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodItems.
     * @param {FoodItemDeleteManyArgs} args - Arguments to filter FoodItems to delete.
     * @example
     * // Delete a few FoodItems
     * const { count } = await prisma.foodItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodItemDeleteManyArgs>(args?: SelectSubset<T, FoodItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodItems
     * const foodItem = await prisma.foodItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodItemUpdateManyArgs>(args: SelectSubset<T, FoodItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodItems and returns the data updated in the database.
     * @param {FoodItemUpdateManyAndReturnArgs} args - Arguments to update many FoodItems.
     * @example
     * // Update many FoodItems
     * const foodItem = await prisma.foodItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodItems and only return the `id`
     * const foodItemWithIdOnly = await prisma.foodItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodItemUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodItem.
     * @param {FoodItemUpsertArgs} args - Arguments to update or create a FoodItem.
     * @example
     * // Update or create a FoodItem
     * const foodItem = await prisma.foodItem.upsert({
     *   create: {
     *     // ... data to create a FoodItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodItem we want to update
     *   }
     * })
     */
    upsert<T extends FoodItemUpsertArgs>(args: SelectSubset<T, FoodItemUpsertArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemCountArgs} args - Arguments to filter FoodItems to count.
     * @example
     * // Count the number of FoodItems
     * const count = await prisma.foodItem.count({
     *   where: {
     *     // ... the filter for the FoodItems we want to count
     *   }
     * })
    **/
    count<T extends FoodItemCountArgs>(
      args?: Subset<T, FoodItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodItemAggregateArgs>(args: Subset<T, FoodItemAggregateArgs>): Prisma.PrismaPromise<GetFoodItemAggregateType<T>>

    /**
     * Group by FoodItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodItemGroupByArgs['orderBy'] }
        : { orderBy?: FoodItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodItem model
   */
  readonly fields: FoodItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodItem model
   */
  interface FoodItemFieldRefs {
    readonly id: FieldRef<"FoodItem", 'String'>
    readonly name: FieldRef<"FoodItem", 'String'>
    readonly calories: FieldRef<"FoodItem", 'Int'>
    readonly protein: FieldRef<"FoodItem", 'Float'>
    readonly carbs: FieldRef<"FoodItem", 'Float'>
    readonly fats: FieldRef<"FoodItem", 'Float'>
    readonly servingSize: FieldRef<"FoodItem", 'String'>
    readonly category: FieldRef<"FoodItem", 'String'>
    readonly image: FieldRef<"FoodItem", 'String'>
    readonly createdAt: FieldRef<"FoodItem", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodItem findUnique
   */
  export type FoodItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem findUniqueOrThrow
   */
  export type FoodItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem findFirst
   */
  export type FoodItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodItems.
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodItems.
     */
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodItem findFirstOrThrow
   */
  export type FoodItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodItems.
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodItems.
     */
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodItem findMany
   */
  export type FoodItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * Filter, which FoodItems to fetch.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodItems.
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodItem create
   */
  export type FoodItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * The data needed to create a FoodItem.
     */
    data: XOR<FoodItemCreateInput, FoodItemUncheckedCreateInput>
  }

  /**
   * FoodItem createMany
   */
  export type FoodItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodItems.
     */
    data: FoodItemCreateManyInput | FoodItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodItem createManyAndReturn
   */
  export type FoodItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * The data used to create many FoodItems.
     */
    data: FoodItemCreateManyInput | FoodItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodItem update
   */
  export type FoodItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * The data needed to update a FoodItem.
     */
    data: XOR<FoodItemUpdateInput, FoodItemUncheckedUpdateInput>
    /**
     * Choose, which FoodItem to update.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem updateMany
   */
  export type FoodItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodItems.
     */
    data: XOR<FoodItemUpdateManyMutationInput, FoodItemUncheckedUpdateManyInput>
    /**
     * Filter which FoodItems to update
     */
    where?: FoodItemWhereInput
    /**
     * Limit how many FoodItems to update.
     */
    limit?: number
  }

  /**
   * FoodItem updateManyAndReturn
   */
  export type FoodItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * The data used to update FoodItems.
     */
    data: XOR<FoodItemUpdateManyMutationInput, FoodItemUncheckedUpdateManyInput>
    /**
     * Filter which FoodItems to update
     */
    where?: FoodItemWhereInput
    /**
     * Limit how many FoodItems to update.
     */
    limit?: number
  }

  /**
   * FoodItem upsert
   */
  export type FoodItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * The filter to search for the FoodItem to update in case it exists.
     */
    where: FoodItemWhereUniqueInput
    /**
     * In case the FoodItem found by the `where` argument doesn't exist, create a new FoodItem with this data.
     */
    create: XOR<FoodItemCreateInput, FoodItemUncheckedCreateInput>
    /**
     * In case the FoodItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodItemUpdateInput, FoodItemUncheckedUpdateInput>
  }

  /**
   * FoodItem delete
   */
  export type FoodItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
    /**
     * Filter which FoodItem to delete.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem deleteMany
   */
  export type FoodItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodItems to delete
     */
    where?: FoodItemWhereInput
    /**
     * Limit how many FoodItems to delete.
     */
    limit?: number
  }

  /**
   * FoodItem without action
   */
  export type FoodItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodItem
     */
    omit?: FoodItemOmit<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    level: number | null
    target: number | null
    xpReward: number | null
  }

  export type AchievementSumAggregateOutputType = {
    level: number | null
    target: number | null
    xpReward: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: string | null
    level: number | null
    color: string | null
    target: number | null
    xpReward: number | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: string | null
    level: number | null
    color: string | null
    target: number | null
    xpReward: number | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    category: number
    level: number
    color: number
    target: number
    xpReward: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    level?: true
    target?: true
    xpReward?: true
  }

  export type AchievementSumAggregateInputType = {
    level?: true
    target?: true
    xpReward?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    level?: true
    color?: true
    target?: true
    xpReward?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    level?: true
    color?: true
    target?: true
    xpReward?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    level?: true
    color?: true
    target?: true
    xpReward?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    title: string
    description: string | null
    icon: string | null
    category: string
    level: number | null
    color: string | null
    target: number | null
    xpReward: number
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    level?: boolean
    color?: boolean
    target?: boolean
    xpReward?: boolean
    createdAt?: boolean
    unlocks?: boolean | Achievement$unlocksArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    level?: boolean
    color?: boolean
    target?: boolean
    xpReward?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    level?: boolean
    color?: boolean
    target?: boolean
    xpReward?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    level?: boolean
    color?: boolean
    target?: boolean
    xpReward?: boolean
    createdAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "icon" | "category" | "level" | "color" | "target" | "xpReward" | "createdAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlocks?: boolean | Achievement$unlocksArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      unlocks: Prisma.$AchievementUnlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      icon: string | null
      category: string
      level: number | null
      color: string | null
      target: number | null
      xpReward: number
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unlocks<T extends Achievement$unlocksArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$unlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'String'>
    readonly level: FieldRef<"Achievement", 'Int'>
    readonly color: FieldRef<"Achievement", 'String'>
    readonly target: FieldRef<"Achievement", 'Int'>
    readonly xpReward: FieldRef<"Achievement", 'Int'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.unlocks
   */
  export type Achievement$unlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    where?: AchievementUnlockWhereInput
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    cursor?: AchievementUnlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model AchievementUnlock
   */

  export type AggregateAchievementUnlock = {
    _count: AchievementUnlockCountAggregateOutputType | null
    _avg: AchievementUnlockAvgAggregateOutputType | null
    _sum: AchievementUnlockSumAggregateOutputType | null
    _min: AchievementUnlockMinAggregateOutputType | null
    _max: AchievementUnlockMaxAggregateOutputType | null
  }

  export type AchievementUnlockAvgAggregateOutputType = {
    progress: number | null
  }

  export type AchievementUnlockSumAggregateOutputType = {
    progress: number | null
  }

  export type AchievementUnlockMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    achievementId: string | null
    progress: number | null
    unlockedAt: Date | null
  }

  export type AchievementUnlockMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    achievementId: string | null
    progress: number | null
    unlockedAt: Date | null
  }

  export type AchievementUnlockCountAggregateOutputType = {
    id: number
    studentId: number
    achievementId: number
    progress: number
    unlockedAt: number
    _all: number
  }


  export type AchievementUnlockAvgAggregateInputType = {
    progress?: true
  }

  export type AchievementUnlockSumAggregateInputType = {
    progress?: true
  }

  export type AchievementUnlockMinAggregateInputType = {
    id?: true
    studentId?: true
    achievementId?: true
    progress?: true
    unlockedAt?: true
  }

  export type AchievementUnlockMaxAggregateInputType = {
    id?: true
    studentId?: true
    achievementId?: true
    progress?: true
    unlockedAt?: true
  }

  export type AchievementUnlockCountAggregateInputType = {
    id?: true
    studentId?: true
    achievementId?: true
    progress?: true
    unlockedAt?: true
    _all?: true
  }

  export type AchievementUnlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementUnlock to aggregate.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AchievementUnlocks
    **/
    _count?: true | AchievementUnlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementUnlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementUnlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementUnlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementUnlockMaxAggregateInputType
  }

  export type GetAchievementUnlockAggregateType<T extends AchievementUnlockAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievementUnlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievementUnlock[P]>
      : GetScalarType<T[P], AggregateAchievementUnlock[P]>
  }




  export type AchievementUnlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementUnlockWhereInput
    orderBy?: AchievementUnlockOrderByWithAggregationInput | AchievementUnlockOrderByWithAggregationInput[]
    by: AchievementUnlockScalarFieldEnum[] | AchievementUnlockScalarFieldEnum
    having?: AchievementUnlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementUnlockCountAggregateInputType | true
    _avg?: AchievementUnlockAvgAggregateInputType
    _sum?: AchievementUnlockSumAggregateInputType
    _min?: AchievementUnlockMinAggregateInputType
    _max?: AchievementUnlockMaxAggregateInputType
  }

  export type AchievementUnlockGroupByOutputType = {
    id: string
    studentId: string
    achievementId: string
    progress: number | null
    unlockedAt: Date
    _count: AchievementUnlockCountAggregateOutputType | null
    _avg: AchievementUnlockAvgAggregateOutputType | null
    _sum: AchievementUnlockSumAggregateOutputType | null
    _min: AchievementUnlockMinAggregateOutputType | null
    _max: AchievementUnlockMaxAggregateOutputType | null
  }

  type GetAchievementUnlockGroupByPayload<T extends AchievementUnlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementUnlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementUnlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementUnlockGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementUnlockGroupByOutputType[P]>
        }
      >
    >


  export type AchievementUnlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlockedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementUnlock"]>

  export type AchievementUnlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlockedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementUnlock"]>

  export type AchievementUnlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlockedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementUnlock"]>

  export type AchievementUnlockSelectScalar = {
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlockedAt?: boolean
  }

  export type AchievementUnlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "achievementId" | "progress" | "unlockedAt", ExtArgs["result"]["achievementUnlock"]>
  export type AchievementUnlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type AchievementUnlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type AchievementUnlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $AchievementUnlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AchievementUnlock"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      achievementId: string
      progress: number | null
      unlockedAt: Date
    }, ExtArgs["result"]["achievementUnlock"]>
    composites: {}
  }

  type AchievementUnlockGetPayload<S extends boolean | null | undefined | AchievementUnlockDefaultArgs> = $Result.GetResult<Prisma.$AchievementUnlockPayload, S>

  type AchievementUnlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementUnlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementUnlockCountAggregateInputType | true
    }

  export interface AchievementUnlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AchievementUnlock'], meta: { name: 'AchievementUnlock' } }
    /**
     * Find zero or one AchievementUnlock that matches the filter.
     * @param {AchievementUnlockFindUniqueArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementUnlockFindUniqueArgs>(args: SelectSubset<T, AchievementUnlockFindUniqueArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AchievementUnlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementUnlockFindUniqueOrThrowArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementUnlockFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementUnlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AchievementUnlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockFindFirstArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementUnlockFindFirstArgs>(args?: SelectSubset<T, AchievementUnlockFindFirstArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AchievementUnlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockFindFirstOrThrowArgs} args - Arguments to find a AchievementUnlock
     * @example
     * // Get one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementUnlockFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementUnlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AchievementUnlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AchievementUnlocks
     * const achievementUnlocks = await prisma.achievementUnlock.findMany()
     * 
     * // Get first 10 AchievementUnlocks
     * const achievementUnlocks = await prisma.achievementUnlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementUnlockWithIdOnly = await prisma.achievementUnlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementUnlockFindManyArgs>(args?: SelectSubset<T, AchievementUnlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AchievementUnlock.
     * @param {AchievementUnlockCreateArgs} args - Arguments to create a AchievementUnlock.
     * @example
     * // Create one AchievementUnlock
     * const AchievementUnlock = await prisma.achievementUnlock.create({
     *   data: {
     *     // ... data to create a AchievementUnlock
     *   }
     * })
     * 
     */
    create<T extends AchievementUnlockCreateArgs>(args: SelectSubset<T, AchievementUnlockCreateArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AchievementUnlocks.
     * @param {AchievementUnlockCreateManyArgs} args - Arguments to create many AchievementUnlocks.
     * @example
     * // Create many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementUnlockCreateManyArgs>(args?: SelectSubset<T, AchievementUnlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AchievementUnlocks and returns the data saved in the database.
     * @param {AchievementUnlockCreateManyAndReturnArgs} args - Arguments to create many AchievementUnlocks.
     * @example
     * // Create many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AchievementUnlocks and only return the `id`
     * const achievementUnlockWithIdOnly = await prisma.achievementUnlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementUnlockCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementUnlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AchievementUnlock.
     * @param {AchievementUnlockDeleteArgs} args - Arguments to delete one AchievementUnlock.
     * @example
     * // Delete one AchievementUnlock
     * const AchievementUnlock = await prisma.achievementUnlock.delete({
     *   where: {
     *     // ... filter to delete one AchievementUnlock
     *   }
     * })
     * 
     */
    delete<T extends AchievementUnlockDeleteArgs>(args: SelectSubset<T, AchievementUnlockDeleteArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AchievementUnlock.
     * @param {AchievementUnlockUpdateArgs} args - Arguments to update one AchievementUnlock.
     * @example
     * // Update one AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUnlockUpdateArgs>(args: SelectSubset<T, AchievementUnlockUpdateArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AchievementUnlocks.
     * @param {AchievementUnlockDeleteManyArgs} args - Arguments to filter AchievementUnlocks to delete.
     * @example
     * // Delete a few AchievementUnlocks
     * const { count } = await prisma.achievementUnlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementUnlockDeleteManyArgs>(args?: SelectSubset<T, AchievementUnlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementUnlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUnlockUpdateManyArgs>(args: SelectSubset<T, AchievementUnlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementUnlocks and returns the data updated in the database.
     * @param {AchievementUnlockUpdateManyAndReturnArgs} args - Arguments to update many AchievementUnlocks.
     * @example
     * // Update many AchievementUnlocks
     * const achievementUnlock = await prisma.achievementUnlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AchievementUnlocks and only return the `id`
     * const achievementUnlockWithIdOnly = await prisma.achievementUnlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUnlockUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUnlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AchievementUnlock.
     * @param {AchievementUnlockUpsertArgs} args - Arguments to update or create a AchievementUnlock.
     * @example
     * // Update or create a AchievementUnlock
     * const achievementUnlock = await prisma.achievementUnlock.upsert({
     *   create: {
     *     // ... data to create a AchievementUnlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AchievementUnlock we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUnlockUpsertArgs>(args: SelectSubset<T, AchievementUnlockUpsertArgs<ExtArgs>>): Prisma__AchievementUnlockClient<$Result.GetResult<Prisma.$AchievementUnlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AchievementUnlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockCountArgs} args - Arguments to filter AchievementUnlocks to count.
     * @example
     * // Count the number of AchievementUnlocks
     * const count = await prisma.achievementUnlock.count({
     *   where: {
     *     // ... the filter for the AchievementUnlocks we want to count
     *   }
     * })
    **/
    count<T extends AchievementUnlockCountArgs>(
      args?: Subset<T, AchievementUnlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementUnlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AchievementUnlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementUnlockAggregateArgs>(args: Subset<T, AchievementUnlockAggregateArgs>): Prisma.PrismaPromise<GetAchievementUnlockAggregateType<T>>

    /**
     * Group by AchievementUnlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUnlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementUnlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementUnlockGroupByArgs['orderBy'] }
        : { orderBy?: AchievementUnlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementUnlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementUnlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AchievementUnlock model
   */
  readonly fields: AchievementUnlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AchievementUnlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementUnlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AchievementUnlock model
   */
  interface AchievementUnlockFieldRefs {
    readonly id: FieldRef<"AchievementUnlock", 'String'>
    readonly studentId: FieldRef<"AchievementUnlock", 'String'>
    readonly achievementId: FieldRef<"AchievementUnlock", 'String'>
    readonly progress: FieldRef<"AchievementUnlock", 'Int'>
    readonly unlockedAt: FieldRef<"AchievementUnlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AchievementUnlock findUnique
   */
  export type AchievementUnlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock findUniqueOrThrow
   */
  export type AchievementUnlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock findFirst
   */
  export type AchievementUnlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementUnlocks.
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementUnlocks.
     */
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * AchievementUnlock findFirstOrThrow
   */
  export type AchievementUnlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlock to fetch.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementUnlocks.
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementUnlocks.
     */
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * AchievementUnlock findMany
   */
  export type AchievementUnlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter, which AchievementUnlocks to fetch.
     */
    where?: AchievementUnlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementUnlocks to fetch.
     */
    orderBy?: AchievementUnlockOrderByWithRelationInput | AchievementUnlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AchievementUnlocks.
     */
    cursor?: AchievementUnlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementUnlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementUnlocks.
     */
    skip?: number
    distinct?: AchievementUnlockScalarFieldEnum | AchievementUnlockScalarFieldEnum[]
  }

  /**
   * AchievementUnlock create
   */
  export type AchievementUnlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * The data needed to create a AchievementUnlock.
     */
    data: XOR<AchievementUnlockCreateInput, AchievementUnlockUncheckedCreateInput>
  }

  /**
   * AchievementUnlock createMany
   */
  export type AchievementUnlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AchievementUnlocks.
     */
    data: AchievementUnlockCreateManyInput | AchievementUnlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AchievementUnlock createManyAndReturn
   */
  export type AchievementUnlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * The data used to create many AchievementUnlocks.
     */
    data: AchievementUnlockCreateManyInput | AchievementUnlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AchievementUnlock update
   */
  export type AchievementUnlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * The data needed to update a AchievementUnlock.
     */
    data: XOR<AchievementUnlockUpdateInput, AchievementUnlockUncheckedUpdateInput>
    /**
     * Choose, which AchievementUnlock to update.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock updateMany
   */
  export type AchievementUnlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AchievementUnlocks.
     */
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyInput>
    /**
     * Filter which AchievementUnlocks to update
     */
    where?: AchievementUnlockWhereInput
    /**
     * Limit how many AchievementUnlocks to update.
     */
    limit?: number
  }

  /**
   * AchievementUnlock updateManyAndReturn
   */
  export type AchievementUnlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * The data used to update AchievementUnlocks.
     */
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyInput>
    /**
     * Filter which AchievementUnlocks to update
     */
    where?: AchievementUnlockWhereInput
    /**
     * Limit how many AchievementUnlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AchievementUnlock upsert
   */
  export type AchievementUnlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * The filter to search for the AchievementUnlock to update in case it exists.
     */
    where: AchievementUnlockWhereUniqueInput
    /**
     * In case the AchievementUnlock found by the `where` argument doesn't exist, create a new AchievementUnlock with this data.
     */
    create: XOR<AchievementUnlockCreateInput, AchievementUnlockUncheckedCreateInput>
    /**
     * In case the AchievementUnlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUnlockUpdateInput, AchievementUnlockUncheckedUpdateInput>
  }

  /**
   * AchievementUnlock delete
   */
  export type AchievementUnlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
    /**
     * Filter which AchievementUnlock to delete.
     */
    where: AchievementUnlockWhereUniqueInput
  }

  /**
   * AchievementUnlock deleteMany
   */
  export type AchievementUnlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementUnlocks to delete
     */
    where?: AchievementUnlockWhereInput
    /**
     * Limit how many AchievementUnlocks to delete.
     */
    limit?: number
  }

  /**
   * AchievementUnlock without action
   */
  export type AchievementUnlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementUnlock
     */
    select?: AchievementUnlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementUnlock
     */
    omit?: AchievementUnlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementUnlockInclude<ExtArgs> | null
  }


  /**
   * Model GymUserPreference
   */

  export type AggregateGymUserPreference = {
    _count: GymUserPreferenceCountAggregateOutputType | null
    _min: GymUserPreferenceMinAggregateOutputType | null
    _max: GymUserPreferenceMaxAggregateOutputType | null
  }

  export type GymUserPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    lastActiveGymId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymUserPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    lastActiveGymId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymUserPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    lastActiveGymId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymUserPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    lastActiveGymId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymUserPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    lastActiveGymId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymUserPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    lastActiveGymId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymUserPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymUserPreference to aggregate.
     */
    where?: GymUserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymUserPreferences to fetch.
     */
    orderBy?: GymUserPreferenceOrderByWithRelationInput | GymUserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymUserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymUserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymUserPreferences
    **/
    _count?: true | GymUserPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymUserPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymUserPreferenceMaxAggregateInputType
  }

  export type GetGymUserPreferenceAggregateType<T extends GymUserPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateGymUserPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymUserPreference[P]>
      : GetScalarType<T[P], AggregateGymUserPreference[P]>
  }




  export type GymUserPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymUserPreferenceWhereInput
    orderBy?: GymUserPreferenceOrderByWithAggregationInput | GymUserPreferenceOrderByWithAggregationInput[]
    by: GymUserPreferenceScalarFieldEnum[] | GymUserPreferenceScalarFieldEnum
    having?: GymUserPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymUserPreferenceCountAggregateInputType | true
    _min?: GymUserPreferenceMinAggregateInputType
    _max?: GymUserPreferenceMaxAggregateInputType
  }

  export type GymUserPreferenceGroupByOutputType = {
    id: string
    userId: string
    lastActiveGymId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GymUserPreferenceCountAggregateOutputType | null
    _min: GymUserPreferenceMinAggregateOutputType | null
    _max: GymUserPreferenceMaxAggregateOutputType | null
  }

  type GetGymUserPreferenceGroupByPayload<T extends GymUserPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymUserPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymUserPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymUserPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], GymUserPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type GymUserPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lastActiveGymId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymUserPreference"]>

  export type GymUserPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lastActiveGymId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymUserPreference"]>

  export type GymUserPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lastActiveGymId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymUserPreference"]>

  export type GymUserPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    lastActiveGymId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymUserPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "lastActiveGymId" | "createdAt" | "updatedAt", ExtArgs["result"]["gymUserPreference"]>
  export type GymUserPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GymUserPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GymUserPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GymUserPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymUserPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      lastActiveGymId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymUserPreference"]>
    composites: {}
  }

  type GymUserPreferenceGetPayload<S extends boolean | null | undefined | GymUserPreferenceDefaultArgs> = $Result.GetResult<Prisma.$GymUserPreferencePayload, S>

  type GymUserPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymUserPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymUserPreferenceCountAggregateInputType | true
    }

  export interface GymUserPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymUserPreference'], meta: { name: 'GymUserPreference' } }
    /**
     * Find zero or one GymUserPreference that matches the filter.
     * @param {GymUserPreferenceFindUniqueArgs} args - Arguments to find a GymUserPreference
     * @example
     * // Get one GymUserPreference
     * const gymUserPreference = await prisma.gymUserPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymUserPreferenceFindUniqueArgs>(args: SelectSubset<T, GymUserPreferenceFindUniqueArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymUserPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymUserPreferenceFindUniqueOrThrowArgs} args - Arguments to find a GymUserPreference
     * @example
     * // Get one GymUserPreference
     * const gymUserPreference = await prisma.gymUserPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymUserPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, GymUserPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymUserPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceFindFirstArgs} args - Arguments to find a GymUserPreference
     * @example
     * // Get one GymUserPreference
     * const gymUserPreference = await prisma.gymUserPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymUserPreferenceFindFirstArgs>(args?: SelectSubset<T, GymUserPreferenceFindFirstArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymUserPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceFindFirstOrThrowArgs} args - Arguments to find a GymUserPreference
     * @example
     * // Get one GymUserPreference
     * const gymUserPreference = await prisma.gymUserPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymUserPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, GymUserPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymUserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymUserPreferences
     * const gymUserPreferences = await prisma.gymUserPreference.findMany()
     * 
     * // Get first 10 GymUserPreferences
     * const gymUserPreferences = await prisma.gymUserPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymUserPreferenceWithIdOnly = await prisma.gymUserPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymUserPreferenceFindManyArgs>(args?: SelectSubset<T, GymUserPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymUserPreference.
     * @param {GymUserPreferenceCreateArgs} args - Arguments to create a GymUserPreference.
     * @example
     * // Create one GymUserPreference
     * const GymUserPreference = await prisma.gymUserPreference.create({
     *   data: {
     *     // ... data to create a GymUserPreference
     *   }
     * })
     * 
     */
    create<T extends GymUserPreferenceCreateArgs>(args: SelectSubset<T, GymUserPreferenceCreateArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymUserPreferences.
     * @param {GymUserPreferenceCreateManyArgs} args - Arguments to create many GymUserPreferences.
     * @example
     * // Create many GymUserPreferences
     * const gymUserPreference = await prisma.gymUserPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymUserPreferenceCreateManyArgs>(args?: SelectSubset<T, GymUserPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymUserPreferences and returns the data saved in the database.
     * @param {GymUserPreferenceCreateManyAndReturnArgs} args - Arguments to create many GymUserPreferences.
     * @example
     * // Create many GymUserPreferences
     * const gymUserPreference = await prisma.gymUserPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymUserPreferences and only return the `id`
     * const gymUserPreferenceWithIdOnly = await prisma.gymUserPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymUserPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, GymUserPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymUserPreference.
     * @param {GymUserPreferenceDeleteArgs} args - Arguments to delete one GymUserPreference.
     * @example
     * // Delete one GymUserPreference
     * const GymUserPreference = await prisma.gymUserPreference.delete({
     *   where: {
     *     // ... filter to delete one GymUserPreference
     *   }
     * })
     * 
     */
    delete<T extends GymUserPreferenceDeleteArgs>(args: SelectSubset<T, GymUserPreferenceDeleteArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymUserPreference.
     * @param {GymUserPreferenceUpdateArgs} args - Arguments to update one GymUserPreference.
     * @example
     * // Update one GymUserPreference
     * const gymUserPreference = await prisma.gymUserPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymUserPreferenceUpdateArgs>(args: SelectSubset<T, GymUserPreferenceUpdateArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymUserPreferences.
     * @param {GymUserPreferenceDeleteManyArgs} args - Arguments to filter GymUserPreferences to delete.
     * @example
     * // Delete a few GymUserPreferences
     * const { count } = await prisma.gymUserPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymUserPreferenceDeleteManyArgs>(args?: SelectSubset<T, GymUserPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymUserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymUserPreferences
     * const gymUserPreference = await prisma.gymUserPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymUserPreferenceUpdateManyArgs>(args: SelectSubset<T, GymUserPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymUserPreferences and returns the data updated in the database.
     * @param {GymUserPreferenceUpdateManyAndReturnArgs} args - Arguments to update many GymUserPreferences.
     * @example
     * // Update many GymUserPreferences
     * const gymUserPreference = await prisma.gymUserPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymUserPreferences and only return the `id`
     * const gymUserPreferenceWithIdOnly = await prisma.gymUserPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymUserPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, GymUserPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymUserPreference.
     * @param {GymUserPreferenceUpsertArgs} args - Arguments to update or create a GymUserPreference.
     * @example
     * // Update or create a GymUserPreference
     * const gymUserPreference = await prisma.gymUserPreference.upsert({
     *   create: {
     *     // ... data to create a GymUserPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymUserPreference we want to update
     *   }
     * })
     */
    upsert<T extends GymUserPreferenceUpsertArgs>(args: SelectSubset<T, GymUserPreferenceUpsertArgs<ExtArgs>>): Prisma__GymUserPreferenceClient<$Result.GetResult<Prisma.$GymUserPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymUserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceCountArgs} args - Arguments to filter GymUserPreferences to count.
     * @example
     * // Count the number of GymUserPreferences
     * const count = await prisma.gymUserPreference.count({
     *   where: {
     *     // ... the filter for the GymUserPreferences we want to count
     *   }
     * })
    **/
    count<T extends GymUserPreferenceCountArgs>(
      args?: Subset<T, GymUserPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymUserPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymUserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymUserPreferenceAggregateArgs>(args: Subset<T, GymUserPreferenceAggregateArgs>): Prisma.PrismaPromise<GetGymUserPreferenceAggregateType<T>>

    /**
     * Group by GymUserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUserPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymUserPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymUserPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: GymUserPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymUserPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymUserPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymUserPreference model
   */
  readonly fields: GymUserPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymUserPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymUserPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymUserPreference model
   */
  interface GymUserPreferenceFieldRefs {
    readonly id: FieldRef<"GymUserPreference", 'String'>
    readonly userId: FieldRef<"GymUserPreference", 'String'>
    readonly lastActiveGymId: FieldRef<"GymUserPreference", 'String'>
    readonly createdAt: FieldRef<"GymUserPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"GymUserPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymUserPreference findUnique
   */
  export type GymUserPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which GymUserPreference to fetch.
     */
    where: GymUserPreferenceWhereUniqueInput
  }

  /**
   * GymUserPreference findUniqueOrThrow
   */
  export type GymUserPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which GymUserPreference to fetch.
     */
    where: GymUserPreferenceWhereUniqueInput
  }

  /**
   * GymUserPreference findFirst
   */
  export type GymUserPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which GymUserPreference to fetch.
     */
    where?: GymUserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymUserPreferences to fetch.
     */
    orderBy?: GymUserPreferenceOrderByWithRelationInput | GymUserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymUserPreferences.
     */
    cursor?: GymUserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymUserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymUserPreferences.
     */
    distinct?: GymUserPreferenceScalarFieldEnum | GymUserPreferenceScalarFieldEnum[]
  }

  /**
   * GymUserPreference findFirstOrThrow
   */
  export type GymUserPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which GymUserPreference to fetch.
     */
    where?: GymUserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymUserPreferences to fetch.
     */
    orderBy?: GymUserPreferenceOrderByWithRelationInput | GymUserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymUserPreferences.
     */
    cursor?: GymUserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymUserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymUserPreferences.
     */
    distinct?: GymUserPreferenceScalarFieldEnum | GymUserPreferenceScalarFieldEnum[]
  }

  /**
   * GymUserPreference findMany
   */
  export type GymUserPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which GymUserPreferences to fetch.
     */
    where?: GymUserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymUserPreferences to fetch.
     */
    orderBy?: GymUserPreferenceOrderByWithRelationInput | GymUserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymUserPreferences.
     */
    cursor?: GymUserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymUserPreferences.
     */
    skip?: number
    distinct?: GymUserPreferenceScalarFieldEnum | GymUserPreferenceScalarFieldEnum[]
  }

  /**
   * GymUserPreference create
   */
  export type GymUserPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a GymUserPreference.
     */
    data: XOR<GymUserPreferenceCreateInput, GymUserPreferenceUncheckedCreateInput>
  }

  /**
   * GymUserPreference createMany
   */
  export type GymUserPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymUserPreferences.
     */
    data: GymUserPreferenceCreateManyInput | GymUserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymUserPreference createManyAndReturn
   */
  export type GymUserPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many GymUserPreferences.
     */
    data: GymUserPreferenceCreateManyInput | GymUserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymUserPreference update
   */
  export type GymUserPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a GymUserPreference.
     */
    data: XOR<GymUserPreferenceUpdateInput, GymUserPreferenceUncheckedUpdateInput>
    /**
     * Choose, which GymUserPreference to update.
     */
    where: GymUserPreferenceWhereUniqueInput
  }

  /**
   * GymUserPreference updateMany
   */
  export type GymUserPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymUserPreferences.
     */
    data: XOR<GymUserPreferenceUpdateManyMutationInput, GymUserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which GymUserPreferences to update
     */
    where?: GymUserPreferenceWhereInput
    /**
     * Limit how many GymUserPreferences to update.
     */
    limit?: number
  }

  /**
   * GymUserPreference updateManyAndReturn
   */
  export type GymUserPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update GymUserPreferences.
     */
    data: XOR<GymUserPreferenceUpdateManyMutationInput, GymUserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which GymUserPreferences to update
     */
    where?: GymUserPreferenceWhereInput
    /**
     * Limit how many GymUserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymUserPreference upsert
   */
  export type GymUserPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the GymUserPreference to update in case it exists.
     */
    where: GymUserPreferenceWhereUniqueInput
    /**
     * In case the GymUserPreference found by the `where` argument doesn't exist, create a new GymUserPreference with this data.
     */
    create: XOR<GymUserPreferenceCreateInput, GymUserPreferenceUncheckedCreateInput>
    /**
     * In case the GymUserPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymUserPreferenceUpdateInput, GymUserPreferenceUncheckedUpdateInput>
  }

  /**
   * GymUserPreference delete
   */
  export type GymUserPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
    /**
     * Filter which GymUserPreference to delete.
     */
    where: GymUserPreferenceWhereUniqueInput
  }

  /**
   * GymUserPreference deleteMany
   */
  export type GymUserPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymUserPreferences to delete
     */
    where?: GymUserPreferenceWhereInput
    /**
     * Limit how many GymUserPreferences to delete.
     */
    limit?: number
  }

  /**
   * GymUserPreference without action
   */
  export type GymUserPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymUserPreference
     */
    select?: GymUserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymUserPreference
     */
    omit?: GymUserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymUserPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model GymMembership
   */

  export type AggregateGymMembership = {
    _count: GymMembershipCountAggregateOutputType | null
    _avg: GymMembershipAvgAggregateOutputType | null
    _sum: GymMembershipSumAggregateOutputType | null
    _min: GymMembershipMinAggregateOutputType | null
    _max: GymMembershipMaxAggregateOutputType | null
  }

  export type GymMembershipAvgAggregateOutputType = {
    amount: number | null
  }

  export type GymMembershipSumAggregateOutputType = {
    amount: number | null
  }

  export type GymMembershipMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    studentId: string | null
    planId: string | null
    startDate: Date | null
    nextBillingDate: Date | null
    amount: number | null
    status: string | null
    autoRenew: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymMembershipMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    studentId: string | null
    planId: string | null
    startDate: Date | null
    nextBillingDate: Date | null
    amount: number | null
    status: string | null
    autoRenew: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymMembershipCountAggregateOutputType = {
    id: number
    gymId: number
    studentId: number
    planId: number
    startDate: number
    nextBillingDate: number
    amount: number
    status: number
    autoRenew: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymMembershipAvgAggregateInputType = {
    amount?: true
  }

  export type GymMembershipSumAggregateInputType = {
    amount?: true
  }

  export type GymMembershipMinAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    planId?: true
    startDate?: true
    nextBillingDate?: true
    amount?: true
    status?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymMembershipMaxAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    planId?: true
    startDate?: true
    nextBillingDate?: true
    amount?: true
    status?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymMembershipCountAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    planId?: true
    startDate?: true
    nextBillingDate?: true
    amount?: true
    status?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymMembership to aggregate.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymMemberships
    **/
    _count?: true | GymMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymMembershipMaxAggregateInputType
  }

  export type GetGymMembershipAggregateType<T extends GymMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateGymMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymMembership[P]>
      : GetScalarType<T[P], AggregateGymMembership[P]>
  }




  export type GymMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymMembershipWhereInput
    orderBy?: GymMembershipOrderByWithAggregationInput | GymMembershipOrderByWithAggregationInput[]
    by: GymMembershipScalarFieldEnum[] | GymMembershipScalarFieldEnum
    having?: GymMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymMembershipCountAggregateInputType | true
    _avg?: GymMembershipAvgAggregateInputType
    _sum?: GymMembershipSumAggregateInputType
    _min?: GymMembershipMinAggregateInputType
    _max?: GymMembershipMaxAggregateInputType
  }

  export type GymMembershipGroupByOutputType = {
    id: string
    gymId: string
    studentId: string
    planId: string | null
    startDate: Date
    nextBillingDate: Date | null
    amount: number
    status: string
    autoRenew: boolean
    createdAt: Date
    updatedAt: Date
    _count: GymMembershipCountAggregateOutputType | null
    _avg: GymMembershipAvgAggregateOutputType | null
    _sum: GymMembershipSumAggregateOutputType | null
    _min: GymMembershipMinAggregateOutputType | null
    _max: GymMembershipMaxAggregateOutputType | null
  }

  type GetGymMembershipGroupByPayload<T extends GymMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], GymMembershipGroupByOutputType[P]>
        }
      >
    >


  export type GymMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    planId?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    amount?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    plan?: boolean | GymMembership$planArgs<ExtArgs>
  }, ExtArgs["result"]["gymMembership"]>

  export type GymMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    planId?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    amount?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    plan?: boolean | GymMembership$planArgs<ExtArgs>
  }, ExtArgs["result"]["gymMembership"]>

  export type GymMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    planId?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    amount?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    plan?: boolean | GymMembership$planArgs<ExtArgs>
  }, ExtArgs["result"]["gymMembership"]>

  export type GymMembershipSelectScalar = {
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    planId?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    amount?: boolean
    status?: boolean
    autoRenew?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "studentId" | "planId" | "startDate" | "nextBillingDate" | "amount" | "status" | "autoRenew" | "createdAt" | "updatedAt", ExtArgs["result"]["gymMembership"]>
  export type GymMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    plan?: boolean | GymMembership$planArgs<ExtArgs>
  }
  export type GymMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    plan?: boolean | GymMembership$planArgs<ExtArgs>
  }
  export type GymMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    plan?: boolean | GymMembership$planArgs<ExtArgs>
  }

  export type $GymMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymMembership"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      plan: Prisma.$MembershipPlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      studentId: string
      planId: string | null
      startDate: Date
      nextBillingDate: Date | null
      amount: number
      status: string
      autoRenew: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymMembership"]>
    composites: {}
  }

  type GymMembershipGetPayload<S extends boolean | null | undefined | GymMembershipDefaultArgs> = $Result.GetResult<Prisma.$GymMembershipPayload, S>

  type GymMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymMembershipCountAggregateInputType | true
    }

  export interface GymMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymMembership'], meta: { name: 'GymMembership' } }
    /**
     * Find zero or one GymMembership that matches the filter.
     * @param {GymMembershipFindUniqueArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymMembershipFindUniqueArgs>(args: SelectSubset<T, GymMembershipFindUniqueArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymMembershipFindUniqueOrThrowArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, GymMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipFindFirstArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymMembershipFindFirstArgs>(args?: SelectSubset<T, GymMembershipFindFirstArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipFindFirstOrThrowArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, GymMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymMemberships
     * const gymMemberships = await prisma.gymMembership.findMany()
     * 
     * // Get first 10 GymMemberships
     * const gymMemberships = await prisma.gymMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymMembershipWithIdOnly = await prisma.gymMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymMembershipFindManyArgs>(args?: SelectSubset<T, GymMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymMembership.
     * @param {GymMembershipCreateArgs} args - Arguments to create a GymMembership.
     * @example
     * // Create one GymMembership
     * const GymMembership = await prisma.gymMembership.create({
     *   data: {
     *     // ... data to create a GymMembership
     *   }
     * })
     * 
     */
    create<T extends GymMembershipCreateArgs>(args: SelectSubset<T, GymMembershipCreateArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymMemberships.
     * @param {GymMembershipCreateManyArgs} args - Arguments to create many GymMemberships.
     * @example
     * // Create many GymMemberships
     * const gymMembership = await prisma.gymMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymMembershipCreateManyArgs>(args?: SelectSubset<T, GymMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymMemberships and returns the data saved in the database.
     * @param {GymMembershipCreateManyAndReturnArgs} args - Arguments to create many GymMemberships.
     * @example
     * // Create many GymMemberships
     * const gymMembership = await prisma.gymMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymMemberships and only return the `id`
     * const gymMembershipWithIdOnly = await prisma.gymMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, GymMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymMembership.
     * @param {GymMembershipDeleteArgs} args - Arguments to delete one GymMembership.
     * @example
     * // Delete one GymMembership
     * const GymMembership = await prisma.gymMembership.delete({
     *   where: {
     *     // ... filter to delete one GymMembership
     *   }
     * })
     * 
     */
    delete<T extends GymMembershipDeleteArgs>(args: SelectSubset<T, GymMembershipDeleteArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymMembership.
     * @param {GymMembershipUpdateArgs} args - Arguments to update one GymMembership.
     * @example
     * // Update one GymMembership
     * const gymMembership = await prisma.gymMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymMembershipUpdateArgs>(args: SelectSubset<T, GymMembershipUpdateArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymMemberships.
     * @param {GymMembershipDeleteManyArgs} args - Arguments to filter GymMemberships to delete.
     * @example
     * // Delete a few GymMemberships
     * const { count } = await prisma.gymMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymMembershipDeleteManyArgs>(args?: SelectSubset<T, GymMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymMemberships
     * const gymMembership = await prisma.gymMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymMembershipUpdateManyArgs>(args: SelectSubset<T, GymMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymMemberships and returns the data updated in the database.
     * @param {GymMembershipUpdateManyAndReturnArgs} args - Arguments to update many GymMemberships.
     * @example
     * // Update many GymMemberships
     * const gymMembership = await prisma.gymMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymMemberships and only return the `id`
     * const gymMembershipWithIdOnly = await prisma.gymMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, GymMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymMembership.
     * @param {GymMembershipUpsertArgs} args - Arguments to update or create a GymMembership.
     * @example
     * // Update or create a GymMembership
     * const gymMembership = await prisma.gymMembership.upsert({
     *   create: {
     *     // ... data to create a GymMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymMembership we want to update
     *   }
     * })
     */
    upsert<T extends GymMembershipUpsertArgs>(args: SelectSubset<T, GymMembershipUpsertArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipCountArgs} args - Arguments to filter GymMemberships to count.
     * @example
     * // Count the number of GymMemberships
     * const count = await prisma.gymMembership.count({
     *   where: {
     *     // ... the filter for the GymMemberships we want to count
     *   }
     * })
    **/
    count<T extends GymMembershipCountArgs>(
      args?: Subset<T, GymMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymMembershipAggregateArgs>(args: Subset<T, GymMembershipAggregateArgs>): Prisma.PrismaPromise<GetGymMembershipAggregateType<T>>

    /**
     * Group by GymMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymMembershipGroupByArgs['orderBy'] }
        : { orderBy?: GymMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymMembership model
   */
  readonly fields: GymMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends GymMembership$planArgs<ExtArgs> = {}>(args?: Subset<T, GymMembership$planArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymMembership model
   */
  interface GymMembershipFieldRefs {
    readonly id: FieldRef<"GymMembership", 'String'>
    readonly gymId: FieldRef<"GymMembership", 'String'>
    readonly studentId: FieldRef<"GymMembership", 'String'>
    readonly planId: FieldRef<"GymMembership", 'String'>
    readonly startDate: FieldRef<"GymMembership", 'DateTime'>
    readonly nextBillingDate: FieldRef<"GymMembership", 'DateTime'>
    readonly amount: FieldRef<"GymMembership", 'Float'>
    readonly status: FieldRef<"GymMembership", 'String'>
    readonly autoRenew: FieldRef<"GymMembership", 'Boolean'>
    readonly createdAt: FieldRef<"GymMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"GymMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymMembership findUnique
   */
  export type GymMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership findUniqueOrThrow
   */
  export type GymMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership findFirst
   */
  export type GymMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymMemberships.
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymMemberships.
     */
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * GymMembership findFirstOrThrow
   */
  export type GymMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymMemberships.
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymMemberships.
     */
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * GymMembership findMany
   */
  export type GymMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMemberships to fetch.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymMemberships.
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * GymMembership create
   */
  export type GymMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a GymMembership.
     */
    data: XOR<GymMembershipCreateInput, GymMembershipUncheckedCreateInput>
  }

  /**
   * GymMembership createMany
   */
  export type GymMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymMemberships.
     */
    data: GymMembershipCreateManyInput | GymMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymMembership createManyAndReturn
   */
  export type GymMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many GymMemberships.
     */
    data: GymMembershipCreateManyInput | GymMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymMembership update
   */
  export type GymMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a GymMembership.
     */
    data: XOR<GymMembershipUpdateInput, GymMembershipUncheckedUpdateInput>
    /**
     * Choose, which GymMembership to update.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership updateMany
   */
  export type GymMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymMemberships.
     */
    data: XOR<GymMembershipUpdateManyMutationInput, GymMembershipUncheckedUpdateManyInput>
    /**
     * Filter which GymMemberships to update
     */
    where?: GymMembershipWhereInput
    /**
     * Limit how many GymMemberships to update.
     */
    limit?: number
  }

  /**
   * GymMembership updateManyAndReturn
   */
  export type GymMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * The data used to update GymMemberships.
     */
    data: XOR<GymMembershipUpdateManyMutationInput, GymMembershipUncheckedUpdateManyInput>
    /**
     * Filter which GymMemberships to update
     */
    where?: GymMembershipWhereInput
    /**
     * Limit how many GymMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymMembership upsert
   */
  export type GymMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the GymMembership to update in case it exists.
     */
    where: GymMembershipWhereUniqueInput
    /**
     * In case the GymMembership found by the `where` argument doesn't exist, create a new GymMembership with this data.
     */
    create: XOR<GymMembershipCreateInput, GymMembershipUncheckedCreateInput>
    /**
     * In case the GymMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymMembershipUpdateInput, GymMembershipUncheckedUpdateInput>
  }

  /**
   * GymMembership delete
   */
  export type GymMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter which GymMembership to delete.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership deleteMany
   */
  export type GymMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymMemberships to delete
     */
    where?: GymMembershipWhereInput
    /**
     * Limit how many GymMemberships to delete.
     */
    limit?: number
  }

  /**
   * GymMembership.plan
   */
  export type GymMembership$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    where?: MembershipPlanWhereInput
  }

  /**
   * GymMembership without action
   */
  export type GymMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
  }


  /**
   * Model MembershipPlan
   */

  export type AggregateMembershipPlan = {
    _count: MembershipPlanCountAggregateOutputType | null
    _avg: MembershipPlanAvgAggregateOutputType | null
    _sum: MembershipPlanSumAggregateOutputType | null
    _min: MembershipPlanMinAggregateOutputType | null
    _max: MembershipPlanMaxAggregateOutputType | null
  }

  export type MembershipPlanAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type MembershipPlanSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type MembershipPlanMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    name: string | null
    type: string | null
    price: number | null
    duration: number | null
    benefits: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipPlanMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    name: string | null
    type: string | null
    price: number | null
    duration: number | null
    benefits: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipPlanCountAggregateOutputType = {
    id: number
    gymId: number
    name: number
    type: number
    price: number
    duration: number
    benefits: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipPlanAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type MembershipPlanSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type MembershipPlanMinAggregateInputType = {
    id?: true
    gymId?: true
    name?: true
    type?: true
    price?: true
    duration?: true
    benefits?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipPlanMaxAggregateInputType = {
    id?: true
    gymId?: true
    name?: true
    type?: true
    price?: true
    duration?: true
    benefits?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipPlanCountAggregateInputType = {
    id?: true
    gymId?: true
    name?: true
    type?: true
    price?: true
    duration?: true
    benefits?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipPlan to aggregate.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipPlans
    **/
    _count?: true | MembershipPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipPlanMaxAggregateInputType
  }

  export type GetMembershipPlanAggregateType<T extends MembershipPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipPlan[P]>
      : GetScalarType<T[P], AggregateMembershipPlan[P]>
  }




  export type MembershipPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipPlanWhereInput
    orderBy?: MembershipPlanOrderByWithAggregationInput | MembershipPlanOrderByWithAggregationInput[]
    by: MembershipPlanScalarFieldEnum[] | MembershipPlanScalarFieldEnum
    having?: MembershipPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipPlanCountAggregateInputType | true
    _avg?: MembershipPlanAvgAggregateInputType
    _sum?: MembershipPlanSumAggregateInputType
    _min?: MembershipPlanMinAggregateInputType
    _max?: MembershipPlanMaxAggregateInputType
  }

  export type MembershipPlanGroupByOutputType = {
    id: string
    gymId: string
    name: string
    type: string
    price: number
    duration: number
    benefits: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MembershipPlanCountAggregateOutputType | null
    _avg: MembershipPlanAvgAggregateOutputType | null
    _sum: MembershipPlanSumAggregateOutputType | null
    _min: MembershipPlanMinAggregateOutputType | null
    _max: MembershipPlanMaxAggregateOutputType | null
  }

  type GetMembershipPlanGroupByPayload<T extends MembershipPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipPlanGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipPlanGroupByOutputType[P]>
        }
      >
    >


  export type MembershipPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    benefits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    memberships?: boolean | MembershipPlan$membershipsArgs<ExtArgs>
    payments?: boolean | MembershipPlan$paymentsArgs<ExtArgs>
    _count?: boolean | MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipPlan"]>

  export type MembershipPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    benefits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipPlan"]>

  export type MembershipPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    benefits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipPlan"]>

  export type MembershipPlanSelectScalar = {
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    price?: boolean
    duration?: boolean
    benefits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "name" | "type" | "price" | "duration" | "benefits" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["membershipPlan"]>
  export type MembershipPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    memberships?: boolean | MembershipPlan$membershipsArgs<ExtArgs>
    payments?: boolean | MembershipPlan$paymentsArgs<ExtArgs>
    _count?: boolean | MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MembershipPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type MembershipPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $MembershipPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipPlan"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
      memberships: Prisma.$GymMembershipPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      name: string
      type: string
      price: number
      duration: number
      benefits: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipPlan"]>
    composites: {}
  }

  type MembershipPlanGetPayload<S extends boolean | null | undefined | MembershipPlanDefaultArgs> = $Result.GetResult<Prisma.$MembershipPlanPayload, S>

  type MembershipPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipPlanCountAggregateInputType | true
    }

  export interface MembershipPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipPlan'], meta: { name: 'MembershipPlan' } }
    /**
     * Find zero or one MembershipPlan that matches the filter.
     * @param {MembershipPlanFindUniqueArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipPlanFindUniqueArgs>(args: SelectSubset<T, MembershipPlanFindUniqueArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MembershipPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipPlanFindUniqueOrThrowArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindFirstArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipPlanFindFirstArgs>(args?: SelectSubset<T, MembershipPlanFindFirstArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindFirstOrThrowArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MembershipPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipPlans
     * const membershipPlans = await prisma.membershipPlan.findMany()
     * 
     * // Get first 10 MembershipPlans
     * const membershipPlans = await prisma.membershipPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipPlanFindManyArgs>(args?: SelectSubset<T, MembershipPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MembershipPlan.
     * @param {MembershipPlanCreateArgs} args - Arguments to create a MembershipPlan.
     * @example
     * // Create one MembershipPlan
     * const MembershipPlan = await prisma.membershipPlan.create({
     *   data: {
     *     // ... data to create a MembershipPlan
     *   }
     * })
     * 
     */
    create<T extends MembershipPlanCreateArgs>(args: SelectSubset<T, MembershipPlanCreateArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MembershipPlans.
     * @param {MembershipPlanCreateManyArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipPlanCreateManyArgs>(args?: SelectSubset<T, MembershipPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipPlans and returns the data saved in the database.
     * @param {MembershipPlanCreateManyAndReturnArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipPlans and only return the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MembershipPlan.
     * @param {MembershipPlanDeleteArgs} args - Arguments to delete one MembershipPlan.
     * @example
     * // Delete one MembershipPlan
     * const MembershipPlan = await prisma.membershipPlan.delete({
     *   where: {
     *     // ... filter to delete one MembershipPlan
     *   }
     * })
     * 
     */
    delete<T extends MembershipPlanDeleteArgs>(args: SelectSubset<T, MembershipPlanDeleteArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MembershipPlan.
     * @param {MembershipPlanUpdateArgs} args - Arguments to update one MembershipPlan.
     * @example
     * // Update one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipPlanUpdateArgs>(args: SelectSubset<T, MembershipPlanUpdateArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MembershipPlans.
     * @param {MembershipPlanDeleteManyArgs} args - Arguments to filter MembershipPlans to delete.
     * @example
     * // Delete a few MembershipPlans
     * const { count } = await prisma.membershipPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipPlanDeleteManyArgs>(args?: SelectSubset<T, MembershipPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipPlanUpdateManyArgs>(args: SelectSubset<T, MembershipPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans and returns the data updated in the database.
     * @param {MembershipPlanUpdateManyAndReturnArgs} args - Arguments to update many MembershipPlans.
     * @example
     * // Update many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MembershipPlans and only return the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MembershipPlan.
     * @param {MembershipPlanUpsertArgs} args - Arguments to update or create a MembershipPlan.
     * @example
     * // Update or create a MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.upsert({
     *   create: {
     *     // ... data to create a MembershipPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipPlan we want to update
     *   }
     * })
     */
    upsert<T extends MembershipPlanUpsertArgs>(args: SelectSubset<T, MembershipPlanUpsertArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanCountArgs} args - Arguments to filter MembershipPlans to count.
     * @example
     * // Count the number of MembershipPlans
     * const count = await prisma.membershipPlan.count({
     *   where: {
     *     // ... the filter for the MembershipPlans we want to count
     *   }
     * })
    **/
    count<T extends MembershipPlanCountArgs>(
      args?: Subset<T, MembershipPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipPlanAggregateArgs>(args: Subset<T, MembershipPlanAggregateArgs>): Prisma.PrismaPromise<GetMembershipPlanAggregateType<T>>

    /**
     * Group by MembershipPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipPlanGroupByArgs['orderBy'] }
        : { orderBy?: MembershipPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipPlan model
   */
  readonly fields: MembershipPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    memberships<T extends MembershipPlan$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, MembershipPlan$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends MembershipPlan$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, MembershipPlan$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipPlan model
   */
  interface MembershipPlanFieldRefs {
    readonly id: FieldRef<"MembershipPlan", 'String'>
    readonly gymId: FieldRef<"MembershipPlan", 'String'>
    readonly name: FieldRef<"MembershipPlan", 'String'>
    readonly type: FieldRef<"MembershipPlan", 'String'>
    readonly price: FieldRef<"MembershipPlan", 'Float'>
    readonly duration: FieldRef<"MembershipPlan", 'Int'>
    readonly benefits: FieldRef<"MembershipPlan", 'String'>
    readonly isActive: FieldRef<"MembershipPlan", 'Boolean'>
    readonly createdAt: FieldRef<"MembershipPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipPlan findUnique
   */
  export type MembershipPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan findUniqueOrThrow
   */
  export type MembershipPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan findFirst
   */
  export type MembershipPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipPlans.
     */
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan findFirstOrThrow
   */
  export type MembershipPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipPlans.
     */
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan findMany
   */
  export type MembershipPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlans to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan create
   */
  export type MembershipPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipPlan.
     */
    data: XOR<MembershipPlanCreateInput, MembershipPlanUncheckedCreateInput>
  }

  /**
   * MembershipPlan createMany
   */
  export type MembershipPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipPlans.
     */
    data: MembershipPlanCreateManyInput | MembershipPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipPlan createManyAndReturn
   */
  export type MembershipPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * The data used to create many MembershipPlans.
     */
    data: MembershipPlanCreateManyInput | MembershipPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipPlan update
   */
  export type MembershipPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipPlan.
     */
    data: XOR<MembershipPlanUpdateInput, MembershipPlanUncheckedUpdateInput>
    /**
     * Choose, which MembershipPlan to update.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan updateMany
   */
  export type MembershipPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipPlans.
     */
    data: XOR<MembershipPlanUpdateManyMutationInput, MembershipPlanUncheckedUpdateManyInput>
    /**
     * Filter which MembershipPlans to update
     */
    where?: MembershipPlanWhereInput
    /**
     * Limit how many MembershipPlans to update.
     */
    limit?: number
  }

  /**
   * MembershipPlan updateManyAndReturn
   */
  export type MembershipPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * The data used to update MembershipPlans.
     */
    data: XOR<MembershipPlanUpdateManyMutationInput, MembershipPlanUncheckedUpdateManyInput>
    /**
     * Filter which MembershipPlans to update
     */
    where?: MembershipPlanWhereInput
    /**
     * Limit how many MembershipPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipPlan upsert
   */
  export type MembershipPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipPlan to update in case it exists.
     */
    where: MembershipPlanWhereUniqueInput
    /**
     * In case the MembershipPlan found by the `where` argument doesn't exist, create a new MembershipPlan with this data.
     */
    create: XOR<MembershipPlanCreateInput, MembershipPlanUncheckedCreateInput>
    /**
     * In case the MembershipPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipPlanUpdateInput, MembershipPlanUncheckedUpdateInput>
  }

  /**
   * MembershipPlan delete
   */
  export type MembershipPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter which MembershipPlan to delete.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan deleteMany
   */
  export type MembershipPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipPlans to delete
     */
    where?: MembershipPlanWhereInput
    /**
     * Limit how many MembershipPlans to delete.
     */
    limit?: number
  }

  /**
   * MembershipPlan.memberships
   */
  export type MembershipPlan$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymMembership
     */
    omit?: GymMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    where?: GymMembershipWhereInput
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    cursor?: GymMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * MembershipPlan.payments
   */
  export type MembershipPlan$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * MembershipPlan without action
   */
  export type MembershipPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
  }


  /**
   * Model DayPass
   */

  export type AggregateDayPass = {
    _count: DayPassCountAggregateOutputType | null
    _avg: DayPassAvgAggregateOutputType | null
    _sum: DayPassSumAggregateOutputType | null
    _min: DayPassMinAggregateOutputType | null
    _max: DayPassMaxAggregateOutputType | null
  }

  export type DayPassAvgAggregateOutputType = {
    price: number | null
  }

  export type DayPassSumAggregateOutputType = {
    price: number | null
  }

  export type DayPassMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    gymId: string | null
    gymName: string | null
    purchaseDate: Date | null
    validDate: Date | null
    price: number | null
    status: string | null
    qrCode: string | null
  }

  export type DayPassMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    gymId: string | null
    gymName: string | null
    purchaseDate: Date | null
    validDate: Date | null
    price: number | null
    status: string | null
    qrCode: string | null
  }

  export type DayPassCountAggregateOutputType = {
    id: number
    studentId: number
    gymId: number
    gymName: number
    purchaseDate: number
    validDate: number
    price: number
    status: number
    qrCode: number
    _all: number
  }


  export type DayPassAvgAggregateInputType = {
    price?: true
  }

  export type DayPassSumAggregateInputType = {
    price?: true
  }

  export type DayPassMinAggregateInputType = {
    id?: true
    studentId?: true
    gymId?: true
    gymName?: true
    purchaseDate?: true
    validDate?: true
    price?: true
    status?: true
    qrCode?: true
  }

  export type DayPassMaxAggregateInputType = {
    id?: true
    studentId?: true
    gymId?: true
    gymName?: true
    purchaseDate?: true
    validDate?: true
    price?: true
    status?: true
    qrCode?: true
  }

  export type DayPassCountAggregateInputType = {
    id?: true
    studentId?: true
    gymId?: true
    gymName?: true
    purchaseDate?: true
    validDate?: true
    price?: true
    status?: true
    qrCode?: true
    _all?: true
  }

  export type DayPassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayPass to aggregate.
     */
    where?: DayPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPasses to fetch.
     */
    orderBy?: DayPassOrderByWithRelationInput | DayPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DayPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DayPasses
    **/
    _count?: true | DayPassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DayPassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DayPassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DayPassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DayPassMaxAggregateInputType
  }

  export type GetDayPassAggregateType<T extends DayPassAggregateArgs> = {
        [P in keyof T & keyof AggregateDayPass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDayPass[P]>
      : GetScalarType<T[P], AggregateDayPass[P]>
  }




  export type DayPassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayPassWhereInput
    orderBy?: DayPassOrderByWithAggregationInput | DayPassOrderByWithAggregationInput[]
    by: DayPassScalarFieldEnum[] | DayPassScalarFieldEnum
    having?: DayPassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DayPassCountAggregateInputType | true
    _avg?: DayPassAvgAggregateInputType
    _sum?: DayPassSumAggregateInputType
    _min?: DayPassMinAggregateInputType
    _max?: DayPassMaxAggregateInputType
  }

  export type DayPassGroupByOutputType = {
    id: string
    studentId: string
    gymId: string
    gymName: string
    purchaseDate: Date
    validDate: Date
    price: number
    status: string
    qrCode: string | null
    _count: DayPassCountAggregateOutputType | null
    _avg: DayPassAvgAggregateOutputType | null
    _sum: DayPassSumAggregateOutputType | null
    _min: DayPassMinAggregateOutputType | null
    _max: DayPassMaxAggregateOutputType | null
  }

  type GetDayPassGroupByPayload<T extends DayPassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DayPassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DayPassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DayPassGroupByOutputType[P]>
            : GetScalarType<T[P], DayPassGroupByOutputType[P]>
        }
      >
    >


  export type DayPassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    gymId?: boolean
    gymName?: boolean
    purchaseDate?: boolean
    validDate?: boolean
    price?: boolean
    status?: boolean
    qrCode?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayPass"]>

  export type DayPassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    gymId?: boolean
    gymName?: boolean
    purchaseDate?: boolean
    validDate?: boolean
    price?: boolean
    status?: boolean
    qrCode?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayPass"]>

  export type DayPassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    gymId?: boolean
    gymName?: boolean
    purchaseDate?: boolean
    validDate?: boolean
    price?: boolean
    status?: boolean
    qrCode?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dayPass"]>

  export type DayPassSelectScalar = {
    id?: boolean
    studentId?: boolean
    gymId?: boolean
    gymName?: boolean
    purchaseDate?: boolean
    validDate?: boolean
    price?: boolean
    status?: boolean
    qrCode?: boolean
  }

  export type DayPassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "gymId" | "gymName" | "purchaseDate" | "validDate" | "price" | "status" | "qrCode", ExtArgs["result"]["dayPass"]>
  export type DayPassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type DayPassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type DayPassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $DayPassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DayPass"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      gymId: string
      gymName: string
      purchaseDate: Date
      validDate: Date
      price: number
      status: string
      qrCode: string | null
    }, ExtArgs["result"]["dayPass"]>
    composites: {}
  }

  type DayPassGetPayload<S extends boolean | null | undefined | DayPassDefaultArgs> = $Result.GetResult<Prisma.$DayPassPayload, S>

  type DayPassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DayPassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DayPassCountAggregateInputType | true
    }

  export interface DayPassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DayPass'], meta: { name: 'DayPass' } }
    /**
     * Find zero or one DayPass that matches the filter.
     * @param {DayPassFindUniqueArgs} args - Arguments to find a DayPass
     * @example
     * // Get one DayPass
     * const dayPass = await prisma.dayPass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DayPassFindUniqueArgs>(args: SelectSubset<T, DayPassFindUniqueArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DayPass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DayPassFindUniqueOrThrowArgs} args - Arguments to find a DayPass
     * @example
     * // Get one DayPass
     * const dayPass = await prisma.dayPass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DayPassFindUniqueOrThrowArgs>(args: SelectSubset<T, DayPassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayPass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassFindFirstArgs} args - Arguments to find a DayPass
     * @example
     * // Get one DayPass
     * const dayPass = await prisma.dayPass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DayPassFindFirstArgs>(args?: SelectSubset<T, DayPassFindFirstArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayPass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassFindFirstOrThrowArgs} args - Arguments to find a DayPass
     * @example
     * // Get one DayPass
     * const dayPass = await prisma.dayPass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DayPassFindFirstOrThrowArgs>(args?: SelectSubset<T, DayPassFindFirstOrThrowArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DayPasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DayPasses
     * const dayPasses = await prisma.dayPass.findMany()
     * 
     * // Get first 10 DayPasses
     * const dayPasses = await prisma.dayPass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dayPassWithIdOnly = await prisma.dayPass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DayPassFindManyArgs>(args?: SelectSubset<T, DayPassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DayPass.
     * @param {DayPassCreateArgs} args - Arguments to create a DayPass.
     * @example
     * // Create one DayPass
     * const DayPass = await prisma.dayPass.create({
     *   data: {
     *     // ... data to create a DayPass
     *   }
     * })
     * 
     */
    create<T extends DayPassCreateArgs>(args: SelectSubset<T, DayPassCreateArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DayPasses.
     * @param {DayPassCreateManyArgs} args - Arguments to create many DayPasses.
     * @example
     * // Create many DayPasses
     * const dayPass = await prisma.dayPass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DayPassCreateManyArgs>(args?: SelectSubset<T, DayPassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DayPasses and returns the data saved in the database.
     * @param {DayPassCreateManyAndReturnArgs} args - Arguments to create many DayPasses.
     * @example
     * // Create many DayPasses
     * const dayPass = await prisma.dayPass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DayPasses and only return the `id`
     * const dayPassWithIdOnly = await prisma.dayPass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DayPassCreateManyAndReturnArgs>(args?: SelectSubset<T, DayPassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DayPass.
     * @param {DayPassDeleteArgs} args - Arguments to delete one DayPass.
     * @example
     * // Delete one DayPass
     * const DayPass = await prisma.dayPass.delete({
     *   where: {
     *     // ... filter to delete one DayPass
     *   }
     * })
     * 
     */
    delete<T extends DayPassDeleteArgs>(args: SelectSubset<T, DayPassDeleteArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DayPass.
     * @param {DayPassUpdateArgs} args - Arguments to update one DayPass.
     * @example
     * // Update one DayPass
     * const dayPass = await prisma.dayPass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DayPassUpdateArgs>(args: SelectSubset<T, DayPassUpdateArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DayPasses.
     * @param {DayPassDeleteManyArgs} args - Arguments to filter DayPasses to delete.
     * @example
     * // Delete a few DayPasses
     * const { count } = await prisma.dayPass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DayPassDeleteManyArgs>(args?: SelectSubset<T, DayPassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayPasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DayPasses
     * const dayPass = await prisma.dayPass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DayPassUpdateManyArgs>(args: SelectSubset<T, DayPassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayPasses and returns the data updated in the database.
     * @param {DayPassUpdateManyAndReturnArgs} args - Arguments to update many DayPasses.
     * @example
     * // Update many DayPasses
     * const dayPass = await prisma.dayPass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DayPasses and only return the `id`
     * const dayPassWithIdOnly = await prisma.dayPass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DayPassUpdateManyAndReturnArgs>(args: SelectSubset<T, DayPassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DayPass.
     * @param {DayPassUpsertArgs} args - Arguments to update or create a DayPass.
     * @example
     * // Update or create a DayPass
     * const dayPass = await prisma.dayPass.upsert({
     *   create: {
     *     // ... data to create a DayPass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DayPass we want to update
     *   }
     * })
     */
    upsert<T extends DayPassUpsertArgs>(args: SelectSubset<T, DayPassUpsertArgs<ExtArgs>>): Prisma__DayPassClient<$Result.GetResult<Prisma.$DayPassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DayPasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassCountArgs} args - Arguments to filter DayPasses to count.
     * @example
     * // Count the number of DayPasses
     * const count = await prisma.dayPass.count({
     *   where: {
     *     // ... the filter for the DayPasses we want to count
     *   }
     * })
    **/
    count<T extends DayPassCountArgs>(
      args?: Subset<T, DayPassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DayPassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DayPass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DayPassAggregateArgs>(args: Subset<T, DayPassAggregateArgs>): Prisma.PrismaPromise<GetDayPassAggregateType<T>>

    /**
     * Group by DayPass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayPassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DayPassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DayPassGroupByArgs['orderBy'] }
        : { orderBy?: DayPassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DayPassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDayPassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DayPass model
   */
  readonly fields: DayPassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DayPass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DayPassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DayPass model
   */
  interface DayPassFieldRefs {
    readonly id: FieldRef<"DayPass", 'String'>
    readonly studentId: FieldRef<"DayPass", 'String'>
    readonly gymId: FieldRef<"DayPass", 'String'>
    readonly gymName: FieldRef<"DayPass", 'String'>
    readonly purchaseDate: FieldRef<"DayPass", 'DateTime'>
    readonly validDate: FieldRef<"DayPass", 'DateTime'>
    readonly price: FieldRef<"DayPass", 'Float'>
    readonly status: FieldRef<"DayPass", 'String'>
    readonly qrCode: FieldRef<"DayPass", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DayPass findUnique
   */
  export type DayPassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * Filter, which DayPass to fetch.
     */
    where: DayPassWhereUniqueInput
  }

  /**
   * DayPass findUniqueOrThrow
   */
  export type DayPassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * Filter, which DayPass to fetch.
     */
    where: DayPassWhereUniqueInput
  }

  /**
   * DayPass findFirst
   */
  export type DayPassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * Filter, which DayPass to fetch.
     */
    where?: DayPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPasses to fetch.
     */
    orderBy?: DayPassOrderByWithRelationInput | DayPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayPasses.
     */
    cursor?: DayPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayPasses.
     */
    distinct?: DayPassScalarFieldEnum | DayPassScalarFieldEnum[]
  }

  /**
   * DayPass findFirstOrThrow
   */
  export type DayPassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * Filter, which DayPass to fetch.
     */
    where?: DayPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPasses to fetch.
     */
    orderBy?: DayPassOrderByWithRelationInput | DayPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayPasses.
     */
    cursor?: DayPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayPasses.
     */
    distinct?: DayPassScalarFieldEnum | DayPassScalarFieldEnum[]
  }

  /**
   * DayPass findMany
   */
  export type DayPassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * Filter, which DayPasses to fetch.
     */
    where?: DayPassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayPasses to fetch.
     */
    orderBy?: DayPassOrderByWithRelationInput | DayPassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DayPasses.
     */
    cursor?: DayPassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayPasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayPasses.
     */
    skip?: number
    distinct?: DayPassScalarFieldEnum | DayPassScalarFieldEnum[]
  }

  /**
   * DayPass create
   */
  export type DayPassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * The data needed to create a DayPass.
     */
    data: XOR<DayPassCreateInput, DayPassUncheckedCreateInput>
  }

  /**
   * DayPass createMany
   */
  export type DayPassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DayPasses.
     */
    data: DayPassCreateManyInput | DayPassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DayPass createManyAndReturn
   */
  export type DayPassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * The data used to create many DayPasses.
     */
    data: DayPassCreateManyInput | DayPassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DayPass update
   */
  export type DayPassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * The data needed to update a DayPass.
     */
    data: XOR<DayPassUpdateInput, DayPassUncheckedUpdateInput>
    /**
     * Choose, which DayPass to update.
     */
    where: DayPassWhereUniqueInput
  }

  /**
   * DayPass updateMany
   */
  export type DayPassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DayPasses.
     */
    data: XOR<DayPassUpdateManyMutationInput, DayPassUncheckedUpdateManyInput>
    /**
     * Filter which DayPasses to update
     */
    where?: DayPassWhereInput
    /**
     * Limit how many DayPasses to update.
     */
    limit?: number
  }

  /**
   * DayPass updateManyAndReturn
   */
  export type DayPassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * The data used to update DayPasses.
     */
    data: XOR<DayPassUpdateManyMutationInput, DayPassUncheckedUpdateManyInput>
    /**
     * Filter which DayPasses to update
     */
    where?: DayPassWhereInput
    /**
     * Limit how many DayPasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DayPass upsert
   */
  export type DayPassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * The filter to search for the DayPass to update in case it exists.
     */
    where: DayPassWhereUniqueInput
    /**
     * In case the DayPass found by the `where` argument doesn't exist, create a new DayPass with this data.
     */
    create: XOR<DayPassCreateInput, DayPassUncheckedCreateInput>
    /**
     * In case the DayPass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DayPassUpdateInput, DayPassUncheckedUpdateInput>
  }

  /**
   * DayPass delete
   */
  export type DayPassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
    /**
     * Filter which DayPass to delete.
     */
    where: DayPassWhereUniqueInput
  }

  /**
   * DayPass deleteMany
   */
  export type DayPassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayPasses to delete
     */
    where?: DayPassWhereInput
    /**
     * Limit how many DayPasses to delete.
     */
    limit?: number
  }

  /**
   * DayPass without action
   */
  export type DayPassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayPass
     */
    select?: DayPassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayPass
     */
    omit?: DayPassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DayPassInclude<ExtArgs> | null
  }


  /**
   * Model CheckIn
   */

  export type AggregateCheckIn = {
    _count: CheckInCountAggregateOutputType | null
    _avg: CheckInAvgAggregateOutputType | null
    _sum: CheckInSumAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  export type CheckInAvgAggregateOutputType = {
    duration: number | null
  }

  export type CheckInSumAggregateOutputType = {
    duration: number | null
  }

  export type CheckInMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    studentId: string | null
    studentName: string | null
    timestamp: Date | null
    checkOut: Date | null
    duration: number | null
  }

  export type CheckInMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    studentId: string | null
    studentName: string | null
    timestamp: Date | null
    checkOut: Date | null
    duration: number | null
  }

  export type CheckInCountAggregateOutputType = {
    id: number
    gymId: number
    studentId: number
    studentName: number
    timestamp: number
    checkOut: number
    duration: number
    _all: number
  }


  export type CheckInAvgAggregateInputType = {
    duration?: true
  }

  export type CheckInSumAggregateInputType = {
    duration?: true
  }

  export type CheckInMinAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    studentName?: true
    timestamp?: true
    checkOut?: true
    duration?: true
  }

  export type CheckInMaxAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    studentName?: true
    timestamp?: true
    checkOut?: true
    duration?: true
  }

  export type CheckInCountAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    studentName?: true
    timestamp?: true
    checkOut?: true
    duration?: true
    _all?: true
  }

  export type CheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIn to aggregate.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckIns
    **/
    _count?: true | CheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckInAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckInSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckInMaxAggregateInputType
  }

  export type GetCheckInAggregateType<T extends CheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckIn[P]>
      : GetScalarType<T[P], AggregateCheckIn[P]>
  }




  export type CheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithAggregationInput | CheckInOrderByWithAggregationInput[]
    by: CheckInScalarFieldEnum[] | CheckInScalarFieldEnum
    having?: CheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckInCountAggregateInputType | true
    _avg?: CheckInAvgAggregateInputType
    _sum?: CheckInSumAggregateInputType
    _min?: CheckInMinAggregateInputType
    _max?: CheckInMaxAggregateInputType
  }

  export type CheckInGroupByOutputType = {
    id: string
    gymId: string
    studentId: string
    studentName: string
    timestamp: Date
    checkOut: Date | null
    duration: number | null
    _count: CheckInCountAggregateOutputType | null
    _avg: CheckInAvgAggregateOutputType | null
    _sum: CheckInSumAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  type GetCheckInGroupByPayload<T extends CheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckInGroupByOutputType[P]>
            : GetScalarType<T[P], CheckInGroupByOutputType[P]>
        }
      >
    >


  export type CheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    timestamp?: boolean
    checkOut?: boolean
    duration?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    timestamp?: boolean
    checkOut?: boolean
    duration?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    timestamp?: boolean
    checkOut?: boolean
    duration?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectScalar = {
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    timestamp?: boolean
    checkOut?: boolean
    duration?: boolean
  }

  export type CheckInOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "studentId" | "studentName" | "timestamp" | "checkOut" | "duration", ExtArgs["result"]["checkIn"]>
  export type CheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type CheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type CheckInIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $CheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckIn"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      studentId: string
      studentName: string
      timestamp: Date
      checkOut: Date | null
      duration: number | null
    }, ExtArgs["result"]["checkIn"]>
    composites: {}
  }

  type CheckInGetPayload<S extends boolean | null | undefined | CheckInDefaultArgs> = $Result.GetResult<Prisma.$CheckInPayload, S>

  type CheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckInFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckInCountAggregateInputType | true
    }

  export interface CheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckIn'], meta: { name: 'CheckIn' } }
    /**
     * Find zero or one CheckIn that matches the filter.
     * @param {CheckInFindUniqueArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckInFindUniqueArgs>(args: SelectSubset<T, CheckInFindUniqueArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CheckIn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckInFindUniqueOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckInFindFirstArgs>(args?: SelectSubset<T, CheckInFindFirstArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckIns
     * const checkIns = await prisma.checkIn.findMany()
     * 
     * // Get first 10 CheckIns
     * const checkIns = await prisma.checkIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkInWithIdOnly = await prisma.checkIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckInFindManyArgs>(args?: SelectSubset<T, CheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CheckIn.
     * @param {CheckInCreateArgs} args - Arguments to create a CheckIn.
     * @example
     * // Create one CheckIn
     * const CheckIn = await prisma.checkIn.create({
     *   data: {
     *     // ... data to create a CheckIn
     *   }
     * })
     * 
     */
    create<T extends CheckInCreateArgs>(args: SelectSubset<T, CheckInCreateArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CheckIns.
     * @param {CheckInCreateManyArgs} args - Arguments to create many CheckIns.
     * @example
     * // Create many CheckIns
     * const checkIn = await prisma.checkIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckInCreateManyArgs>(args?: SelectSubset<T, CheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckIns and returns the data saved in the database.
     * @param {CheckInCreateManyAndReturnArgs} args - Arguments to create many CheckIns.
     * @example
     * // Create many CheckIns
     * const checkIn = await prisma.checkIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckIns and only return the `id`
     * const checkInWithIdOnly = await prisma.checkIn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CheckIn.
     * @param {CheckInDeleteArgs} args - Arguments to delete one CheckIn.
     * @example
     * // Delete one CheckIn
     * const CheckIn = await prisma.checkIn.delete({
     *   where: {
     *     // ... filter to delete one CheckIn
     *   }
     * })
     * 
     */
    delete<T extends CheckInDeleteArgs>(args: SelectSubset<T, CheckInDeleteArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CheckIn.
     * @param {CheckInUpdateArgs} args - Arguments to update one CheckIn.
     * @example
     * // Update one CheckIn
     * const checkIn = await prisma.checkIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckInUpdateArgs>(args: SelectSubset<T, CheckInUpdateArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CheckIns.
     * @param {CheckInDeleteManyArgs} args - Arguments to filter CheckIns to delete.
     * @example
     * // Delete a few CheckIns
     * const { count } = await prisma.checkIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckInDeleteManyArgs>(args?: SelectSubset<T, CheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckIns
     * const checkIn = await prisma.checkIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckInUpdateManyArgs>(args: SelectSubset<T, CheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckIns and returns the data updated in the database.
     * @param {CheckInUpdateManyAndReturnArgs} args - Arguments to update many CheckIns.
     * @example
     * // Update many CheckIns
     * const checkIn = await prisma.checkIn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CheckIns and only return the `id`
     * const checkInWithIdOnly = await prisma.checkIn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CheckInUpdateManyAndReturnArgs>(args: SelectSubset<T, CheckInUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CheckIn.
     * @param {CheckInUpsertArgs} args - Arguments to update or create a CheckIn.
     * @example
     * // Update or create a CheckIn
     * const checkIn = await prisma.checkIn.upsert({
     *   create: {
     *     // ... data to create a CheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckIn we want to update
     *   }
     * })
     */
    upsert<T extends CheckInUpsertArgs>(args: SelectSubset<T, CheckInUpsertArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInCountArgs} args - Arguments to filter CheckIns to count.
     * @example
     * // Count the number of CheckIns
     * const count = await prisma.checkIn.count({
     *   where: {
     *     // ... the filter for the CheckIns we want to count
     *   }
     * })
    **/
    count<T extends CheckInCountArgs>(
      args?: Subset<T, CheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckInAggregateArgs>(args: Subset<T, CheckInAggregateArgs>): Prisma.PrismaPromise<GetCheckInAggregateType<T>>

    /**
     * Group by CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckInGroupByArgs['orderBy'] }
        : { orderBy?: CheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckIn model
   */
  readonly fields: CheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckIn model
   */
  interface CheckInFieldRefs {
    readonly id: FieldRef<"CheckIn", 'String'>
    readonly gymId: FieldRef<"CheckIn", 'String'>
    readonly studentId: FieldRef<"CheckIn", 'String'>
    readonly studentName: FieldRef<"CheckIn", 'String'>
    readonly timestamp: FieldRef<"CheckIn", 'DateTime'>
    readonly checkOut: FieldRef<"CheckIn", 'DateTime'>
    readonly duration: FieldRef<"CheckIn", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CheckIn findUnique
   */
  export type CheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findUniqueOrThrow
   */
  export type CheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findFirst
   */
  export type CheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn findFirstOrThrow
   */
  export type CheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn findMany
   */
  export type CheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIns to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn create
   */
  export type CheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckIn.
     */
    data: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
  }

  /**
   * CheckIn createMany
   */
  export type CheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckIns.
     */
    data: CheckInCreateManyInput | CheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckIn createManyAndReturn
   */
  export type CheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * The data used to create many CheckIns.
     */
    data: CheckInCreateManyInput | CheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckIn update
   */
  export type CheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckIn.
     */
    data: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
    /**
     * Choose, which CheckIn to update.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn updateMany
   */
  export type CheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckIns.
     */
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyInput>
    /**
     * Filter which CheckIns to update
     */
    where?: CheckInWhereInput
    /**
     * Limit how many CheckIns to update.
     */
    limit?: number
  }

  /**
   * CheckIn updateManyAndReturn
   */
  export type CheckInUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * The data used to update CheckIns.
     */
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyInput>
    /**
     * Filter which CheckIns to update
     */
    where?: CheckInWhereInput
    /**
     * Limit how many CheckIns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckIn upsert
   */
  export type CheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckIn to update in case it exists.
     */
    where: CheckInWhereUniqueInput
    /**
     * In case the CheckIn found by the `where` argument doesn't exist, create a new CheckIn with this data.
     */
    create: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
    /**
     * In case the CheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
  }

  /**
   * CheckIn delete
   */
  export type CheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter which CheckIn to delete.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn deleteMany
   */
  export type CheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIns to delete
     */
    where?: CheckInWhereInput
    /**
     * Limit how many CheckIns to delete.
     */
    limit?: number
  }

  /**
   * CheckIn without action
   */
  export type CheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    name: string | null
    type: string | null
    brand: string | null
    model: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    status: string | null
    currentUserId: string | null
    currentUserName: string | null
    currentStartTime: Date | null
    qrCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    name: string | null
    type: string | null
    brand: string | null
    model: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    status: string | null
    currentUserId: string | null
    currentUserName: string | null
    currentStartTime: Date | null
    qrCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    gymId: number
    name: number
    type: number
    brand: number
    model: number
    serialNumber: number
    purchaseDate: number
    lastMaintenance: number
    nextMaintenance: number
    status: number
    currentUserId: number
    currentUserName: number
    currentStartTime: number
    qrCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentMinAggregateInputType = {
    id?: true
    gymId?: true
    name?: true
    type?: true
    brand?: true
    model?: true
    serialNumber?: true
    purchaseDate?: true
    lastMaintenance?: true
    nextMaintenance?: true
    status?: true
    currentUserId?: true
    currentUserName?: true
    currentStartTime?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    gymId?: true
    name?: true
    type?: true
    brand?: true
    model?: true
    serialNumber?: true
    purchaseDate?: true
    lastMaintenance?: true
    nextMaintenance?: true
    status?: true
    currentUserId?: true
    currentUserName?: true
    currentStartTime?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    gymId?: true
    name?: true
    type?: true
    brand?: true
    model?: true
    serialNumber?: true
    purchaseDate?: true
    lastMaintenance?: true
    nextMaintenance?: true
    status?: true
    currentUserId?: true
    currentUserName?: true
    currentStartTime?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    gymId: string
    name: string
    type: string
    brand: string | null
    model: string | null
    serialNumber: string | null
    purchaseDate: Date | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    status: string
    currentUserId: string | null
    currentUserName: string | null
    currentStartTime: Date | null
    qrCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentCountAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    status?: boolean
    currentUserId?: boolean
    currentUserName?: boolean
    currentStartTime?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    maintenanceHistory?: boolean | Equipment$maintenanceHistoryArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    status?: boolean
    currentUserId?: boolean
    currentUserName?: boolean
    currentStartTime?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    status?: boolean
    currentUserId?: boolean
    currentUserName?: boolean
    currentStartTime?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    gymId?: boolean
    name?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    purchaseDate?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    status?: boolean
    currentUserId?: boolean
    currentUserName?: boolean
    currentStartTime?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "name" | "type" | "brand" | "model" | "serialNumber" | "purchaseDate" | "lastMaintenance" | "nextMaintenance" | "status" | "currentUserId" | "currentUserName" | "currentStartTime" | "qrCode" | "createdAt" | "updatedAt", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    maintenanceHistory?: boolean | Equipment$maintenanceHistoryArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
      maintenanceHistory: Prisma.$MaintenanceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      name: string
      type: string
      brand: string | null
      model: string | null
      serialNumber: string | null
      purchaseDate: Date | null
      lastMaintenance: Date | null
      nextMaintenance: Date | null
      status: string
      currentUserId: string | null
      currentUserName: string | null
      currentStartTime: Date | null
      qrCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenanceHistory<T extends Equipment$maintenanceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$maintenanceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly gymId: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'String'>
    readonly brand: FieldRef<"Equipment", 'String'>
    readonly model: FieldRef<"Equipment", 'String'>
    readonly serialNumber: FieldRef<"Equipment", 'String'>
    readonly purchaseDate: FieldRef<"Equipment", 'DateTime'>
    readonly lastMaintenance: FieldRef<"Equipment", 'DateTime'>
    readonly nextMaintenance: FieldRef<"Equipment", 'DateTime'>
    readonly status: FieldRef<"Equipment", 'String'>
    readonly currentUserId: FieldRef<"Equipment", 'String'>
    readonly currentUserName: FieldRef<"Equipment", 'String'>
    readonly currentStartTime: FieldRef<"Equipment", 'DateTime'>
    readonly qrCode: FieldRef<"Equipment", 'String'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.maintenanceHistory
   */
  export type Equipment$maintenanceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    where?: MaintenanceRecordWhereInput
    orderBy?: MaintenanceRecordOrderByWithRelationInput | MaintenanceRecordOrderByWithRelationInput[]
    cursor?: MaintenanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRecordScalarFieldEnum | MaintenanceRecordScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceRecord
   */

  export type AggregateMaintenanceRecord = {
    _count: MaintenanceRecordCountAggregateOutputType | null
    _avg: MaintenanceRecordAvgAggregateOutputType | null
    _sum: MaintenanceRecordSumAggregateOutputType | null
    _min: MaintenanceRecordMinAggregateOutputType | null
    _max: MaintenanceRecordMaxAggregateOutputType | null
  }

  export type MaintenanceRecordAvgAggregateOutputType = {
    cost: number | null
  }

  export type MaintenanceRecordSumAggregateOutputType = {
    cost: number | null
  }

  export type MaintenanceRecordMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    date: Date | null
    type: string | null
    description: string | null
    performedBy: string | null
    cost: number | null
    nextScheduled: Date | null
  }

  export type MaintenanceRecordMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    date: Date | null
    type: string | null
    description: string | null
    performedBy: string | null
    cost: number | null
    nextScheduled: Date | null
  }

  export type MaintenanceRecordCountAggregateOutputType = {
    id: number
    equipmentId: number
    date: number
    type: number
    description: number
    performedBy: number
    cost: number
    nextScheduled: number
    _all: number
  }


  export type MaintenanceRecordAvgAggregateInputType = {
    cost?: true
  }

  export type MaintenanceRecordSumAggregateInputType = {
    cost?: true
  }

  export type MaintenanceRecordMinAggregateInputType = {
    id?: true
    equipmentId?: true
    date?: true
    type?: true
    description?: true
    performedBy?: true
    cost?: true
    nextScheduled?: true
  }

  export type MaintenanceRecordMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    date?: true
    type?: true
    description?: true
    performedBy?: true
    cost?: true
    nextScheduled?: true
  }

  export type MaintenanceRecordCountAggregateInputType = {
    id?: true
    equipmentId?: true
    date?: true
    type?: true
    description?: true
    performedBy?: true
    cost?: true
    nextScheduled?: true
    _all?: true
  }

  export type MaintenanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRecord to aggregate.
     */
    where?: MaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRecords to fetch.
     */
    orderBy?: MaintenanceRecordOrderByWithRelationInput | MaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceRecords
    **/
    _count?: true | MaintenanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceRecordMaxAggregateInputType
  }

  export type GetMaintenanceRecordAggregateType<T extends MaintenanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceRecord[P]>
      : GetScalarType<T[P], AggregateMaintenanceRecord[P]>
  }




  export type MaintenanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRecordWhereInput
    orderBy?: MaintenanceRecordOrderByWithAggregationInput | MaintenanceRecordOrderByWithAggregationInput[]
    by: MaintenanceRecordScalarFieldEnum[] | MaintenanceRecordScalarFieldEnum
    having?: MaintenanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceRecordCountAggregateInputType | true
    _avg?: MaintenanceRecordAvgAggregateInputType
    _sum?: MaintenanceRecordSumAggregateInputType
    _min?: MaintenanceRecordMinAggregateInputType
    _max?: MaintenanceRecordMaxAggregateInputType
  }

  export type MaintenanceRecordGroupByOutputType = {
    id: string
    equipmentId: string
    date: Date
    type: string
    description: string | null
    performedBy: string | null
    cost: number | null
    nextScheduled: Date | null
    _count: MaintenanceRecordCountAggregateOutputType | null
    _avg: MaintenanceRecordAvgAggregateOutputType | null
    _sum: MaintenanceRecordSumAggregateOutputType | null
    _min: MaintenanceRecordMinAggregateOutputType | null
    _max: MaintenanceRecordMaxAggregateOutputType | null
  }

  type GetMaintenanceRecordGroupByPayload<T extends MaintenanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    cost?: boolean
    nextScheduled?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRecord"]>

  export type MaintenanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    cost?: boolean
    nextScheduled?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRecord"]>

  export type MaintenanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    cost?: boolean
    nextScheduled?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRecord"]>

  export type MaintenanceRecordSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    cost?: boolean
    nextScheduled?: boolean
  }

  export type MaintenanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentId" | "date" | "type" | "description" | "performedBy" | "cost" | "nextScheduled", ExtArgs["result"]["maintenanceRecord"]>
  export type MaintenanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $MaintenanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceRecord"
    objects: {
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      date: Date
      type: string
      description: string | null
      performedBy: string | null
      cost: number | null
      nextScheduled: Date | null
    }, ExtArgs["result"]["maintenanceRecord"]>
    composites: {}
  }

  type MaintenanceRecordGetPayload<S extends boolean | null | undefined | MaintenanceRecordDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceRecordPayload, S>

  type MaintenanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceRecordCountAggregateInputType | true
    }

  export interface MaintenanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceRecord'], meta: { name: 'MaintenanceRecord' } }
    /**
     * Find zero or one MaintenanceRecord that matches the filter.
     * @param {MaintenanceRecordFindUniqueArgs} args - Arguments to find a MaintenanceRecord
     * @example
     * // Get one MaintenanceRecord
     * const maintenanceRecord = await prisma.maintenanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceRecordFindUniqueArgs>(args: SelectSubset<T, MaintenanceRecordFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceRecordFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceRecord
     * @example
     * // Get one MaintenanceRecord
     * const maintenanceRecord = await prisma.maintenanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordFindFirstArgs} args - Arguments to find a MaintenanceRecord
     * @example
     * // Get one MaintenanceRecord
     * const maintenanceRecord = await prisma.maintenanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceRecordFindFirstArgs>(args?: SelectSubset<T, MaintenanceRecordFindFirstArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordFindFirstOrThrowArgs} args - Arguments to find a MaintenanceRecord
     * @example
     * // Get one MaintenanceRecord
     * const maintenanceRecord = await prisma.maintenanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceRecords
     * const maintenanceRecords = await prisma.maintenanceRecord.findMany()
     * 
     * // Get first 10 MaintenanceRecords
     * const maintenanceRecords = await prisma.maintenanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceRecordWithIdOnly = await prisma.maintenanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceRecordFindManyArgs>(args?: SelectSubset<T, MaintenanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceRecord.
     * @param {MaintenanceRecordCreateArgs} args - Arguments to create a MaintenanceRecord.
     * @example
     * // Create one MaintenanceRecord
     * const MaintenanceRecord = await prisma.maintenanceRecord.create({
     *   data: {
     *     // ... data to create a MaintenanceRecord
     *   }
     * })
     * 
     */
    create<T extends MaintenanceRecordCreateArgs>(args: SelectSubset<T, MaintenanceRecordCreateArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceRecords.
     * @param {MaintenanceRecordCreateManyArgs} args - Arguments to create many MaintenanceRecords.
     * @example
     * // Create many MaintenanceRecords
     * const maintenanceRecord = await prisma.maintenanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceRecordCreateManyArgs>(args?: SelectSubset<T, MaintenanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceRecords and returns the data saved in the database.
     * @param {MaintenanceRecordCreateManyAndReturnArgs} args - Arguments to create many MaintenanceRecords.
     * @example
     * // Create many MaintenanceRecords
     * const maintenanceRecord = await prisma.maintenanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceRecords and only return the `id`
     * const maintenanceRecordWithIdOnly = await prisma.maintenanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceRecord.
     * @param {MaintenanceRecordDeleteArgs} args - Arguments to delete one MaintenanceRecord.
     * @example
     * // Delete one MaintenanceRecord
     * const MaintenanceRecord = await prisma.maintenanceRecord.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceRecord
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceRecordDeleteArgs>(args: SelectSubset<T, MaintenanceRecordDeleteArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceRecord.
     * @param {MaintenanceRecordUpdateArgs} args - Arguments to update one MaintenanceRecord.
     * @example
     * // Update one MaintenanceRecord
     * const maintenanceRecord = await prisma.maintenanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceRecordUpdateArgs>(args: SelectSubset<T, MaintenanceRecordUpdateArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceRecords.
     * @param {MaintenanceRecordDeleteManyArgs} args - Arguments to filter MaintenanceRecords to delete.
     * @example
     * // Delete a few MaintenanceRecords
     * const { count } = await prisma.maintenanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceRecordDeleteManyArgs>(args?: SelectSubset<T, MaintenanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceRecords
     * const maintenanceRecord = await prisma.maintenanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceRecordUpdateManyArgs>(args: SelectSubset<T, MaintenanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRecords and returns the data updated in the database.
     * @param {MaintenanceRecordUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceRecords.
     * @example
     * // Update many MaintenanceRecords
     * const maintenanceRecord = await prisma.maintenanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceRecords and only return the `id`
     * const maintenanceRecordWithIdOnly = await prisma.maintenanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceRecord.
     * @param {MaintenanceRecordUpsertArgs} args - Arguments to update or create a MaintenanceRecord.
     * @example
     * // Update or create a MaintenanceRecord
     * const maintenanceRecord = await prisma.maintenanceRecord.upsert({
     *   create: {
     *     // ... data to create a MaintenanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceRecordUpsertArgs>(args: SelectSubset<T, MaintenanceRecordUpsertArgs<ExtArgs>>): Prisma__MaintenanceRecordClient<$Result.GetResult<Prisma.$MaintenanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordCountArgs} args - Arguments to filter MaintenanceRecords to count.
     * @example
     * // Count the number of MaintenanceRecords
     * const count = await prisma.maintenanceRecord.count({
     *   where: {
     *     // ... the filter for the MaintenanceRecords we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceRecordCountArgs>(
      args?: Subset<T, MaintenanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceRecordAggregateArgs>(args: Subset<T, MaintenanceRecordAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceRecordAggregateType<T>>

    /**
     * Group by MaintenanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceRecord model
   */
  readonly fields: MaintenanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceRecord model
   */
  interface MaintenanceRecordFieldRefs {
    readonly id: FieldRef<"MaintenanceRecord", 'String'>
    readonly equipmentId: FieldRef<"MaintenanceRecord", 'String'>
    readonly date: FieldRef<"MaintenanceRecord", 'DateTime'>
    readonly type: FieldRef<"MaintenanceRecord", 'String'>
    readonly description: FieldRef<"MaintenanceRecord", 'String'>
    readonly performedBy: FieldRef<"MaintenanceRecord", 'String'>
    readonly cost: FieldRef<"MaintenanceRecord", 'Float'>
    readonly nextScheduled: FieldRef<"MaintenanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceRecord findUnique
   */
  export type MaintenanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRecord to fetch.
     */
    where: MaintenanceRecordWhereUniqueInput
  }

  /**
   * MaintenanceRecord findUniqueOrThrow
   */
  export type MaintenanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRecord to fetch.
     */
    where: MaintenanceRecordWhereUniqueInput
  }

  /**
   * MaintenanceRecord findFirst
   */
  export type MaintenanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRecord to fetch.
     */
    where?: MaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRecords to fetch.
     */
    orderBy?: MaintenanceRecordOrderByWithRelationInput | MaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRecords.
     */
    cursor?: MaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRecords.
     */
    distinct?: MaintenanceRecordScalarFieldEnum | MaintenanceRecordScalarFieldEnum[]
  }

  /**
   * MaintenanceRecord findFirstOrThrow
   */
  export type MaintenanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRecord to fetch.
     */
    where?: MaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRecords to fetch.
     */
    orderBy?: MaintenanceRecordOrderByWithRelationInput | MaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRecords.
     */
    cursor?: MaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRecords.
     */
    distinct?: MaintenanceRecordScalarFieldEnum | MaintenanceRecordScalarFieldEnum[]
  }

  /**
   * MaintenanceRecord findMany
   */
  export type MaintenanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRecords to fetch.
     */
    where?: MaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRecords to fetch.
     */
    orderBy?: MaintenanceRecordOrderByWithRelationInput | MaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceRecords.
     */
    cursor?: MaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRecords.
     */
    skip?: number
    distinct?: MaintenanceRecordScalarFieldEnum | MaintenanceRecordScalarFieldEnum[]
  }

  /**
   * MaintenanceRecord create
   */
  export type MaintenanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceRecord.
     */
    data: XOR<MaintenanceRecordCreateInput, MaintenanceRecordUncheckedCreateInput>
  }

  /**
   * MaintenanceRecord createMany
   */
  export type MaintenanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceRecords.
     */
    data: MaintenanceRecordCreateManyInput | MaintenanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceRecord createManyAndReturn
   */
  export type MaintenanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceRecords.
     */
    data: MaintenanceRecordCreateManyInput | MaintenanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRecord update
   */
  export type MaintenanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceRecord.
     */
    data: XOR<MaintenanceRecordUpdateInput, MaintenanceRecordUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceRecord to update.
     */
    where: MaintenanceRecordWhereUniqueInput
  }

  /**
   * MaintenanceRecord updateMany
   */
  export type MaintenanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceRecords.
     */
    data: XOR<MaintenanceRecordUpdateManyMutationInput, MaintenanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRecords to update
     */
    where?: MaintenanceRecordWhereInput
    /**
     * Limit how many MaintenanceRecords to update.
     */
    limit?: number
  }

  /**
   * MaintenanceRecord updateManyAndReturn
   */
  export type MaintenanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceRecords.
     */
    data: XOR<MaintenanceRecordUpdateManyMutationInput, MaintenanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRecords to update
     */
    where?: MaintenanceRecordWhereInput
    /**
     * Limit how many MaintenanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRecord upsert
   */
  export type MaintenanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceRecord to update in case it exists.
     */
    where: MaintenanceRecordWhereUniqueInput
    /**
     * In case the MaintenanceRecord found by the `where` argument doesn't exist, create a new MaintenanceRecord with this data.
     */
    create: XOR<MaintenanceRecordCreateInput, MaintenanceRecordUncheckedCreateInput>
    /**
     * In case the MaintenanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceRecordUpdateInput, MaintenanceRecordUncheckedUpdateInput>
  }

  /**
   * MaintenanceRecord delete
   */
  export type MaintenanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceRecord to delete.
     */
    where: MaintenanceRecordWhereUniqueInput
  }

  /**
   * MaintenanceRecord deleteMany
   */
  export type MaintenanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRecords to delete
     */
    where?: MaintenanceRecordWhereInput
    /**
     * Limit how many MaintenanceRecords to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceRecord without action
   */
  export type MaintenanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRecord
     */
    select?: MaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRecord
     */
    omit?: MaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    studentId: string | null
    studentName: string | null
    planId: string | null
    amount: number | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    paymentMethod: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    studentId: string | null
    studentName: string | null
    planId: string | null
    amount: number | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    paymentMethod: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    gymId: number
    studentId: number
    studentName: number
    planId: number
    amount: number
    date: number
    dueDate: number
    status: number
    paymentMethod: number
    reference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    studentName?: true
    planId?: true
    amount?: true
    date?: true
    dueDate?: true
    status?: true
    paymentMethod?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    studentName?: true
    planId?: true
    amount?: true
    date?: true
    dueDate?: true
    status?: true
    paymentMethod?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    gymId?: true
    studentId?: true
    studentName?: true
    planId?: true
    amount?: true
    date?: true
    dueDate?: true
    status?: true
    paymentMethod?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    gymId: string
    studentId: string
    studentName: string
    planId: string | null
    amount: number
    date: Date
    dueDate: Date
    status: string
    paymentMethod: string | null
    reference: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    planId?: boolean
    amount?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    plan?: boolean | Payment$planArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    planId?: boolean
    amount?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    plan?: boolean | Payment$planArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    planId?: boolean
    amount?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    plan?: boolean | Payment$planArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    gymId?: boolean
    studentId?: boolean
    studentName?: boolean
    planId?: boolean
    amount?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "studentId" | "studentName" | "planId" | "amount" | "date" | "dueDate" | "status" | "paymentMethod" | "reference" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    plan?: boolean | Payment$planArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    plan?: boolean | Payment$planArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    plan?: boolean | Payment$planArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
      plan: Prisma.$MembershipPlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      studentId: string
      studentName: string
      planId: string | null
      amount: number
      date: Date
      dueDate: Date
      status: string
      paymentMethod: string | null
      reference: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends Payment$planArgs<ExtArgs> = {}>(args?: Subset<T, Payment$planArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly gymId: FieldRef<"Payment", 'String'>
    readonly studentId: FieldRef<"Payment", 'String'>
    readonly studentName: FieldRef<"Payment", 'String'>
    readonly planId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly date: FieldRef<"Payment", 'DateTime'>
    readonly dueDate: FieldRef<"Payment", 'DateTime'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.plan
   */
  export type Payment$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    where?: MembershipPlanWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    type: string | null
    description: string | null
    amount: number | null
    date: Date | null
    category: string | null
    createdAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    type: string | null
    description: string | null
    amount: number | null
    date: Date | null
    category: string | null
    createdAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    gymId: number
    type: number
    description: number
    amount: number
    date: number
    category: number
    createdAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    gymId?: true
    type?: true
    description?: true
    amount?: true
    date?: true
    category?: true
    createdAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    gymId?: true
    type?: true
    description?: true
    amount?: true
    date?: true
    category?: true
    createdAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    gymId?: true
    type?: true
    description?: true
    amount?: true
    date?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    gymId: string
    type: string
    description: string | null
    amount: number
    date: Date
    category: string | null
    createdAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    gymId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "type" | "description" | "amount" | "date" | "category" | "createdAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      type: string
      description: string | null
      amount: number
      date: Date
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly gymId: FieldRef<"Expense", 'String'>
    readonly type: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    isDefault: boolean | null
    cardBrand: string | null
    last4: string | null
    expiryMonth: number | null
    expiryYear: number | null
    holderName: string | null
    pixKey: string | null
    pixKeyType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    isDefault: boolean | null
    cardBrand: string | null
    last4: string | null
    expiryMonth: number | null
    expiryYear: number | null
    holderName: string | null
    pixKey: string | null
    pixKeyType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    isDefault: number
    cardBrand: number
    last4: number
    expiryMonth: number
    expiryYear: number
    holderName: number
    pixKey: number
    pixKeyType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    isDefault?: true
    cardBrand?: true
    last4?: true
    expiryMonth?: true
    expiryYear?: true
    holderName?: true
    pixKey?: true
    pixKeyType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    isDefault?: true
    cardBrand?: true
    last4?: true
    expiryMonth?: true
    expiryYear?: true
    holderName?: true
    pixKey?: true
    pixKeyType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    isDefault?: true
    cardBrand?: true
    last4?: true
    expiryMonth?: true
    expiryYear?: true
    holderName?: true
    pixKey?: true
    pixKeyType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    userId: string
    type: string
    isDefault: boolean
    cardBrand: string | null
    last4: string | null
    expiryMonth: number | null
    expiryYear: number | null
    holderName: string | null
    pixKey: string | null
    pixKeyType: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    isDefault?: boolean
    cardBrand?: boolean
    last4?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    holderName?: boolean
    pixKey?: boolean
    pixKeyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    isDefault?: boolean
    cardBrand?: boolean
    last4?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    holderName?: boolean
    pixKey?: boolean
    pixKeyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    isDefault?: boolean
    cardBrand?: boolean
    last4?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    holderName?: boolean
    pixKey?: boolean
    pixKeyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    isDefault?: boolean
    cardBrand?: boolean
    last4?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    holderName?: boolean
    pixKey?: boolean
    pixKeyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "isDefault" | "cardBrand" | "last4" | "expiryMonth" | "expiryYear" | "holderName" | "pixKey" | "pixKeyType" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      isDefault: boolean
      cardBrand: string | null
      last4: string | null
      expiryMonth: number | null
      expiryYear: number | null
      holderName: string | null
      pixKey: string | null
      pixKeyType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly userId: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'String'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly cardBrand: FieldRef<"PaymentMethod", 'String'>
    readonly last4: FieldRef<"PaymentMethod", 'String'>
    readonly expiryMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expiryYear: FieldRef<"PaymentMethod", 'Int'>
    readonly holderName: FieldRef<"PaymentMethod", 'String'>
    readonly pixKey: FieldRef<"PaymentMethod", 'String'>
    readonly pixKeyType: FieldRef<"PaymentMethod", 'String'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    friendId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    friendId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    userId: number
    friendId: number
    status: number
    createdAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    status?: true
    createdAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    status?: true
    createdAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    userId: string
    friendId: string
    status: string
    createdAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | StudentDefaultArgs<ExtArgs>
    friend?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | StudentDefaultArgs<ExtArgs>
    friend?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | StudentDefaultArgs<ExtArgs>
    friend?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type FriendshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "friendId" | "status" | "createdAt", ExtArgs["result"]["friendship"]>
  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StudentDefaultArgs<ExtArgs>
    friend?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StudentDefaultArgs<ExtArgs>
    friend?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StudentDefaultArgs<ExtArgs>
    friend?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      user: Prisma.$StudentPayload<ExtArgs>
      friend: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      friendId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships and returns the data updated in the database.
     * @param {FriendshipUpdateManyAndReturnArgs} args - Arguments to update many Friendships.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendshipUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    friend<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly userId: FieldRef<"Friendship", 'String'>
    readonly friendId: FieldRef<"Friendship", 'String'>
    readonly status: FieldRef<"Friendship", 'String'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to update.
     */
    limit?: number
  }

  /**
   * Friendship updateManyAndReturn
   */
  export type FriendshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to delete.
     */
    limit?: number
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    plan: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    abacatePayBillingId: string | null
    abacatePayCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    plan: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    abacatePayBillingId: string | null
    abacatePayCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    studentId: number
    plan: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    abacatePayBillingId: number
    abacatePayCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    studentId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    abacatePayBillingId?: true
    abacatePayCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    studentId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    abacatePayBillingId?: true
    abacatePayCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    studentId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    abacatePayBillingId?: true
    abacatePayCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    studentId: string
    plan: string
    status: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    abacatePayBillingId: string | null
    abacatePayCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    studentId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "plan" | "status" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "canceledAt" | "trialStart" | "trialEnd" | "abacatePayBillingId" | "abacatePayCustomerId" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      plan: string
      status: string
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      trialStart: Date | null
      trialEnd: Date | null
      abacatePayBillingId: string | null
      abacatePayCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly studentId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialStart: FieldRef<"Subscription", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscription", 'DateTime'>
    readonly abacatePayBillingId: FieldRef<"Subscription", 'String'>
    readonly abacatePayCustomerId: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model GymSubscription
   */

  export type AggregateGymSubscription = {
    _count: GymSubscriptionCountAggregateOutputType | null
    _avg: GymSubscriptionAvgAggregateOutputType | null
    _sum: GymSubscriptionSumAggregateOutputType | null
    _min: GymSubscriptionMinAggregateOutputType | null
    _max: GymSubscriptionMaxAggregateOutputType | null
  }

  export type GymSubscriptionAvgAggregateOutputType = {
    basePrice: number | null
    pricePerStudent: number | null
  }

  export type GymSubscriptionSumAggregateOutputType = {
    basePrice: number | null
    pricePerStudent: number | null
  }

  export type GymSubscriptionMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    plan: string | null
    billingPeriod: string | null
    status: string | null
    basePrice: number | null
    pricePerStudent: number | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    abacatePayBillingId: string | null
    abacatePayCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymSubscriptionMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    plan: string | null
    billingPeriod: string | null
    status: string | null
    basePrice: number | null
    pricePerStudent: number | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    abacatePayBillingId: string | null
    abacatePayCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymSubscriptionCountAggregateOutputType = {
    id: number
    gymId: number
    plan: number
    billingPeriod: number
    status: number
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    abacatePayBillingId: number
    abacatePayCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymSubscriptionAvgAggregateInputType = {
    basePrice?: true
    pricePerStudent?: true
  }

  export type GymSubscriptionSumAggregateInputType = {
    basePrice?: true
    pricePerStudent?: true
  }

  export type GymSubscriptionMinAggregateInputType = {
    id?: true
    gymId?: true
    plan?: true
    billingPeriod?: true
    status?: true
    basePrice?: true
    pricePerStudent?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    abacatePayBillingId?: true
    abacatePayCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymSubscriptionMaxAggregateInputType = {
    id?: true
    gymId?: true
    plan?: true
    billingPeriod?: true
    status?: true
    basePrice?: true
    pricePerStudent?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    abacatePayBillingId?: true
    abacatePayCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymSubscriptionCountAggregateInputType = {
    id?: true
    gymId?: true
    plan?: true
    billingPeriod?: true
    status?: true
    basePrice?: true
    pricePerStudent?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    abacatePayBillingId?: true
    abacatePayCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymSubscription to aggregate.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymSubscriptions
    **/
    _count?: true | GymSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymSubscriptionMaxAggregateInputType
  }

  export type GetGymSubscriptionAggregateType<T extends GymSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateGymSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymSubscription[P]>
      : GetScalarType<T[P], AggregateGymSubscription[P]>
  }




  export type GymSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymSubscriptionWhereInput
    orderBy?: GymSubscriptionOrderByWithAggregationInput | GymSubscriptionOrderByWithAggregationInput[]
    by: GymSubscriptionScalarFieldEnum[] | GymSubscriptionScalarFieldEnum
    having?: GymSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymSubscriptionCountAggregateInputType | true
    _avg?: GymSubscriptionAvgAggregateInputType
    _sum?: GymSubscriptionSumAggregateInputType
    _min?: GymSubscriptionMinAggregateInputType
    _max?: GymSubscriptionMaxAggregateInputType
  }

  export type GymSubscriptionGroupByOutputType = {
    id: string
    gymId: string
    plan: string
    billingPeriod: string
    status: string
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    abacatePayBillingId: string | null
    abacatePayCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GymSubscriptionCountAggregateOutputType | null
    _avg: GymSubscriptionAvgAggregateOutputType | null
    _sum: GymSubscriptionSumAggregateOutputType | null
    _min: GymSubscriptionMinAggregateOutputType | null
    _max: GymSubscriptionMaxAggregateOutputType | null
  }

  type GetGymSubscriptionGroupByPayload<T extends GymSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], GymSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type GymSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    plan?: boolean
    billingPeriod?: boolean
    status?: boolean
    basePrice?: boolean
    pricePerStudent?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymSubscription"]>

  export type GymSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    plan?: boolean
    billingPeriod?: boolean
    status?: boolean
    basePrice?: boolean
    pricePerStudent?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymSubscription"]>

  export type GymSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    plan?: boolean
    billingPeriod?: boolean
    status?: boolean
    basePrice?: boolean
    pricePerStudent?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymSubscription"]>

  export type GymSubscriptionSelectScalar = {
    id?: boolean
    gymId?: boolean
    plan?: boolean
    billingPeriod?: boolean
    status?: boolean
    basePrice?: boolean
    pricePerStudent?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    abacatePayBillingId?: boolean
    abacatePayCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "plan" | "billingPeriod" | "status" | "basePrice" | "pricePerStudent" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "canceledAt" | "trialStart" | "trialEnd" | "abacatePayBillingId" | "abacatePayCustomerId" | "createdAt" | "updatedAt", ExtArgs["result"]["gymSubscription"]>
  export type GymSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $GymSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymSubscription"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      plan: string
      billingPeriod: string
      status: string
      basePrice: number
      pricePerStudent: number
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      trialStart: Date | null
      trialEnd: Date | null
      abacatePayBillingId: string | null
      abacatePayCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymSubscription"]>
    composites: {}
  }

  type GymSubscriptionGetPayload<S extends boolean | null | undefined | GymSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$GymSubscriptionPayload, S>

  type GymSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymSubscriptionCountAggregateInputType | true
    }

  export interface GymSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymSubscription'], meta: { name: 'GymSubscription' } }
    /**
     * Find zero or one GymSubscription that matches the filter.
     * @param {GymSubscriptionFindUniqueArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymSubscriptionFindUniqueArgs>(args: SelectSubset<T, GymSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, GymSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionFindFirstArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymSubscriptionFindFirstArgs>(args?: SelectSubset<T, GymSubscriptionFindFirstArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionFindFirstOrThrowArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, GymSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymSubscriptions
     * const gymSubscriptions = await prisma.gymSubscription.findMany()
     * 
     * // Get first 10 GymSubscriptions
     * const gymSubscriptions = await prisma.gymSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymSubscriptionWithIdOnly = await prisma.gymSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymSubscriptionFindManyArgs>(args?: SelectSubset<T, GymSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymSubscription.
     * @param {GymSubscriptionCreateArgs} args - Arguments to create a GymSubscription.
     * @example
     * // Create one GymSubscription
     * const GymSubscription = await prisma.gymSubscription.create({
     *   data: {
     *     // ... data to create a GymSubscription
     *   }
     * })
     * 
     */
    create<T extends GymSubscriptionCreateArgs>(args: SelectSubset<T, GymSubscriptionCreateArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymSubscriptions.
     * @param {GymSubscriptionCreateManyArgs} args - Arguments to create many GymSubscriptions.
     * @example
     * // Create many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymSubscriptionCreateManyArgs>(args?: SelectSubset<T, GymSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymSubscriptions and returns the data saved in the database.
     * @param {GymSubscriptionCreateManyAndReturnArgs} args - Arguments to create many GymSubscriptions.
     * @example
     * // Create many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymSubscriptions and only return the `id`
     * const gymSubscriptionWithIdOnly = await prisma.gymSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, GymSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymSubscription.
     * @param {GymSubscriptionDeleteArgs} args - Arguments to delete one GymSubscription.
     * @example
     * // Delete one GymSubscription
     * const GymSubscription = await prisma.gymSubscription.delete({
     *   where: {
     *     // ... filter to delete one GymSubscription
     *   }
     * })
     * 
     */
    delete<T extends GymSubscriptionDeleteArgs>(args: SelectSubset<T, GymSubscriptionDeleteArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymSubscription.
     * @param {GymSubscriptionUpdateArgs} args - Arguments to update one GymSubscription.
     * @example
     * // Update one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymSubscriptionUpdateArgs>(args: SelectSubset<T, GymSubscriptionUpdateArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymSubscriptions.
     * @param {GymSubscriptionDeleteManyArgs} args - Arguments to filter GymSubscriptions to delete.
     * @example
     * // Delete a few GymSubscriptions
     * const { count } = await prisma.gymSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymSubscriptionDeleteManyArgs>(args?: SelectSubset<T, GymSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymSubscriptionUpdateManyArgs>(args: SelectSubset<T, GymSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymSubscriptions and returns the data updated in the database.
     * @param {GymSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many GymSubscriptions.
     * @example
     * // Update many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymSubscriptions and only return the `id`
     * const gymSubscriptionWithIdOnly = await prisma.gymSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, GymSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymSubscription.
     * @param {GymSubscriptionUpsertArgs} args - Arguments to update or create a GymSubscription.
     * @example
     * // Update or create a GymSubscription
     * const gymSubscription = await prisma.gymSubscription.upsert({
     *   create: {
     *     // ... data to create a GymSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymSubscription we want to update
     *   }
     * })
     */
    upsert<T extends GymSubscriptionUpsertArgs>(args: SelectSubset<T, GymSubscriptionUpsertArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionCountArgs} args - Arguments to filter GymSubscriptions to count.
     * @example
     * // Count the number of GymSubscriptions
     * const count = await prisma.gymSubscription.count({
     *   where: {
     *     // ... the filter for the GymSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends GymSubscriptionCountArgs>(
      args?: Subset<T, GymSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymSubscriptionAggregateArgs>(args: Subset<T, GymSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetGymSubscriptionAggregateType<T>>

    /**
     * Group by GymSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: GymSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymSubscription model
   */
  readonly fields: GymSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymSubscription model
   */
  interface GymSubscriptionFieldRefs {
    readonly id: FieldRef<"GymSubscription", 'String'>
    readonly gymId: FieldRef<"GymSubscription", 'String'>
    readonly plan: FieldRef<"GymSubscription", 'String'>
    readonly billingPeriod: FieldRef<"GymSubscription", 'String'>
    readonly status: FieldRef<"GymSubscription", 'String'>
    readonly basePrice: FieldRef<"GymSubscription", 'Float'>
    readonly pricePerStudent: FieldRef<"GymSubscription", 'Float'>
    readonly currentPeriodStart: FieldRef<"GymSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"GymSubscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"GymSubscription", 'Boolean'>
    readonly canceledAt: FieldRef<"GymSubscription", 'DateTime'>
    readonly trialStart: FieldRef<"GymSubscription", 'DateTime'>
    readonly trialEnd: FieldRef<"GymSubscription", 'DateTime'>
    readonly abacatePayBillingId: FieldRef<"GymSubscription", 'String'>
    readonly abacatePayCustomerId: FieldRef<"GymSubscription", 'String'>
    readonly createdAt: FieldRef<"GymSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"GymSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymSubscription findUnique
   */
  export type GymSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription findUniqueOrThrow
   */
  export type GymSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription findFirst
   */
  export type GymSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymSubscriptions.
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymSubscriptions.
     */
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymSubscription findFirstOrThrow
   */
  export type GymSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymSubscriptions.
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymSubscriptions.
     */
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymSubscription findMany
   */
  export type GymSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscriptions to fetch.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymSubscriptions.
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymSubscription create
   */
  export type GymSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a GymSubscription.
     */
    data: XOR<GymSubscriptionCreateInput, GymSubscriptionUncheckedCreateInput>
  }

  /**
   * GymSubscription createMany
   */
  export type GymSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymSubscriptions.
     */
    data: GymSubscriptionCreateManyInput | GymSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymSubscription createManyAndReturn
   */
  export type GymSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many GymSubscriptions.
     */
    data: GymSubscriptionCreateManyInput | GymSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymSubscription update
   */
  export type GymSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a GymSubscription.
     */
    data: XOR<GymSubscriptionUpdateInput, GymSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which GymSubscription to update.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription updateMany
   */
  export type GymSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymSubscriptions.
     */
    data: XOR<GymSubscriptionUpdateManyMutationInput, GymSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which GymSubscriptions to update
     */
    where?: GymSubscriptionWhereInput
    /**
     * Limit how many GymSubscriptions to update.
     */
    limit?: number
  }

  /**
   * GymSubscription updateManyAndReturn
   */
  export type GymSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update GymSubscriptions.
     */
    data: XOR<GymSubscriptionUpdateManyMutationInput, GymSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which GymSubscriptions to update
     */
    where?: GymSubscriptionWhereInput
    /**
     * Limit how many GymSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymSubscription upsert
   */
  export type GymSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the GymSubscription to update in case it exists.
     */
    where: GymSubscriptionWhereUniqueInput
    /**
     * In case the GymSubscription found by the `where` argument doesn't exist, create a new GymSubscription with this data.
     */
    create: XOR<GymSubscriptionCreateInput, GymSubscriptionUncheckedCreateInput>
    /**
     * In case the GymSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymSubscriptionUpdateInput, GymSubscriptionUncheckedUpdateInput>
  }

  /**
   * GymSubscription delete
   */
  export type GymSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which GymSubscription to delete.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription deleteMany
   */
  export type GymSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymSubscriptions to delete
     */
    where?: GymSubscriptionWhereInput
    /**
     * Limit how many GymSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * GymSubscription without action
   */
  export type GymSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymSubscription
     */
    omit?: GymSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionFeature
   */

  export type AggregateSubscriptionFeature = {
    _count: SubscriptionFeatureCountAggregateOutputType | null
    _min: SubscriptionFeatureMinAggregateOutputType | null
    _max: SubscriptionFeatureMaxAggregateOutputType | null
  }

  export type SubscriptionFeatureMinAggregateOutputType = {
    id: string | null
    featureKey: string | null
    name: string | null
    description: string | null
    category: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionFeatureMaxAggregateOutputType = {
    id: string | null
    featureKey: string | null
    name: string | null
    description: string | null
    category: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionFeatureCountAggregateOutputType = {
    id: number
    featureKey: number
    name: number
    description: number
    category: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionFeatureMinAggregateInputType = {
    id?: true
    featureKey?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionFeatureMaxAggregateInputType = {
    id?: true
    featureKey?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionFeatureCountAggregateInputType = {
    id?: true
    featureKey?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionFeature to aggregate.
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeatureOrderByWithRelationInput | SubscriptionFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionFeatures
    **/
    _count?: true | SubscriptionFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionFeatureMaxAggregateInputType
  }

  export type GetSubscriptionFeatureAggregateType<T extends SubscriptionFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionFeature[P]>
      : GetScalarType<T[P], AggregateSubscriptionFeature[P]>
  }




  export type SubscriptionFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionFeatureWhereInput
    orderBy?: SubscriptionFeatureOrderByWithAggregationInput | SubscriptionFeatureOrderByWithAggregationInput[]
    by: SubscriptionFeatureScalarFieldEnum[] | SubscriptionFeatureScalarFieldEnum
    having?: SubscriptionFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionFeatureCountAggregateInputType | true
    _min?: SubscriptionFeatureMinAggregateInputType
    _max?: SubscriptionFeatureMaxAggregateInputType
  }

  export type SubscriptionFeatureGroupByOutputType = {
    id: string
    featureKey: string
    name: string
    description: string | null
    category: string
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionFeatureCountAggregateOutputType | null
    _min: SubscriptionFeatureMinAggregateOutputType | null
    _max: SubscriptionFeatureMaxAggregateOutputType | null
  }

  type GetSubscriptionFeatureGroupByPayload<T extends SubscriptionFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionFeatureGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureKey?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionFeature"]>

  export type SubscriptionFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureKey?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionFeature"]>

  export type SubscriptionFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureKey?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionFeature"]>

  export type SubscriptionFeatureSelectScalar = {
    id?: boolean
    featureKey?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "featureKey" | "name" | "description" | "category" | "icon" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptionFeature"]>

  export type $SubscriptionFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionFeature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      featureKey: string
      name: string
      description: string | null
      category: string
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionFeature"]>
    composites: {}
  }

  type SubscriptionFeatureGetPayload<S extends boolean | null | undefined | SubscriptionFeatureDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionFeaturePayload, S>

  type SubscriptionFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionFeatureCountAggregateInputType | true
    }

  export interface SubscriptionFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionFeature'], meta: { name: 'SubscriptionFeature' } }
    /**
     * Find zero or one SubscriptionFeature that matches the filter.
     * @param {SubscriptionFeatureFindUniqueArgs} args - Arguments to find a SubscriptionFeature
     * @example
     * // Get one SubscriptionFeature
     * const subscriptionFeature = await prisma.subscriptionFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFeatureFindUniqueArgs>(args: SelectSubset<T, SubscriptionFeatureFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFeatureFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionFeature
     * @example
     * // Get one SubscriptionFeature
     * const subscriptionFeature = await prisma.subscriptionFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureFindFirstArgs} args - Arguments to find a SubscriptionFeature
     * @example
     * // Get one SubscriptionFeature
     * const subscriptionFeature = await prisma.subscriptionFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFeatureFindFirstArgs>(args?: SelectSubset<T, SubscriptionFeatureFindFirstArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureFindFirstOrThrowArgs} args - Arguments to find a SubscriptionFeature
     * @example
     * // Get one SubscriptionFeature
     * const subscriptionFeature = await prisma.subscriptionFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeature.findMany()
     * 
     * // Get first 10 SubscriptionFeatures
     * const subscriptionFeatures = await prisma.subscriptionFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionFeatureWithIdOnly = await prisma.subscriptionFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFeatureFindManyArgs>(args?: SelectSubset<T, SubscriptionFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionFeature.
     * @param {SubscriptionFeatureCreateArgs} args - Arguments to create a SubscriptionFeature.
     * @example
     * // Create one SubscriptionFeature
     * const SubscriptionFeature = await prisma.subscriptionFeature.create({
     *   data: {
     *     // ... data to create a SubscriptionFeature
     *   }
     * })
     * 
     */
    create<T extends SubscriptionFeatureCreateArgs>(args: SelectSubset<T, SubscriptionFeatureCreateArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionFeatures.
     * @param {SubscriptionFeatureCreateManyArgs} args - Arguments to create many SubscriptionFeatures.
     * @example
     * // Create many SubscriptionFeatures
     * const subscriptionFeature = await prisma.subscriptionFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionFeatureCreateManyArgs>(args?: SelectSubset<T, SubscriptionFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionFeatures and returns the data saved in the database.
     * @param {SubscriptionFeatureCreateManyAndReturnArgs} args - Arguments to create many SubscriptionFeatures.
     * @example
     * // Create many SubscriptionFeatures
     * const subscriptionFeature = await prisma.subscriptionFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionFeatures and only return the `id`
     * const subscriptionFeatureWithIdOnly = await prisma.subscriptionFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionFeature.
     * @param {SubscriptionFeatureDeleteArgs} args - Arguments to delete one SubscriptionFeature.
     * @example
     * // Delete one SubscriptionFeature
     * const SubscriptionFeature = await prisma.subscriptionFeature.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionFeature
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionFeatureDeleteArgs>(args: SelectSubset<T, SubscriptionFeatureDeleteArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionFeature.
     * @param {SubscriptionFeatureUpdateArgs} args - Arguments to update one SubscriptionFeature.
     * @example
     * // Update one SubscriptionFeature
     * const subscriptionFeature = await prisma.subscriptionFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionFeatureUpdateArgs>(args: SelectSubset<T, SubscriptionFeatureUpdateArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionFeatures.
     * @param {SubscriptionFeatureDeleteManyArgs} args - Arguments to filter SubscriptionFeatures to delete.
     * @example
     * // Delete a few SubscriptionFeatures
     * const { count } = await prisma.subscriptionFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionFeatureDeleteManyArgs>(args?: SelectSubset<T, SubscriptionFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionFeatures
     * const subscriptionFeature = await prisma.subscriptionFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionFeatureUpdateManyArgs>(args: SelectSubset<T, SubscriptionFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionFeatures and returns the data updated in the database.
     * @param {SubscriptionFeatureUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionFeatures.
     * @example
     * // Update many SubscriptionFeatures
     * const subscriptionFeature = await prisma.subscriptionFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionFeatures and only return the `id`
     * const subscriptionFeatureWithIdOnly = await prisma.subscriptionFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionFeature.
     * @param {SubscriptionFeatureUpsertArgs} args - Arguments to update or create a SubscriptionFeature.
     * @example
     * // Update or create a SubscriptionFeature
     * const subscriptionFeature = await prisma.subscriptionFeature.upsert({
     *   create: {
     *     // ... data to create a SubscriptionFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionFeature we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionFeatureUpsertArgs>(args: SelectSubset<T, SubscriptionFeatureUpsertArgs<ExtArgs>>): Prisma__SubscriptionFeatureClient<$Result.GetResult<Prisma.$SubscriptionFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureCountArgs} args - Arguments to filter SubscriptionFeatures to count.
     * @example
     * // Count the number of SubscriptionFeatures
     * const count = await prisma.subscriptionFeature.count({
     *   where: {
     *     // ... the filter for the SubscriptionFeatures we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionFeatureCountArgs>(
      args?: Subset<T, SubscriptionFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionFeatureAggregateArgs>(args: Subset<T, SubscriptionFeatureAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionFeatureAggregateType<T>>

    /**
     * Group by SubscriptionFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionFeatureGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionFeature model
   */
  readonly fields: SubscriptionFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionFeature model
   */
  interface SubscriptionFeatureFieldRefs {
    readonly id: FieldRef<"SubscriptionFeature", 'String'>
    readonly featureKey: FieldRef<"SubscriptionFeature", 'String'>
    readonly name: FieldRef<"SubscriptionFeature", 'String'>
    readonly description: FieldRef<"SubscriptionFeature", 'String'>
    readonly category: FieldRef<"SubscriptionFeature", 'String'>
    readonly icon: FieldRef<"SubscriptionFeature", 'String'>
    readonly createdAt: FieldRef<"SubscriptionFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionFeature findUnique
   */
  export type SubscriptionFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeature to fetch.
     */
    where: SubscriptionFeatureWhereUniqueInput
  }

  /**
   * SubscriptionFeature findUniqueOrThrow
   */
  export type SubscriptionFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeature to fetch.
     */
    where: SubscriptionFeatureWhereUniqueInput
  }

  /**
   * SubscriptionFeature findFirst
   */
  export type SubscriptionFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeature to fetch.
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeatureOrderByWithRelationInput | SubscriptionFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionFeatures.
     */
    cursor?: SubscriptionFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionFeatures.
     */
    distinct?: SubscriptionFeatureScalarFieldEnum | SubscriptionFeatureScalarFieldEnum[]
  }

  /**
   * SubscriptionFeature findFirstOrThrow
   */
  export type SubscriptionFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeature to fetch.
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeatureOrderByWithRelationInput | SubscriptionFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionFeatures.
     */
    cursor?: SubscriptionFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionFeatures.
     */
    distinct?: SubscriptionFeatureScalarFieldEnum | SubscriptionFeatureScalarFieldEnum[]
  }

  /**
   * SubscriptionFeature findMany
   */
  export type SubscriptionFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionFeatures to fetch.
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionFeatures to fetch.
     */
    orderBy?: SubscriptionFeatureOrderByWithRelationInput | SubscriptionFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionFeatures.
     */
    cursor?: SubscriptionFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionFeatures.
     */
    skip?: number
    distinct?: SubscriptionFeatureScalarFieldEnum | SubscriptionFeatureScalarFieldEnum[]
  }

  /**
   * SubscriptionFeature create
   */
  export type SubscriptionFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionFeature.
     */
    data: XOR<SubscriptionFeatureCreateInput, SubscriptionFeatureUncheckedCreateInput>
  }

  /**
   * SubscriptionFeature createMany
   */
  export type SubscriptionFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionFeatures.
     */
    data: SubscriptionFeatureCreateManyInput | SubscriptionFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionFeature createManyAndReturn
   */
  export type SubscriptionFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionFeatures.
     */
    data: SubscriptionFeatureCreateManyInput | SubscriptionFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionFeature update
   */
  export type SubscriptionFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionFeature.
     */
    data: XOR<SubscriptionFeatureUpdateInput, SubscriptionFeatureUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionFeature to update.
     */
    where: SubscriptionFeatureWhereUniqueInput
  }

  /**
   * SubscriptionFeature updateMany
   */
  export type SubscriptionFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionFeatures.
     */
    data: XOR<SubscriptionFeatureUpdateManyMutationInput, SubscriptionFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionFeatures to update
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * Limit how many SubscriptionFeatures to update.
     */
    limit?: number
  }

  /**
   * SubscriptionFeature updateManyAndReturn
   */
  export type SubscriptionFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionFeatures.
     */
    data: XOR<SubscriptionFeatureUpdateManyMutationInput, SubscriptionFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionFeatures to update
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * Limit how many SubscriptionFeatures to update.
     */
    limit?: number
  }

  /**
   * SubscriptionFeature upsert
   */
  export type SubscriptionFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionFeature to update in case it exists.
     */
    where: SubscriptionFeatureWhereUniqueInput
    /**
     * In case the SubscriptionFeature found by the `where` argument doesn't exist, create a new SubscriptionFeature with this data.
     */
    create: XOR<SubscriptionFeatureCreateInput, SubscriptionFeatureUncheckedCreateInput>
    /**
     * In case the SubscriptionFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionFeatureUpdateInput, SubscriptionFeatureUncheckedUpdateInput>
  }

  /**
   * SubscriptionFeature delete
   */
  export type SubscriptionFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
    /**
     * Filter which SubscriptionFeature to delete.
     */
    where: SubscriptionFeatureWhereUniqueInput
  }

  /**
   * SubscriptionFeature deleteMany
   */
  export type SubscriptionFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionFeatures to delete
     */
    where?: SubscriptionFeatureWhereInput
    /**
     * Limit how many SubscriptionFeatures to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionFeature without action
   */
  export type SubscriptionFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionFeature
     */
    select?: SubscriptionFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionFeature
     */
    omit?: SubscriptionFeatureOmit<ExtArgs> | null
  }


  /**
   * Model SubscriptionPayment
   */

  export type AggregateSubscriptionPayment = {
    _count: SubscriptionPaymentCountAggregateOutputType | null
    _avg: SubscriptionPaymentAvgAggregateOutputType | null
    _sum: SubscriptionPaymentSumAggregateOutputType | null
    _min: SubscriptionPaymentMinAggregateOutputType | null
    _max: SubscriptionPaymentMaxAggregateOutputType | null
  }

  export type SubscriptionPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type SubscriptionPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type SubscriptionPaymentMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    gymSubscriptionId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    paymentMethod: string | null
    abacatePayBillingId: string | null
    paidAt: Date | null
    failedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPaymentMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    gymSubscriptionId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    paymentMethod: string | null
    abacatePayBillingId: string | null
    paidAt: Date | null
    failedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPaymentCountAggregateOutputType = {
    id: number
    subscriptionId: number
    gymSubscriptionId: number
    amount: number
    currency: number
    status: number
    paymentMethod: number
    abacatePayBillingId: number
    paidAt: number
    failedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SubscriptionPaymentSumAggregateInputType = {
    amount?: true
  }

  export type SubscriptionPaymentMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    gymSubscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    abacatePayBillingId?: true
    paidAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPaymentMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    gymSubscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    abacatePayBillingId?: true
    paidAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPaymentCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    gymSubscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    abacatePayBillingId?: true
    paidAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPayment to aggregate.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPayments
    **/
    _count?: true | SubscriptionPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPaymentMaxAggregateInputType
  }

  export type GetSubscriptionPaymentAggregateType<T extends SubscriptionPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPayment[P]>
      : GetScalarType<T[P], AggregateSubscriptionPayment[P]>
  }




  export type SubscriptionPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPaymentWhereInput
    orderBy?: SubscriptionPaymentOrderByWithAggregationInput | SubscriptionPaymentOrderByWithAggregationInput[]
    by: SubscriptionPaymentScalarFieldEnum[] | SubscriptionPaymentScalarFieldEnum
    having?: SubscriptionPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPaymentCountAggregateInputType | true
    _avg?: SubscriptionPaymentAvgAggregateInputType
    _sum?: SubscriptionPaymentSumAggregateInputType
    _min?: SubscriptionPaymentMinAggregateInputType
    _max?: SubscriptionPaymentMaxAggregateInputType
  }

  export type SubscriptionPaymentGroupByOutputType = {
    id: string
    subscriptionId: string | null
    gymSubscriptionId: string | null
    amount: number
    currency: string
    status: string
    paymentMethod: string | null
    abacatePayBillingId: string | null
    paidAt: Date | null
    failedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPaymentCountAggregateOutputType | null
    _avg: SubscriptionPaymentAvgAggregateOutputType | null
    _sum: SubscriptionPaymentSumAggregateOutputType | null
    _min: SubscriptionPaymentMinAggregateOutputType | null
    _max: SubscriptionPaymentMaxAggregateOutputType | null
  }

  type GetSubscriptionPaymentGroupByPayload<T extends SubscriptionPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    gymSubscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    abacatePayBillingId?: boolean
    paidAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPayment"]>

  export type SubscriptionPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    gymSubscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    abacatePayBillingId?: boolean
    paidAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPayment"]>

  export type SubscriptionPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    gymSubscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    abacatePayBillingId?: boolean
    paidAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPayment"]>

  export type SubscriptionPaymentSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    gymSubscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    abacatePayBillingId?: boolean
    paidAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "gymSubscriptionId" | "amount" | "currency" | "status" | "paymentMethod" | "abacatePayBillingId" | "paidAt" | "failedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptionPayment"]>

  export type $SubscriptionPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPayment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string | null
      gymSubscriptionId: string | null
      amount: number
      currency: string
      status: string
      paymentMethod: string | null
      abacatePayBillingId: string | null
      paidAt: Date | null
      failedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPayment"]>
    composites: {}
  }

  type SubscriptionPaymentGetPayload<S extends boolean | null | undefined | SubscriptionPaymentDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPaymentPayload, S>

  type SubscriptionPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPaymentCountAggregateInputType | true
    }

  export interface SubscriptionPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPayment'], meta: { name: 'SubscriptionPayment' } }
    /**
     * Find zero or one SubscriptionPayment that matches the filter.
     * @param {SubscriptionPaymentFindUniqueArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPaymentFindUniqueArgs>(args: SelectSubset<T, SubscriptionPaymentFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPaymentFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentFindFirstArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPaymentFindFirstArgs>(args?: SelectSubset<T, SubscriptionPaymentFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPayments
     * const subscriptionPayments = await prisma.subscriptionPayment.findMany()
     * 
     * // Get first 10 SubscriptionPayments
     * const subscriptionPayments = await prisma.subscriptionPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPaymentWithIdOnly = await prisma.subscriptionPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPaymentFindManyArgs>(args?: SelectSubset<T, SubscriptionPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPayment.
     * @param {SubscriptionPaymentCreateArgs} args - Arguments to create a SubscriptionPayment.
     * @example
     * // Create one SubscriptionPayment
     * const SubscriptionPayment = await prisma.subscriptionPayment.create({
     *   data: {
     *     // ... data to create a SubscriptionPayment
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPaymentCreateArgs>(args: SelectSubset<T, SubscriptionPaymentCreateArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPayments.
     * @param {SubscriptionPaymentCreateManyArgs} args - Arguments to create many SubscriptionPayments.
     * @example
     * // Create many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPaymentCreateManyArgs>(args?: SelectSubset<T, SubscriptionPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPayments and returns the data saved in the database.
     * @param {SubscriptionPaymentCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPayments.
     * @example
     * // Create many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPayments and only return the `id`
     * const subscriptionPaymentWithIdOnly = await prisma.subscriptionPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPayment.
     * @param {SubscriptionPaymentDeleteArgs} args - Arguments to delete one SubscriptionPayment.
     * @example
     * // Delete one SubscriptionPayment
     * const SubscriptionPayment = await prisma.subscriptionPayment.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPayment
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPaymentDeleteArgs>(args: SelectSubset<T, SubscriptionPaymentDeleteArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPayment.
     * @param {SubscriptionPaymentUpdateArgs} args - Arguments to update one SubscriptionPayment.
     * @example
     * // Update one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPaymentUpdateArgs>(args: SelectSubset<T, SubscriptionPaymentUpdateArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPayments.
     * @param {SubscriptionPaymentDeleteManyArgs} args - Arguments to filter SubscriptionPayments to delete.
     * @example
     * // Delete a few SubscriptionPayments
     * const { count } = await prisma.subscriptionPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPaymentDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPaymentUpdateManyArgs>(args: SelectSubset<T, SubscriptionPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPayments and returns the data updated in the database.
     * @param {SubscriptionPaymentUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPayments.
     * @example
     * // Update many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPayments and only return the `id`
     * const subscriptionPaymentWithIdOnly = await prisma.subscriptionPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPayment.
     * @param {SubscriptionPaymentUpsertArgs} args - Arguments to update or create a SubscriptionPayment.
     * @example
     * // Update or create a SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPayment we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPaymentUpsertArgs>(args: SelectSubset<T, SubscriptionPaymentUpsertArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentCountArgs} args - Arguments to filter SubscriptionPayments to count.
     * @example
     * // Count the number of SubscriptionPayments
     * const count = await prisma.subscriptionPayment.count({
     *   where: {
     *     // ... the filter for the SubscriptionPayments we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPaymentCountArgs>(
      args?: Subset<T, SubscriptionPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPaymentAggregateArgs>(args: Subset<T, SubscriptionPaymentAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPaymentAggregateType<T>>

    /**
     * Group by SubscriptionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPayment model
   */
  readonly fields: SubscriptionPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPayment model
   */
  interface SubscriptionPaymentFieldRefs {
    readonly id: FieldRef<"SubscriptionPayment", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionPayment", 'String'>
    readonly gymSubscriptionId: FieldRef<"SubscriptionPayment", 'String'>
    readonly amount: FieldRef<"SubscriptionPayment", 'Float'>
    readonly currency: FieldRef<"SubscriptionPayment", 'String'>
    readonly status: FieldRef<"SubscriptionPayment", 'String'>
    readonly paymentMethod: FieldRef<"SubscriptionPayment", 'String'>
    readonly abacatePayBillingId: FieldRef<"SubscriptionPayment", 'String'>
    readonly paidAt: FieldRef<"SubscriptionPayment", 'DateTime'>
    readonly failedAt: FieldRef<"SubscriptionPayment", 'DateTime'>
    readonly createdAt: FieldRef<"SubscriptionPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPayment findUnique
   */
  export type SubscriptionPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment findUniqueOrThrow
   */
  export type SubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment findFirst
   */
  export type SubscriptionPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPayments.
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPayments.
     */
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * SubscriptionPayment findFirstOrThrow
   */
  export type SubscriptionPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPayments.
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPayments.
     */
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * SubscriptionPayment findMany
   */
  export type SubscriptionPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayments to fetch.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPayments.
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * SubscriptionPayment create
   */
  export type SubscriptionPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPayment.
     */
    data: XOR<SubscriptionPaymentCreateInput, SubscriptionPaymentUncheckedCreateInput>
  }

  /**
   * SubscriptionPayment createMany
   */
  export type SubscriptionPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPayments.
     */
    data: SubscriptionPaymentCreateManyInput | SubscriptionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPayment createManyAndReturn
   */
  export type SubscriptionPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPayments.
     */
    data: SubscriptionPaymentCreateManyInput | SubscriptionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPayment update
   */
  export type SubscriptionPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPayment.
     */
    data: XOR<SubscriptionPaymentUpdateInput, SubscriptionPaymentUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPayment to update.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment updateMany
   */
  export type SubscriptionPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPayments.
     */
    data: XOR<SubscriptionPaymentUpdateManyMutationInput, SubscriptionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPayments to update
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * Limit how many SubscriptionPayments to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPayment updateManyAndReturn
   */
  export type SubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPayments.
     */
    data: XOR<SubscriptionPaymentUpdateManyMutationInput, SubscriptionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPayments to update
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * Limit how many SubscriptionPayments to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPayment upsert
   */
  export type SubscriptionPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPayment to update in case it exists.
     */
    where: SubscriptionPaymentWhereUniqueInput
    /**
     * In case the SubscriptionPayment found by the `where` argument doesn't exist, create a new SubscriptionPayment with this data.
     */
    create: XOR<SubscriptionPaymentCreateInput, SubscriptionPaymentUncheckedCreateInput>
    /**
     * In case the SubscriptionPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPaymentUpdateInput, SubscriptionPaymentUncheckedUpdateInput>
  }

  /**
   * SubscriptionPayment delete
   */
  export type SubscriptionPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter which SubscriptionPayment to delete.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment deleteMany
   */
  export type SubscriptionPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPayments to delete
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * Limit how many SubscriptionPayments to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPayment without action
   */
  export type SubscriptionPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    activeGymId: 'activeGymId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    idToken: 'idToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sessionToken: 'sessionToken',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    age: 'age',
    gender: 'gender',
    phone: 'phone',
    avatar: 'avatar',
    isTrans: 'isTrans',
    usesHormones: 'usesHormones',
    hormoneType: 'hormoneType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const StudentProgressScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    totalXP: 'totalXP',
    currentLevel: 'currentLevel',
    xpToNextLevel: 'xpToNextLevel',
    workoutsCompleted: 'workoutsCompleted',
    lastActivityDate: 'lastActivityDate',
    dailyGoalXP: 'dailyGoalXP',
    todayXP: 'todayXP',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentProgressScalarFieldEnum = (typeof StudentProgressScalarFieldEnum)[keyof typeof StudentProgressScalarFieldEnum]


  export const StudentProfileScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    height: 'height',
    weight: 'weight',
    fitnessLevel: 'fitnessLevel',
    weeklyWorkoutFrequency: 'weeklyWorkoutFrequency',
    workoutDuration: 'workoutDuration',
    goals: 'goals',
    injuries: 'injuries',
    availableEquipment: 'availableEquipment',
    gymType: 'gymType',
    preferredWorkoutTime: 'preferredWorkoutTime',
    preferredSets: 'preferredSets',
    preferredRepRange: 'preferredRepRange',
    restTime: 'restTime',
    dietType: 'dietType',
    allergies: 'allergies',
    targetCalories: 'targetCalories',
    targetProtein: 'targetProtein',
    targetCarbs: 'targetCarbs',
    targetFats: 'targetFats',
    mealsPerDay: 'mealsPerDay',
    bmr: 'bmr',
    tdee: 'tdee',
    activityLevel: 'activityLevel',
    hormoneTreatmentDuration: 'hormoneTreatmentDuration',
    physicalLimitations: 'physicalLimitations',
    motorLimitations: 'motorLimitations',
    medicalConditions: 'medicalConditions',
    limitationDetails: 'limitationDetails',
    dailyAvailableHours: 'dailyAvailableHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentProfileScalarFieldEnum = (typeof StudentProfileScalarFieldEnum)[keyof typeof StudentProfileScalarFieldEnum]


  export const WeightHistoryScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    weight: 'weight',
    date: 'date',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeightHistoryScalarFieldEnum = (typeof WeightHistoryScalarFieldEnum)[keyof typeof WeightHistoryScalarFieldEnum]


  export const GymScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    logo: 'logo',
    address: 'address',
    phone: 'phone',
    email: 'email',
    cnpj: 'cnpj',
    plan: 'plan',
    isActive: 'isActive',
    latitude: 'latitude',
    longitude: 'longitude',
    rating: 'rating',
    totalReviews: 'totalReviews',
    amenities: 'amenities',
    openingHours: 'openingHours',
    photos: 'photos',
    isPartner: 'isPartner',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymScalarFieldEnum = (typeof GymScalarFieldEnum)[keyof typeof GymScalarFieldEnum]


  export const GymProfileScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    totalStudents: 'totalStudents',
    activeStudents: 'activeStudents',
    equipmentCount: 'equipmentCount',
    level: 'level',
    xp: 'xp',
    xpToNextLevel: 'xpToNextLevel',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    monthlyStudentGoal: 'monthlyStudentGoal',
    avgStudentFrequency: 'avgStudentFrequency',
    equipmentUtilization: 'equipmentUtilization',
    ranking: 'ranking',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymProfileScalarFieldEnum = (typeof GymProfileScalarFieldEnum)[keyof typeof GymProfileScalarFieldEnum]


  export const GymStatsScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    todayCheckins: 'todayCheckins',
    todayActiveStudents: 'todayActiveStudents',
    todayEquipmentInUse: 'todayEquipmentInUse',
    weekTotalCheckins: 'weekTotalCheckins',
    weekAvgDailyCheckins: 'weekAvgDailyCheckins',
    weekNewMembers: 'weekNewMembers',
    weekCanceledMembers: 'weekCanceledMembers',
    monthTotalCheckins: 'monthTotalCheckins',
    monthRetentionRate: 'monthRetentionRate',
    monthGrowthRate: 'monthGrowthRate',
    updatedAt: 'updatedAt'
  };

  export type GymStatsScalarFieldEnum = (typeof GymStatsScalarFieldEnum)[keyof typeof GymStatsScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    color: 'color',
    icon: 'icon',
    order: 'order',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const WorkoutScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    title: 'title',
    description: 'description',
    type: 'type',
    muscleGroup: 'muscleGroup',
    difficulty: 'difficulty',
    xpReward: 'xpReward',
    estimatedTime: 'estimatedTime',
    order: 'order',
    locked: 'locked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkoutScalarFieldEnum = (typeof WorkoutScalarFieldEnum)[keyof typeof WorkoutScalarFieldEnum]


  export const WorkoutExerciseScalarFieldEnum: {
    id: 'id',
    workoutId: 'workoutId',
    name: 'name',
    sets: 'sets',
    reps: 'reps',
    rest: 'rest',
    notes: 'notes',
    videoUrl: 'videoUrl',
    educationalId: 'educationalId',
    order: 'order',
    primaryMuscles: 'primaryMuscles',
    secondaryMuscles: 'secondaryMuscles',
    difficulty: 'difficulty',
    equipment: 'equipment',
    instructions: 'instructions',
    tips: 'tips',
    commonMistakes: 'commonMistakes',
    benefits: 'benefits',
    scientificEvidence: 'scientificEvidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkoutExerciseScalarFieldEnum = (typeof WorkoutExerciseScalarFieldEnum)[keyof typeof WorkoutExerciseScalarFieldEnum]


  export const AlternativeExerciseScalarFieldEnum: {
    id: 'id',
    workoutExerciseId: 'workoutExerciseId',
    name: 'name',
    reason: 'reason',
    educationalId: 'educationalId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlternativeExerciseScalarFieldEnum = (typeof AlternativeExerciseScalarFieldEnum)[keyof typeof AlternativeExerciseScalarFieldEnum]


  export const WorkoutProgressScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    workoutId: 'workoutId',
    currentExerciseIndex: 'currentExerciseIndex',
    exerciseLogs: 'exerciseLogs',
    skippedExercises: 'skippedExercises',
    selectedAlternatives: 'selectedAlternatives',
    xpEarned: 'xpEarned',
    totalVolume: 'totalVolume',
    completionPercentage: 'completionPercentage',
    startTime: 'startTime',
    cardioPreference: 'cardioPreference',
    cardioDuration: 'cardioDuration',
    selectedCardioType: 'selectedCardioType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkoutProgressScalarFieldEnum = (typeof WorkoutProgressScalarFieldEnum)[keyof typeof WorkoutProgressScalarFieldEnum]


  export const WorkoutHistoryScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    workoutId: 'workoutId',
    date: 'date',
    duration: 'duration',
    totalVolume: 'totalVolume',
    overallFeedback: 'overallFeedback',
    bodyPartsFatigued: 'bodyPartsFatigued',
    createdAt: 'createdAt'
  };

  export type WorkoutHistoryScalarFieldEnum = (typeof WorkoutHistoryScalarFieldEnum)[keyof typeof WorkoutHistoryScalarFieldEnum]


  export const ExerciseLogScalarFieldEnum: {
    id: 'id',
    workoutHistoryId: 'workoutHistoryId',
    exerciseId: 'exerciseId',
    exerciseName: 'exerciseName',
    sets: 'sets',
    notes: 'notes',
    formCheckScore: 'formCheckScore',
    difficulty: 'difficulty'
  };

  export type ExerciseLogScalarFieldEnum = (typeof ExerciseLogScalarFieldEnum)[keyof typeof ExerciseLogScalarFieldEnum]


  export const PersonalRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    workoutHistoryId: 'workoutHistoryId',
    exerciseId: 'exerciseId',
    exerciseName: 'exerciseName',
    type: 'type',
    value: 'value',
    date: 'date',
    previousBest: 'previousBest'
  };

  export type PersonalRecordScalarFieldEnum = (typeof PersonalRecordScalarFieldEnum)[keyof typeof PersonalRecordScalarFieldEnum]


  export const DietPlanScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    totalCalories: 'totalCalories',
    targetProtein: 'targetProtein',
    targetCarbs: 'targetCarbs',
    targetFats: 'targetFats',
    xpReward: 'xpReward',
    locked: 'locked',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DietPlanScalarFieldEnum = (typeof DietPlanScalarFieldEnum)[keyof typeof DietPlanScalarFieldEnum]


  export const MealScalarFieldEnum: {
    id: 'id',
    dietPlanId: 'dietPlanId',
    name: 'name',
    type: 'type',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    time: 'time',
    image: 'image',
    ingredients: 'ingredients',
    order: 'order'
  };

  export type MealScalarFieldEnum = (typeof MealScalarFieldEnum)[keyof typeof MealScalarFieldEnum]


  export const DietPlanCompletionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    dietPlanId: 'dietPlanId',
    date: 'date',
    completed: 'completed'
  };

  export type DietPlanCompletionScalarFieldEnum = (typeof DietPlanCompletionScalarFieldEnum)[keyof typeof DietPlanCompletionScalarFieldEnum]


  export const DailyNutritionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    date: 'date',
    waterIntake: 'waterIntake',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyNutritionScalarFieldEnum = (typeof DailyNutritionScalarFieldEnum)[keyof typeof DailyNutritionScalarFieldEnum]


  export const NutritionMealScalarFieldEnum: {
    id: 'id',
    dailyNutritionId: 'dailyNutritionId',
    name: 'name',
    type: 'type',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    time: 'time',
    completed: 'completed',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NutritionMealScalarFieldEnum = (typeof NutritionMealScalarFieldEnum)[keyof typeof NutritionMealScalarFieldEnum]


  export const NutritionFoodItemScalarFieldEnum: {
    id: 'id',
    nutritionMealId: 'nutritionMealId',
    foodId: 'foodId',
    foodName: 'foodName',
    servings: 'servings',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    servingSize: 'servingSize',
    createdAt: 'createdAt'
  };

  export type NutritionFoodItemScalarFieldEnum = (typeof NutritionFoodItemScalarFieldEnum)[keyof typeof NutritionFoodItemScalarFieldEnum]


  export const NutritionChatUsageScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    date: 'date',
    messageCount: 'messageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NutritionChatUsageScalarFieldEnum = (typeof NutritionChatUsageScalarFieldEnum)[keyof typeof NutritionChatUsageScalarFieldEnum]


  export const FoodItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    servingSize: 'servingSize',
    category: 'category',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodItemScalarFieldEnum = (typeof FoodItemScalarFieldEnum)[keyof typeof FoodItemScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon',
    category: 'category',
    level: 'level',
    color: 'color',
    target: 'target',
    xpReward: 'xpReward',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const AchievementUnlockScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    achievementId: 'achievementId',
    progress: 'progress',
    unlockedAt: 'unlockedAt'
  };

  export type AchievementUnlockScalarFieldEnum = (typeof AchievementUnlockScalarFieldEnum)[keyof typeof AchievementUnlockScalarFieldEnum]


  export const GymUserPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lastActiveGymId: 'lastActiveGymId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymUserPreferenceScalarFieldEnum = (typeof GymUserPreferenceScalarFieldEnum)[keyof typeof GymUserPreferenceScalarFieldEnum]


  export const GymMembershipScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    studentId: 'studentId',
    planId: 'planId',
    startDate: 'startDate',
    nextBillingDate: 'nextBillingDate',
    amount: 'amount',
    status: 'status',
    autoRenew: 'autoRenew',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymMembershipScalarFieldEnum = (typeof GymMembershipScalarFieldEnum)[keyof typeof GymMembershipScalarFieldEnum]


  export const MembershipPlanScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    name: 'name',
    type: 'type',
    price: 'price',
    duration: 'duration',
    benefits: 'benefits',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipPlanScalarFieldEnum = (typeof MembershipPlanScalarFieldEnum)[keyof typeof MembershipPlanScalarFieldEnum]


  export const DayPassScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    gymId: 'gymId',
    gymName: 'gymName',
    purchaseDate: 'purchaseDate',
    validDate: 'validDate',
    price: 'price',
    status: 'status',
    qrCode: 'qrCode'
  };

  export type DayPassScalarFieldEnum = (typeof DayPassScalarFieldEnum)[keyof typeof DayPassScalarFieldEnum]


  export const CheckInScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    studentId: 'studentId',
    studentName: 'studentName',
    timestamp: 'timestamp',
    checkOut: 'checkOut',
    duration: 'duration'
  };

  export type CheckInScalarFieldEnum = (typeof CheckInScalarFieldEnum)[keyof typeof CheckInScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    name: 'name',
    type: 'type',
    brand: 'brand',
    model: 'model',
    serialNumber: 'serialNumber',
    purchaseDate: 'purchaseDate',
    lastMaintenance: 'lastMaintenance',
    nextMaintenance: 'nextMaintenance',
    status: 'status',
    currentUserId: 'currentUserId',
    currentUserName: 'currentUserName',
    currentStartTime: 'currentStartTime',
    qrCode: 'qrCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const MaintenanceRecordScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    date: 'date',
    type: 'type',
    description: 'description',
    performedBy: 'performedBy',
    cost: 'cost',
    nextScheduled: 'nextScheduled'
  };

  export type MaintenanceRecordScalarFieldEnum = (typeof MaintenanceRecordScalarFieldEnum)[keyof typeof MaintenanceRecordScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    studentId: 'studentId',
    studentName: 'studentName',
    planId: 'planId',
    amount: 'amount',
    date: 'date',
    dueDate: 'dueDate',
    status: 'status',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    type: 'type',
    description: 'description',
    amount: 'amount',
    date: 'date',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    isDefault: 'isDefault',
    cardBrand: 'cardBrand',
    last4: 'last4',
    expiryMonth: 'expiryMonth',
    expiryYear: 'expiryYear',
    holderName: 'holderName',
    pixKey: 'pixKey',
    pixKeyType: 'pixKeyType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    friendId: 'friendId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    plan: 'plan',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    abacatePayBillingId: 'abacatePayBillingId',
    abacatePayCustomerId: 'abacatePayCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const GymSubscriptionScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    plan: 'plan',
    billingPeriod: 'billingPeriod',
    status: 'status',
    basePrice: 'basePrice',
    pricePerStudent: 'pricePerStudent',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    abacatePayBillingId: 'abacatePayBillingId',
    abacatePayCustomerId: 'abacatePayCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymSubscriptionScalarFieldEnum = (typeof GymSubscriptionScalarFieldEnum)[keyof typeof GymSubscriptionScalarFieldEnum]


  export const SubscriptionFeatureScalarFieldEnum: {
    id: 'id',
    featureKey: 'featureKey',
    name: 'name',
    description: 'description',
    category: 'category',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionFeatureScalarFieldEnum = (typeof SubscriptionFeatureScalarFieldEnum)[keyof typeof SubscriptionFeatureScalarFieldEnum]


  export const SubscriptionPaymentScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    gymSubscriptionId: 'gymSubscriptionId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    paymentMethod: 'paymentMethod',
    abacatePayBillingId: 'abacatePayBillingId',
    paidAt: 'paidAt',
    failedAt: 'failedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPaymentScalarFieldEnum = (typeof SubscriptionPaymentScalarFieldEnum)[keyof typeof SubscriptionPaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activeGymId?: StringNullableFilter<"User"> | string | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    gyms?: GymListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    gymPreference?: XOR<GymUserPreferenceNullableScalarRelationFilter, GymUserPreferenceWhereInput> | null
    paymentMethods?: PaymentMethodListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activeGymId?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    gyms?: GymOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    gymPreference?: GymUserPreferenceOrderByWithRelationInput
    paymentMethods?: PaymentMethodOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activeGymId?: StringNullableFilter<"User"> | string | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    gyms?: GymListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    gymPreference?: XOR<GymUserPreferenceNullableScalarRelationFilter, GymUserPreferenceWhereInput> | null
    paymentMethods?: PaymentMethodListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activeGymId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    activeGymId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringNullableFilter<"Account"> | string | null
    provider?: StringNullableFilter<"Account"> | string | null
    providerAccountId?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accountId?: StringNullableFilter<"Account"> | string | null
    providerId?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerAccountId?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accounts_provider_providerAccountId_key?: AccountAccounts_provider_providerAccountId_keyCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringNullableFilter<"Account"> | string | null
    provider?: StringNullableFilter<"Account"> | string | null
    providerAccountId?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accountId?: StringNullableFilter<"Account"> | string | null
    providerId?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "accounts_provider_providerAccountId_key">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerAccountId?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    provider?: StringNullableWithAggregatesFilter<"Account"> | string | null
    providerAccountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringNullableFilter<"Session"> | string | null
    expires?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    expires?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringNullableFilter<"Session"> | string | null
    expires?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    expires?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    sessionToken?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expires?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    age?: IntNullableFilter<"Student"> | number | null
    gender?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    avatar?: StringNullableFilter<"Student"> | string | null
    isTrans?: BoolNullableFilter<"Student"> | boolean | null
    usesHormones?: BoolNullableFilter<"Student"> | boolean | null
    hormoneType?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    progress?: XOR<StudentProgressNullableScalarRelationFilter, StudentProgressWhereInput> | null
    profile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    workouts?: WorkoutHistoryListRelationFilter
    workoutProgress?: WorkoutProgressListRelationFilter
    records?: PersonalRecordListRelationFilter
    diets?: DietPlanCompletionListRelationFilter
    achievements?: AchievementUnlockListRelationFilter
    weightHistory?: WeightHistoryListRelationFilter
    dailyNutrition?: DailyNutritionListRelationFilter
    nutritionChatUsage?: NutritionChatUsageListRelationFilter
    units?: UnitListRelationFilter
    memberships?: GymMembershipListRelationFilter
    dayPasses?: DayPassListRelationFilter
    friends?: FriendshipListRelationFilter
    friendOf?: FriendshipListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isTrans?: SortOrderInput | SortOrder
    usesHormones?: SortOrderInput | SortOrder
    hormoneType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    progress?: StudentProgressOrderByWithRelationInput
    profile?: StudentProfileOrderByWithRelationInput
    workouts?: WorkoutHistoryOrderByRelationAggregateInput
    workoutProgress?: WorkoutProgressOrderByRelationAggregateInput
    records?: PersonalRecordOrderByRelationAggregateInput
    diets?: DietPlanCompletionOrderByRelationAggregateInput
    achievements?: AchievementUnlockOrderByRelationAggregateInput
    weightHistory?: WeightHistoryOrderByRelationAggregateInput
    dailyNutrition?: DailyNutritionOrderByRelationAggregateInput
    nutritionChatUsage?: NutritionChatUsageOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    memberships?: GymMembershipOrderByRelationAggregateInput
    dayPasses?: DayPassOrderByRelationAggregateInput
    friends?: FriendshipOrderByRelationAggregateInput
    friendOf?: FriendshipOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    age?: IntNullableFilter<"Student"> | number | null
    gender?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    avatar?: StringNullableFilter<"Student"> | string | null
    isTrans?: BoolNullableFilter<"Student"> | boolean | null
    usesHormones?: BoolNullableFilter<"Student"> | boolean | null
    hormoneType?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    progress?: XOR<StudentProgressNullableScalarRelationFilter, StudentProgressWhereInput> | null
    profile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    workouts?: WorkoutHistoryListRelationFilter
    workoutProgress?: WorkoutProgressListRelationFilter
    records?: PersonalRecordListRelationFilter
    diets?: DietPlanCompletionListRelationFilter
    achievements?: AchievementUnlockListRelationFilter
    weightHistory?: WeightHistoryListRelationFilter
    dailyNutrition?: DailyNutritionListRelationFilter
    nutritionChatUsage?: NutritionChatUsageListRelationFilter
    units?: UnitListRelationFilter
    memberships?: GymMembershipListRelationFilter
    dayPasses?: DayPassListRelationFilter
    friends?: FriendshipListRelationFilter
    friendOf?: FriendshipListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isTrans?: SortOrderInput | SortOrder
    usesHormones?: SortOrderInput | SortOrder
    hormoneType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    age?: IntNullableWithAggregatesFilter<"Student"> | number | null
    gender?: StringNullableWithAggregatesFilter<"Student"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Student"> | string | null
    isTrans?: BoolNullableWithAggregatesFilter<"Student"> | boolean | null
    usesHormones?: BoolNullableWithAggregatesFilter<"Student"> | boolean | null
    hormoneType?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type StudentProgressWhereInput = {
    AND?: StudentProgressWhereInput | StudentProgressWhereInput[]
    OR?: StudentProgressWhereInput[]
    NOT?: StudentProgressWhereInput | StudentProgressWhereInput[]
    id?: StringFilter<"StudentProgress"> | string
    studentId?: StringFilter<"StudentProgress"> | string
    currentStreak?: IntFilter<"StudentProgress"> | number
    longestStreak?: IntFilter<"StudentProgress"> | number
    totalXP?: IntFilter<"StudentProgress"> | number
    currentLevel?: IntFilter<"StudentProgress"> | number
    xpToNextLevel?: IntFilter<"StudentProgress"> | number
    workoutsCompleted?: IntFilter<"StudentProgress"> | number
    lastActivityDate?: DateTimeNullableFilter<"StudentProgress"> | Date | string | null
    dailyGoalXP?: IntFilter<"StudentProgress"> | number
    todayXP?: IntFilter<"StudentProgress"> | number
    createdAt?: DateTimeFilter<"StudentProgress"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProgress"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentProgressOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    lastActivityDate?: SortOrderInput | SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: StudentProgressWhereInput | StudentProgressWhereInput[]
    OR?: StudentProgressWhereInput[]
    NOT?: StudentProgressWhereInput | StudentProgressWhereInput[]
    currentStreak?: IntFilter<"StudentProgress"> | number
    longestStreak?: IntFilter<"StudentProgress"> | number
    totalXP?: IntFilter<"StudentProgress"> | number
    currentLevel?: IntFilter<"StudentProgress"> | number
    xpToNextLevel?: IntFilter<"StudentProgress"> | number
    workoutsCompleted?: IntFilter<"StudentProgress"> | number
    lastActivityDate?: DateTimeNullableFilter<"StudentProgress"> | Date | string | null
    dailyGoalXP?: IntFilter<"StudentProgress"> | number
    todayXP?: IntFilter<"StudentProgress"> | number
    createdAt?: DateTimeFilter<"StudentProgress"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProgress"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId">

  export type StudentProgressOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    lastActivityDate?: SortOrderInput | SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentProgressCountOrderByAggregateInput
    _avg?: StudentProgressAvgOrderByAggregateInput
    _max?: StudentProgressMaxOrderByAggregateInput
    _min?: StudentProgressMinOrderByAggregateInput
    _sum?: StudentProgressSumOrderByAggregateInput
  }

  export type StudentProgressScalarWhereWithAggregatesInput = {
    AND?: StudentProgressScalarWhereWithAggregatesInput | StudentProgressScalarWhereWithAggregatesInput[]
    OR?: StudentProgressScalarWhereWithAggregatesInput[]
    NOT?: StudentProgressScalarWhereWithAggregatesInput | StudentProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentProgress"> | string
    studentId?: StringWithAggregatesFilter<"StudentProgress"> | string
    currentStreak?: IntWithAggregatesFilter<"StudentProgress"> | number
    longestStreak?: IntWithAggregatesFilter<"StudentProgress"> | number
    totalXP?: IntWithAggregatesFilter<"StudentProgress"> | number
    currentLevel?: IntWithAggregatesFilter<"StudentProgress"> | number
    xpToNextLevel?: IntWithAggregatesFilter<"StudentProgress"> | number
    workoutsCompleted?: IntWithAggregatesFilter<"StudentProgress"> | number
    lastActivityDate?: DateTimeNullableWithAggregatesFilter<"StudentProgress"> | Date | string | null
    dailyGoalXP?: IntWithAggregatesFilter<"StudentProgress"> | number
    todayXP?: IntWithAggregatesFilter<"StudentProgress"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StudentProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentProgress"> | Date | string
  }

  export type StudentProfileWhereInput = {
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    id?: StringFilter<"StudentProfile"> | string
    studentId?: StringFilter<"StudentProfile"> | string
    height?: FloatNullableFilter<"StudentProfile"> | number | null
    weight?: FloatNullableFilter<"StudentProfile"> | number | null
    fitnessLevel?: StringNullableFilter<"StudentProfile"> | string | null
    weeklyWorkoutFrequency?: IntNullableFilter<"StudentProfile"> | number | null
    workoutDuration?: IntNullableFilter<"StudentProfile"> | number | null
    goals?: StringNullableFilter<"StudentProfile"> | string | null
    injuries?: StringNullableFilter<"StudentProfile"> | string | null
    availableEquipment?: StringNullableFilter<"StudentProfile"> | string | null
    gymType?: StringNullableFilter<"StudentProfile"> | string | null
    preferredWorkoutTime?: StringNullableFilter<"StudentProfile"> | string | null
    preferredSets?: IntNullableFilter<"StudentProfile"> | number | null
    preferredRepRange?: StringNullableFilter<"StudentProfile"> | string | null
    restTime?: StringNullableFilter<"StudentProfile"> | string | null
    dietType?: StringNullableFilter<"StudentProfile"> | string | null
    allergies?: StringNullableFilter<"StudentProfile"> | string | null
    targetCalories?: IntNullableFilter<"StudentProfile"> | number | null
    targetProtein?: FloatNullableFilter<"StudentProfile"> | number | null
    targetCarbs?: FloatNullableFilter<"StudentProfile"> | number | null
    targetFats?: FloatNullableFilter<"StudentProfile"> | number | null
    mealsPerDay?: IntNullableFilter<"StudentProfile"> | number | null
    bmr?: FloatNullableFilter<"StudentProfile"> | number | null
    tdee?: FloatNullableFilter<"StudentProfile"> | number | null
    activityLevel?: IntNullableFilter<"StudentProfile"> | number | null
    hormoneTreatmentDuration?: IntNullableFilter<"StudentProfile"> | number | null
    physicalLimitations?: StringNullableFilter<"StudentProfile"> | string | null
    motorLimitations?: StringNullableFilter<"StudentProfile"> | string | null
    medicalConditions?: StringNullableFilter<"StudentProfile"> | string | null
    limitationDetails?: StringNullableFilter<"StudentProfile"> | string | null
    dailyAvailableHours?: FloatNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentProfileOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    fitnessLevel?: SortOrderInput | SortOrder
    weeklyWorkoutFrequency?: SortOrderInput | SortOrder
    workoutDuration?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    injuries?: SortOrderInput | SortOrder
    availableEquipment?: SortOrderInput | SortOrder
    gymType?: SortOrderInput | SortOrder
    preferredWorkoutTime?: SortOrderInput | SortOrder
    preferredSets?: SortOrderInput | SortOrder
    preferredRepRange?: SortOrderInput | SortOrder
    restTime?: SortOrderInput | SortOrder
    dietType?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    targetCalories?: SortOrderInput | SortOrder
    targetProtein?: SortOrderInput | SortOrder
    targetCarbs?: SortOrderInput | SortOrder
    targetFats?: SortOrderInput | SortOrder
    mealsPerDay?: SortOrderInput | SortOrder
    bmr?: SortOrderInput | SortOrder
    tdee?: SortOrderInput | SortOrder
    activityLevel?: SortOrderInput | SortOrder
    hormoneTreatmentDuration?: SortOrderInput | SortOrder
    physicalLimitations?: SortOrderInput | SortOrder
    motorLimitations?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    limitationDetails?: SortOrderInput | SortOrder
    dailyAvailableHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    height?: FloatNullableFilter<"StudentProfile"> | number | null
    weight?: FloatNullableFilter<"StudentProfile"> | number | null
    fitnessLevel?: StringNullableFilter<"StudentProfile"> | string | null
    weeklyWorkoutFrequency?: IntNullableFilter<"StudentProfile"> | number | null
    workoutDuration?: IntNullableFilter<"StudentProfile"> | number | null
    goals?: StringNullableFilter<"StudentProfile"> | string | null
    injuries?: StringNullableFilter<"StudentProfile"> | string | null
    availableEquipment?: StringNullableFilter<"StudentProfile"> | string | null
    gymType?: StringNullableFilter<"StudentProfile"> | string | null
    preferredWorkoutTime?: StringNullableFilter<"StudentProfile"> | string | null
    preferredSets?: IntNullableFilter<"StudentProfile"> | number | null
    preferredRepRange?: StringNullableFilter<"StudentProfile"> | string | null
    restTime?: StringNullableFilter<"StudentProfile"> | string | null
    dietType?: StringNullableFilter<"StudentProfile"> | string | null
    allergies?: StringNullableFilter<"StudentProfile"> | string | null
    targetCalories?: IntNullableFilter<"StudentProfile"> | number | null
    targetProtein?: FloatNullableFilter<"StudentProfile"> | number | null
    targetCarbs?: FloatNullableFilter<"StudentProfile"> | number | null
    targetFats?: FloatNullableFilter<"StudentProfile"> | number | null
    mealsPerDay?: IntNullableFilter<"StudentProfile"> | number | null
    bmr?: FloatNullableFilter<"StudentProfile"> | number | null
    tdee?: FloatNullableFilter<"StudentProfile"> | number | null
    activityLevel?: IntNullableFilter<"StudentProfile"> | number | null
    hormoneTreatmentDuration?: IntNullableFilter<"StudentProfile"> | number | null
    physicalLimitations?: StringNullableFilter<"StudentProfile"> | string | null
    motorLimitations?: StringNullableFilter<"StudentProfile"> | string | null
    medicalConditions?: StringNullableFilter<"StudentProfile"> | string | null
    limitationDetails?: StringNullableFilter<"StudentProfile"> | string | null
    dailyAvailableHours?: FloatNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId">

  export type StudentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    fitnessLevel?: SortOrderInput | SortOrder
    weeklyWorkoutFrequency?: SortOrderInput | SortOrder
    workoutDuration?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    injuries?: SortOrderInput | SortOrder
    availableEquipment?: SortOrderInput | SortOrder
    gymType?: SortOrderInput | SortOrder
    preferredWorkoutTime?: SortOrderInput | SortOrder
    preferredSets?: SortOrderInput | SortOrder
    preferredRepRange?: SortOrderInput | SortOrder
    restTime?: SortOrderInput | SortOrder
    dietType?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    targetCalories?: SortOrderInput | SortOrder
    targetProtein?: SortOrderInput | SortOrder
    targetCarbs?: SortOrderInput | SortOrder
    targetFats?: SortOrderInput | SortOrder
    mealsPerDay?: SortOrderInput | SortOrder
    bmr?: SortOrderInput | SortOrder
    tdee?: SortOrderInput | SortOrder
    activityLevel?: SortOrderInput | SortOrder
    hormoneTreatmentDuration?: SortOrderInput | SortOrder
    physicalLimitations?: SortOrderInput | SortOrder
    motorLimitations?: SortOrderInput | SortOrder
    medicalConditions?: SortOrderInput | SortOrder
    limitationDetails?: SortOrderInput | SortOrder
    dailyAvailableHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentProfileCountOrderByAggregateInput
    _avg?: StudentProfileAvgOrderByAggregateInput
    _max?: StudentProfileMaxOrderByAggregateInput
    _min?: StudentProfileMinOrderByAggregateInput
    _sum?: StudentProfileSumOrderByAggregateInput
  }

  export type StudentProfileScalarWhereWithAggregatesInput = {
    AND?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    OR?: StudentProfileScalarWhereWithAggregatesInput[]
    NOT?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentProfile"> | string
    studentId?: StringWithAggregatesFilter<"StudentProfile"> | string
    height?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    fitnessLevel?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    weeklyWorkoutFrequency?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    workoutDuration?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    goals?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    injuries?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    availableEquipment?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    gymType?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    preferredWorkoutTime?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    preferredSets?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    preferredRepRange?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    restTime?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    dietType?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    targetCalories?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    targetProtein?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    targetCarbs?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    targetFats?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    mealsPerDay?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    bmr?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    tdee?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    activityLevel?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    hormoneTreatmentDuration?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    physicalLimitations?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    motorLimitations?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    medicalConditions?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    limitationDetails?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    dailyAvailableHours?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
  }

  export type WeightHistoryWhereInput = {
    AND?: WeightHistoryWhereInput | WeightHistoryWhereInput[]
    OR?: WeightHistoryWhereInput[]
    NOT?: WeightHistoryWhereInput | WeightHistoryWhereInput[]
    id?: StringFilter<"WeightHistory"> | string
    studentId?: StringFilter<"WeightHistory"> | string
    weight?: FloatFilter<"WeightHistory"> | number
    date?: DateTimeFilter<"WeightHistory"> | Date | string
    notes?: StringNullableFilter<"WeightHistory"> | string | null
    createdAt?: DateTimeFilter<"WeightHistory"> | Date | string
    updatedAt?: DateTimeFilter<"WeightHistory"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type WeightHistoryOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    weight?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type WeightHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeightHistoryWhereInput | WeightHistoryWhereInput[]
    OR?: WeightHistoryWhereInput[]
    NOT?: WeightHistoryWhereInput | WeightHistoryWhereInput[]
    studentId?: StringFilter<"WeightHistory"> | string
    weight?: FloatFilter<"WeightHistory"> | number
    date?: DateTimeFilter<"WeightHistory"> | Date | string
    notes?: StringNullableFilter<"WeightHistory"> | string | null
    createdAt?: DateTimeFilter<"WeightHistory"> | Date | string
    updatedAt?: DateTimeFilter<"WeightHistory"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type WeightHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    weight?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeightHistoryCountOrderByAggregateInput
    _avg?: WeightHistoryAvgOrderByAggregateInput
    _max?: WeightHistoryMaxOrderByAggregateInput
    _min?: WeightHistoryMinOrderByAggregateInput
    _sum?: WeightHistorySumOrderByAggregateInput
  }

  export type WeightHistoryScalarWhereWithAggregatesInput = {
    AND?: WeightHistoryScalarWhereWithAggregatesInput | WeightHistoryScalarWhereWithAggregatesInput[]
    OR?: WeightHistoryScalarWhereWithAggregatesInput[]
    NOT?: WeightHistoryScalarWhereWithAggregatesInput | WeightHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeightHistory"> | string
    studentId?: StringWithAggregatesFilter<"WeightHistory"> | string
    weight?: FloatWithAggregatesFilter<"WeightHistory"> | number
    date?: DateTimeWithAggregatesFilter<"WeightHistory"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"WeightHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeightHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeightHistory"> | Date | string
  }

  export type GymWhereInput = {
    AND?: GymWhereInput | GymWhereInput[]
    OR?: GymWhereInput[]
    NOT?: GymWhereInput | GymWhereInput[]
    id?: StringFilter<"Gym"> | string
    userId?: StringFilter<"Gym"> | string
    name?: StringFilter<"Gym"> | string
    logo?: StringNullableFilter<"Gym"> | string | null
    address?: StringFilter<"Gym"> | string
    phone?: StringFilter<"Gym"> | string
    email?: StringFilter<"Gym"> | string
    cnpj?: StringNullableFilter<"Gym"> | string | null
    plan?: StringFilter<"Gym"> | string
    isActive?: BoolFilter<"Gym"> | boolean
    latitude?: FloatNullableFilter<"Gym"> | number | null
    longitude?: FloatNullableFilter<"Gym"> | number | null
    rating?: FloatNullableFilter<"Gym"> | number | null
    totalReviews?: IntFilter<"Gym"> | number
    amenities?: StringNullableFilter<"Gym"> | string | null
    openingHours?: StringNullableFilter<"Gym"> | string | null
    photos?: StringNullableFilter<"Gym"> | string | null
    isPartner?: BoolFilter<"Gym"> | boolean
    createdAt?: DateTimeFilter<"Gym"> | Date | string
    updatedAt?: DateTimeFilter<"Gym"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profile?: XOR<GymProfileNullableScalarRelationFilter, GymProfileWhereInput> | null
    students?: GymMembershipListRelationFilter
    equipment?: EquipmentListRelationFilter
    plans?: MembershipPlanListRelationFilter
    payments?: PaymentListRelationFilter
    expenses?: ExpenseListRelationFilter
    checkIns?: CheckInListRelationFilter
    stats?: XOR<GymStatsNullableScalarRelationFilter, GymStatsWhereInput> | null
    subscription?: XOR<GymSubscriptionNullableScalarRelationFilter, GymSubscriptionWhereInput> | null
  }

  export type GymOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    amenities?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    isPartner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    profile?: GymProfileOrderByWithRelationInput
    students?: GymMembershipOrderByRelationAggregateInput
    equipment?: EquipmentOrderByRelationAggregateInput
    plans?: MembershipPlanOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    checkIns?: CheckInOrderByRelationAggregateInput
    stats?: GymStatsOrderByWithRelationInput
    subscription?: GymSubscriptionOrderByWithRelationInput
  }

  export type GymWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    AND?: GymWhereInput | GymWhereInput[]
    OR?: GymWhereInput[]
    NOT?: GymWhereInput | GymWhereInput[]
    userId?: StringFilter<"Gym"> | string
    name?: StringFilter<"Gym"> | string
    logo?: StringNullableFilter<"Gym"> | string | null
    address?: StringFilter<"Gym"> | string
    phone?: StringFilter<"Gym"> | string
    email?: StringFilter<"Gym"> | string
    plan?: StringFilter<"Gym"> | string
    isActive?: BoolFilter<"Gym"> | boolean
    latitude?: FloatNullableFilter<"Gym"> | number | null
    longitude?: FloatNullableFilter<"Gym"> | number | null
    rating?: FloatNullableFilter<"Gym"> | number | null
    totalReviews?: IntFilter<"Gym"> | number
    amenities?: StringNullableFilter<"Gym"> | string | null
    openingHours?: StringNullableFilter<"Gym"> | string | null
    photos?: StringNullableFilter<"Gym"> | string | null
    isPartner?: BoolFilter<"Gym"> | boolean
    createdAt?: DateTimeFilter<"Gym"> | Date | string
    updatedAt?: DateTimeFilter<"Gym"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profile?: XOR<GymProfileNullableScalarRelationFilter, GymProfileWhereInput> | null
    students?: GymMembershipListRelationFilter
    equipment?: EquipmentListRelationFilter
    plans?: MembershipPlanListRelationFilter
    payments?: PaymentListRelationFilter
    expenses?: ExpenseListRelationFilter
    checkIns?: CheckInListRelationFilter
    stats?: XOR<GymStatsNullableScalarRelationFilter, GymStatsWhereInput> | null
    subscription?: XOR<GymSubscriptionNullableScalarRelationFilter, GymSubscriptionWhereInput> | null
  }, "id" | "cnpj">

  export type GymOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    amenities?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    photos?: SortOrderInput | SortOrder
    isPartner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymCountOrderByAggregateInput
    _avg?: GymAvgOrderByAggregateInput
    _max?: GymMaxOrderByAggregateInput
    _min?: GymMinOrderByAggregateInput
    _sum?: GymSumOrderByAggregateInput
  }

  export type GymScalarWhereWithAggregatesInput = {
    AND?: GymScalarWhereWithAggregatesInput | GymScalarWhereWithAggregatesInput[]
    OR?: GymScalarWhereWithAggregatesInput[]
    NOT?: GymScalarWhereWithAggregatesInput | GymScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gym"> | string
    userId?: StringWithAggregatesFilter<"Gym"> | string
    name?: StringWithAggregatesFilter<"Gym"> | string
    logo?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    address?: StringWithAggregatesFilter<"Gym"> | string
    phone?: StringWithAggregatesFilter<"Gym"> | string
    email?: StringWithAggregatesFilter<"Gym"> | string
    cnpj?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    plan?: StringWithAggregatesFilter<"Gym"> | string
    isActive?: BoolWithAggregatesFilter<"Gym"> | boolean
    latitude?: FloatNullableWithAggregatesFilter<"Gym"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Gym"> | number | null
    rating?: FloatNullableWithAggregatesFilter<"Gym"> | number | null
    totalReviews?: IntWithAggregatesFilter<"Gym"> | number
    amenities?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    openingHours?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    photos?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    isPartner?: BoolWithAggregatesFilter<"Gym"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Gym"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gym"> | Date | string
  }

  export type GymProfileWhereInput = {
    AND?: GymProfileWhereInput | GymProfileWhereInput[]
    OR?: GymProfileWhereInput[]
    NOT?: GymProfileWhereInput | GymProfileWhereInput[]
    id?: StringFilter<"GymProfile"> | string
    gymId?: StringFilter<"GymProfile"> | string
    totalStudents?: IntFilter<"GymProfile"> | number
    activeStudents?: IntFilter<"GymProfile"> | number
    equipmentCount?: IntFilter<"GymProfile"> | number
    level?: IntFilter<"GymProfile"> | number
    xp?: IntFilter<"GymProfile"> | number
    xpToNextLevel?: IntFilter<"GymProfile"> | number
    currentStreak?: IntFilter<"GymProfile"> | number
    longestStreak?: IntFilter<"GymProfile"> | number
    monthlyStudentGoal?: IntNullableFilter<"GymProfile"> | number | null
    avgStudentFrequency?: FloatNullableFilter<"GymProfile"> | number | null
    equipmentUtilization?: FloatNullableFilter<"GymProfile"> | number | null
    ranking?: IntNullableFilter<"GymProfile"> | number | null
    createdAt?: DateTimeFilter<"GymProfile"> | Date | string
    updatedAt?: DateTimeFilter<"GymProfile"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type GymProfileOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrderInput | SortOrder
    avgStudentFrequency?: SortOrderInput | SortOrder
    equipmentUtilization?: SortOrderInput | SortOrder
    ranking?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type GymProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gymId?: string
    AND?: GymProfileWhereInput | GymProfileWhereInput[]
    OR?: GymProfileWhereInput[]
    NOT?: GymProfileWhereInput | GymProfileWhereInput[]
    totalStudents?: IntFilter<"GymProfile"> | number
    activeStudents?: IntFilter<"GymProfile"> | number
    equipmentCount?: IntFilter<"GymProfile"> | number
    level?: IntFilter<"GymProfile"> | number
    xp?: IntFilter<"GymProfile"> | number
    xpToNextLevel?: IntFilter<"GymProfile"> | number
    currentStreak?: IntFilter<"GymProfile"> | number
    longestStreak?: IntFilter<"GymProfile"> | number
    monthlyStudentGoal?: IntNullableFilter<"GymProfile"> | number | null
    avgStudentFrequency?: FloatNullableFilter<"GymProfile"> | number | null
    equipmentUtilization?: FloatNullableFilter<"GymProfile"> | number | null
    ranking?: IntNullableFilter<"GymProfile"> | number | null
    createdAt?: DateTimeFilter<"GymProfile"> | Date | string
    updatedAt?: DateTimeFilter<"GymProfile"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id" | "gymId">

  export type GymProfileOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrderInput | SortOrder
    avgStudentFrequency?: SortOrderInput | SortOrder
    equipmentUtilization?: SortOrderInput | SortOrder
    ranking?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymProfileCountOrderByAggregateInput
    _avg?: GymProfileAvgOrderByAggregateInput
    _max?: GymProfileMaxOrderByAggregateInput
    _min?: GymProfileMinOrderByAggregateInput
    _sum?: GymProfileSumOrderByAggregateInput
  }

  export type GymProfileScalarWhereWithAggregatesInput = {
    AND?: GymProfileScalarWhereWithAggregatesInput | GymProfileScalarWhereWithAggregatesInput[]
    OR?: GymProfileScalarWhereWithAggregatesInput[]
    NOT?: GymProfileScalarWhereWithAggregatesInput | GymProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymProfile"> | string
    gymId?: StringWithAggregatesFilter<"GymProfile"> | string
    totalStudents?: IntWithAggregatesFilter<"GymProfile"> | number
    activeStudents?: IntWithAggregatesFilter<"GymProfile"> | number
    equipmentCount?: IntWithAggregatesFilter<"GymProfile"> | number
    level?: IntWithAggregatesFilter<"GymProfile"> | number
    xp?: IntWithAggregatesFilter<"GymProfile"> | number
    xpToNextLevel?: IntWithAggregatesFilter<"GymProfile"> | number
    currentStreak?: IntWithAggregatesFilter<"GymProfile"> | number
    longestStreak?: IntWithAggregatesFilter<"GymProfile"> | number
    monthlyStudentGoal?: IntNullableWithAggregatesFilter<"GymProfile"> | number | null
    avgStudentFrequency?: FloatNullableWithAggregatesFilter<"GymProfile"> | number | null
    equipmentUtilization?: FloatNullableWithAggregatesFilter<"GymProfile"> | number | null
    ranking?: IntNullableWithAggregatesFilter<"GymProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GymProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymProfile"> | Date | string
  }

  export type GymStatsWhereInput = {
    AND?: GymStatsWhereInput | GymStatsWhereInput[]
    OR?: GymStatsWhereInput[]
    NOT?: GymStatsWhereInput | GymStatsWhereInput[]
    id?: StringFilter<"GymStats"> | string
    gymId?: StringFilter<"GymStats"> | string
    todayCheckins?: IntFilter<"GymStats"> | number
    todayActiveStudents?: IntFilter<"GymStats"> | number
    todayEquipmentInUse?: IntFilter<"GymStats"> | number
    weekTotalCheckins?: IntFilter<"GymStats"> | number
    weekAvgDailyCheckins?: FloatFilter<"GymStats"> | number
    weekNewMembers?: IntFilter<"GymStats"> | number
    weekCanceledMembers?: IntFilter<"GymStats"> | number
    monthTotalCheckins?: IntFilter<"GymStats"> | number
    monthRetentionRate?: FloatFilter<"GymStats"> | number
    monthGrowthRate?: FloatFilter<"GymStats"> | number
    updatedAt?: DateTimeFilter<"GymStats"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type GymStatsOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type GymStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gymId?: string
    AND?: GymStatsWhereInput | GymStatsWhereInput[]
    OR?: GymStatsWhereInput[]
    NOT?: GymStatsWhereInput | GymStatsWhereInput[]
    todayCheckins?: IntFilter<"GymStats"> | number
    todayActiveStudents?: IntFilter<"GymStats"> | number
    todayEquipmentInUse?: IntFilter<"GymStats"> | number
    weekTotalCheckins?: IntFilter<"GymStats"> | number
    weekAvgDailyCheckins?: FloatFilter<"GymStats"> | number
    weekNewMembers?: IntFilter<"GymStats"> | number
    weekCanceledMembers?: IntFilter<"GymStats"> | number
    monthTotalCheckins?: IntFilter<"GymStats"> | number
    monthRetentionRate?: FloatFilter<"GymStats"> | number
    monthGrowthRate?: FloatFilter<"GymStats"> | number
    updatedAt?: DateTimeFilter<"GymStats"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id" | "gymId">

  export type GymStatsOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
    updatedAt?: SortOrder
    _count?: GymStatsCountOrderByAggregateInput
    _avg?: GymStatsAvgOrderByAggregateInput
    _max?: GymStatsMaxOrderByAggregateInput
    _min?: GymStatsMinOrderByAggregateInput
    _sum?: GymStatsSumOrderByAggregateInput
  }

  export type GymStatsScalarWhereWithAggregatesInput = {
    AND?: GymStatsScalarWhereWithAggregatesInput | GymStatsScalarWhereWithAggregatesInput[]
    OR?: GymStatsScalarWhereWithAggregatesInput[]
    NOT?: GymStatsScalarWhereWithAggregatesInput | GymStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymStats"> | string
    gymId?: StringWithAggregatesFilter<"GymStats"> | string
    todayCheckins?: IntWithAggregatesFilter<"GymStats"> | number
    todayActiveStudents?: IntWithAggregatesFilter<"GymStats"> | number
    todayEquipmentInUse?: IntWithAggregatesFilter<"GymStats"> | number
    weekTotalCheckins?: IntWithAggregatesFilter<"GymStats"> | number
    weekAvgDailyCheckins?: FloatWithAggregatesFilter<"GymStats"> | number
    weekNewMembers?: IntWithAggregatesFilter<"GymStats"> | number
    weekCanceledMembers?: IntWithAggregatesFilter<"GymStats"> | number
    monthTotalCheckins?: IntWithAggregatesFilter<"GymStats"> | number
    monthRetentionRate?: FloatWithAggregatesFilter<"GymStats"> | number
    monthGrowthRate?: FloatWithAggregatesFilter<"GymStats"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"GymStats"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    title?: StringFilter<"Unit"> | string
    description?: StringNullableFilter<"Unit"> | string | null
    color?: StringNullableFilter<"Unit"> | string | null
    icon?: StringNullableFilter<"Unit"> | string | null
    order?: IntFilter<"Unit"> | number
    studentId?: StringNullableFilter<"Unit"> | string | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    workouts?: WorkoutListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    studentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    workouts?: WorkoutOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    title?: StringFilter<"Unit"> | string
    description?: StringNullableFilter<"Unit"> | string | null
    color?: StringNullableFilter<"Unit"> | string | null
    icon?: StringNullableFilter<"Unit"> | string | null
    order?: IntFilter<"Unit"> | number
    studentId?: StringNullableFilter<"Unit"> | string | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    workouts?: WorkoutListRelationFilter
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    studentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    title?: StringWithAggregatesFilter<"Unit"> | string
    description?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    color?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    order?: IntWithAggregatesFilter<"Unit"> | number
    studentId?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type WorkoutWhereInput = {
    AND?: WorkoutWhereInput | WorkoutWhereInput[]
    OR?: WorkoutWhereInput[]
    NOT?: WorkoutWhereInput | WorkoutWhereInput[]
    id?: StringFilter<"Workout"> | string
    unitId?: StringNullableFilter<"Workout"> | string | null
    title?: StringFilter<"Workout"> | string
    description?: StringNullableFilter<"Workout"> | string | null
    type?: StringFilter<"Workout"> | string
    muscleGroup?: StringFilter<"Workout"> | string
    difficulty?: StringFilter<"Workout"> | string
    xpReward?: IntFilter<"Workout"> | number
    estimatedTime?: IntFilter<"Workout"> | number
    order?: IntFilter<"Workout"> | number
    locked?: BoolFilter<"Workout"> | boolean
    createdAt?: DateTimeFilter<"Workout"> | Date | string
    updatedAt?: DateTimeFilter<"Workout"> | Date | string
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    exercises?: WorkoutExerciseListRelationFilter
    completions?: WorkoutHistoryListRelationFilter
    progress?: WorkoutProgressListRelationFilter
  }

  export type WorkoutOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    muscleGroup?: SortOrder
    difficulty?: SortOrder
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
    exercises?: WorkoutExerciseOrderByRelationAggregateInput
    completions?: WorkoutHistoryOrderByRelationAggregateInput
    progress?: WorkoutProgressOrderByRelationAggregateInput
  }

  export type WorkoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutWhereInput | WorkoutWhereInput[]
    OR?: WorkoutWhereInput[]
    NOT?: WorkoutWhereInput | WorkoutWhereInput[]
    unitId?: StringNullableFilter<"Workout"> | string | null
    title?: StringFilter<"Workout"> | string
    description?: StringNullableFilter<"Workout"> | string | null
    type?: StringFilter<"Workout"> | string
    muscleGroup?: StringFilter<"Workout"> | string
    difficulty?: StringFilter<"Workout"> | string
    xpReward?: IntFilter<"Workout"> | number
    estimatedTime?: IntFilter<"Workout"> | number
    order?: IntFilter<"Workout"> | number
    locked?: BoolFilter<"Workout"> | boolean
    createdAt?: DateTimeFilter<"Workout"> | Date | string
    updatedAt?: DateTimeFilter<"Workout"> | Date | string
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    exercises?: WorkoutExerciseListRelationFilter
    completions?: WorkoutHistoryListRelationFilter
    progress?: WorkoutProgressListRelationFilter
  }, "id">

  export type WorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    muscleGroup?: SortOrder
    difficulty?: SortOrder
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkoutCountOrderByAggregateInput
    _avg?: WorkoutAvgOrderByAggregateInput
    _max?: WorkoutMaxOrderByAggregateInput
    _min?: WorkoutMinOrderByAggregateInput
    _sum?: WorkoutSumOrderByAggregateInput
  }

  export type WorkoutScalarWhereWithAggregatesInput = {
    AND?: WorkoutScalarWhereWithAggregatesInput | WorkoutScalarWhereWithAggregatesInput[]
    OR?: WorkoutScalarWhereWithAggregatesInput[]
    NOT?: WorkoutScalarWhereWithAggregatesInput | WorkoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workout"> | string
    unitId?: StringNullableWithAggregatesFilter<"Workout"> | string | null
    title?: StringWithAggregatesFilter<"Workout"> | string
    description?: StringNullableWithAggregatesFilter<"Workout"> | string | null
    type?: StringWithAggregatesFilter<"Workout"> | string
    muscleGroup?: StringWithAggregatesFilter<"Workout"> | string
    difficulty?: StringWithAggregatesFilter<"Workout"> | string
    xpReward?: IntWithAggregatesFilter<"Workout"> | number
    estimatedTime?: IntWithAggregatesFilter<"Workout"> | number
    order?: IntWithAggregatesFilter<"Workout"> | number
    locked?: BoolWithAggregatesFilter<"Workout"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Workout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workout"> | Date | string
  }

  export type WorkoutExerciseWhereInput = {
    AND?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    OR?: WorkoutExerciseWhereInput[]
    NOT?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    id?: StringFilter<"WorkoutExercise"> | string
    workoutId?: StringFilter<"WorkoutExercise"> | string
    name?: StringFilter<"WorkoutExercise"> | string
    sets?: IntFilter<"WorkoutExercise"> | number
    reps?: StringFilter<"WorkoutExercise"> | string
    rest?: IntFilter<"WorkoutExercise"> | number
    notes?: StringNullableFilter<"WorkoutExercise"> | string | null
    videoUrl?: StringNullableFilter<"WorkoutExercise"> | string | null
    educationalId?: StringNullableFilter<"WorkoutExercise"> | string | null
    order?: IntFilter<"WorkoutExercise"> | number
    primaryMuscles?: StringNullableFilter<"WorkoutExercise"> | string | null
    secondaryMuscles?: StringNullableFilter<"WorkoutExercise"> | string | null
    difficulty?: StringNullableFilter<"WorkoutExercise"> | string | null
    equipment?: StringNullableFilter<"WorkoutExercise"> | string | null
    instructions?: StringNullableFilter<"WorkoutExercise"> | string | null
    tips?: StringNullableFilter<"WorkoutExercise"> | string | null
    commonMistakes?: StringNullableFilter<"WorkoutExercise"> | string | null
    benefits?: StringNullableFilter<"WorkoutExercise"> | string | null
    scientificEvidence?: StringNullableFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    workout?: XOR<WorkoutScalarRelationFilter, WorkoutWhereInput>
    alternatives?: AlternativeExerciseListRelationFilter
  }

  export type WorkoutExerciseOrderByWithRelationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    rest?: SortOrder
    notes?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    educationalId?: SortOrderInput | SortOrder
    order?: SortOrder
    primaryMuscles?: SortOrderInput | SortOrder
    secondaryMuscles?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    tips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    scientificEvidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workout?: WorkoutOrderByWithRelationInput
    alternatives?: AlternativeExerciseOrderByRelationAggregateInput
  }

  export type WorkoutExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    OR?: WorkoutExerciseWhereInput[]
    NOT?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    workoutId?: StringFilter<"WorkoutExercise"> | string
    name?: StringFilter<"WorkoutExercise"> | string
    sets?: IntFilter<"WorkoutExercise"> | number
    reps?: StringFilter<"WorkoutExercise"> | string
    rest?: IntFilter<"WorkoutExercise"> | number
    notes?: StringNullableFilter<"WorkoutExercise"> | string | null
    videoUrl?: StringNullableFilter<"WorkoutExercise"> | string | null
    educationalId?: StringNullableFilter<"WorkoutExercise"> | string | null
    order?: IntFilter<"WorkoutExercise"> | number
    primaryMuscles?: StringNullableFilter<"WorkoutExercise"> | string | null
    secondaryMuscles?: StringNullableFilter<"WorkoutExercise"> | string | null
    difficulty?: StringNullableFilter<"WorkoutExercise"> | string | null
    equipment?: StringNullableFilter<"WorkoutExercise"> | string | null
    instructions?: StringNullableFilter<"WorkoutExercise"> | string | null
    tips?: StringNullableFilter<"WorkoutExercise"> | string | null
    commonMistakes?: StringNullableFilter<"WorkoutExercise"> | string | null
    benefits?: StringNullableFilter<"WorkoutExercise"> | string | null
    scientificEvidence?: StringNullableFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    workout?: XOR<WorkoutScalarRelationFilter, WorkoutWhereInput>
    alternatives?: AlternativeExerciseListRelationFilter
  }, "id">

  export type WorkoutExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    rest?: SortOrder
    notes?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    educationalId?: SortOrderInput | SortOrder
    order?: SortOrder
    primaryMuscles?: SortOrderInput | SortOrder
    secondaryMuscles?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    tips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    scientificEvidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkoutExerciseCountOrderByAggregateInput
    _avg?: WorkoutExerciseAvgOrderByAggregateInput
    _max?: WorkoutExerciseMaxOrderByAggregateInput
    _min?: WorkoutExerciseMinOrderByAggregateInput
    _sum?: WorkoutExerciseSumOrderByAggregateInput
  }

  export type WorkoutExerciseScalarWhereWithAggregatesInput = {
    AND?: WorkoutExerciseScalarWhereWithAggregatesInput | WorkoutExerciseScalarWhereWithAggregatesInput[]
    OR?: WorkoutExerciseScalarWhereWithAggregatesInput[]
    NOT?: WorkoutExerciseScalarWhereWithAggregatesInput | WorkoutExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    workoutId?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    name?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    sets?: IntWithAggregatesFilter<"WorkoutExercise"> | number
    reps?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    rest?: IntWithAggregatesFilter<"WorkoutExercise"> | number
    notes?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    educationalId?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    order?: IntWithAggregatesFilter<"WorkoutExercise"> | number
    primaryMuscles?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    secondaryMuscles?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    equipment?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    tips?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    commonMistakes?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    benefits?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    scientificEvidence?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkoutExercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkoutExercise"> | Date | string
  }

  export type AlternativeExerciseWhereInput = {
    AND?: AlternativeExerciseWhereInput | AlternativeExerciseWhereInput[]
    OR?: AlternativeExerciseWhereInput[]
    NOT?: AlternativeExerciseWhereInput | AlternativeExerciseWhereInput[]
    id?: StringFilter<"AlternativeExercise"> | string
    workoutExerciseId?: StringFilter<"AlternativeExercise"> | string
    name?: StringFilter<"AlternativeExercise"> | string
    reason?: StringFilter<"AlternativeExercise"> | string
    educationalId?: StringNullableFilter<"AlternativeExercise"> | string | null
    order?: IntFilter<"AlternativeExercise"> | number
    createdAt?: DateTimeFilter<"AlternativeExercise"> | Date | string
    updatedAt?: DateTimeFilter<"AlternativeExercise"> | Date | string
    workoutExercise?: XOR<WorkoutExerciseScalarRelationFilter, WorkoutExerciseWhereInput>
  }

  export type AlternativeExerciseOrderByWithRelationInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    educationalId?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workoutExercise?: WorkoutExerciseOrderByWithRelationInput
  }

  export type AlternativeExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlternativeExerciseWhereInput | AlternativeExerciseWhereInput[]
    OR?: AlternativeExerciseWhereInput[]
    NOT?: AlternativeExerciseWhereInput | AlternativeExerciseWhereInput[]
    workoutExerciseId?: StringFilter<"AlternativeExercise"> | string
    name?: StringFilter<"AlternativeExercise"> | string
    reason?: StringFilter<"AlternativeExercise"> | string
    educationalId?: StringNullableFilter<"AlternativeExercise"> | string | null
    order?: IntFilter<"AlternativeExercise"> | number
    createdAt?: DateTimeFilter<"AlternativeExercise"> | Date | string
    updatedAt?: DateTimeFilter<"AlternativeExercise"> | Date | string
    workoutExercise?: XOR<WorkoutExerciseScalarRelationFilter, WorkoutExerciseWhereInput>
  }, "id">

  export type AlternativeExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    educationalId?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlternativeExerciseCountOrderByAggregateInput
    _avg?: AlternativeExerciseAvgOrderByAggregateInput
    _max?: AlternativeExerciseMaxOrderByAggregateInput
    _min?: AlternativeExerciseMinOrderByAggregateInput
    _sum?: AlternativeExerciseSumOrderByAggregateInput
  }

  export type AlternativeExerciseScalarWhereWithAggregatesInput = {
    AND?: AlternativeExerciseScalarWhereWithAggregatesInput | AlternativeExerciseScalarWhereWithAggregatesInput[]
    OR?: AlternativeExerciseScalarWhereWithAggregatesInput[]
    NOT?: AlternativeExerciseScalarWhereWithAggregatesInput | AlternativeExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlternativeExercise"> | string
    workoutExerciseId?: StringWithAggregatesFilter<"AlternativeExercise"> | string
    name?: StringWithAggregatesFilter<"AlternativeExercise"> | string
    reason?: StringWithAggregatesFilter<"AlternativeExercise"> | string
    educationalId?: StringNullableWithAggregatesFilter<"AlternativeExercise"> | string | null
    order?: IntWithAggregatesFilter<"AlternativeExercise"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AlternativeExercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlternativeExercise"> | Date | string
  }

  export type WorkoutProgressWhereInput = {
    AND?: WorkoutProgressWhereInput | WorkoutProgressWhereInput[]
    OR?: WorkoutProgressWhereInput[]
    NOT?: WorkoutProgressWhereInput | WorkoutProgressWhereInput[]
    id?: StringFilter<"WorkoutProgress"> | string
    studentId?: StringFilter<"WorkoutProgress"> | string
    workoutId?: StringFilter<"WorkoutProgress"> | string
    currentExerciseIndex?: IntFilter<"WorkoutProgress"> | number
    exerciseLogs?: StringFilter<"WorkoutProgress"> | string
    skippedExercises?: StringNullableFilter<"WorkoutProgress"> | string | null
    selectedAlternatives?: StringNullableFilter<"WorkoutProgress"> | string | null
    xpEarned?: IntFilter<"WorkoutProgress"> | number
    totalVolume?: FloatFilter<"WorkoutProgress"> | number
    completionPercentage?: FloatFilter<"WorkoutProgress"> | number
    startTime?: DateTimeFilter<"WorkoutProgress"> | Date | string
    cardioPreference?: StringNullableFilter<"WorkoutProgress"> | string | null
    cardioDuration?: IntNullableFilter<"WorkoutProgress"> | number | null
    selectedCardioType?: StringNullableFilter<"WorkoutProgress"> | string | null
    createdAt?: DateTimeFilter<"WorkoutProgress"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutProgress"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    workout?: XOR<WorkoutScalarRelationFilter, WorkoutWhereInput>
  }

  export type WorkoutProgressOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    currentExerciseIndex?: SortOrder
    exerciseLogs?: SortOrder
    skippedExercises?: SortOrderInput | SortOrder
    selectedAlternatives?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    startTime?: SortOrder
    cardioPreference?: SortOrderInput | SortOrder
    cardioDuration?: SortOrderInput | SortOrder
    selectedCardioType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    workout?: WorkoutOrderByWithRelationInput
  }

  export type WorkoutProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_workoutId?: WorkoutProgressStudentIdWorkoutIdCompoundUniqueInput
    AND?: WorkoutProgressWhereInput | WorkoutProgressWhereInput[]
    OR?: WorkoutProgressWhereInput[]
    NOT?: WorkoutProgressWhereInput | WorkoutProgressWhereInput[]
    studentId?: StringFilter<"WorkoutProgress"> | string
    workoutId?: StringFilter<"WorkoutProgress"> | string
    currentExerciseIndex?: IntFilter<"WorkoutProgress"> | number
    exerciseLogs?: StringFilter<"WorkoutProgress"> | string
    skippedExercises?: StringNullableFilter<"WorkoutProgress"> | string | null
    selectedAlternatives?: StringNullableFilter<"WorkoutProgress"> | string | null
    xpEarned?: IntFilter<"WorkoutProgress"> | number
    totalVolume?: FloatFilter<"WorkoutProgress"> | number
    completionPercentage?: FloatFilter<"WorkoutProgress"> | number
    startTime?: DateTimeFilter<"WorkoutProgress"> | Date | string
    cardioPreference?: StringNullableFilter<"WorkoutProgress"> | string | null
    cardioDuration?: IntNullableFilter<"WorkoutProgress"> | number | null
    selectedCardioType?: StringNullableFilter<"WorkoutProgress"> | string | null
    createdAt?: DateTimeFilter<"WorkoutProgress"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutProgress"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    workout?: XOR<WorkoutScalarRelationFilter, WorkoutWhereInput>
  }, "id" | "studentId_workoutId">

  export type WorkoutProgressOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    currentExerciseIndex?: SortOrder
    exerciseLogs?: SortOrder
    skippedExercises?: SortOrderInput | SortOrder
    selectedAlternatives?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    startTime?: SortOrder
    cardioPreference?: SortOrderInput | SortOrder
    cardioDuration?: SortOrderInput | SortOrder
    selectedCardioType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkoutProgressCountOrderByAggregateInput
    _avg?: WorkoutProgressAvgOrderByAggregateInput
    _max?: WorkoutProgressMaxOrderByAggregateInput
    _min?: WorkoutProgressMinOrderByAggregateInput
    _sum?: WorkoutProgressSumOrderByAggregateInput
  }

  export type WorkoutProgressScalarWhereWithAggregatesInput = {
    AND?: WorkoutProgressScalarWhereWithAggregatesInput | WorkoutProgressScalarWhereWithAggregatesInput[]
    OR?: WorkoutProgressScalarWhereWithAggregatesInput[]
    NOT?: WorkoutProgressScalarWhereWithAggregatesInput | WorkoutProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutProgress"> | string
    studentId?: StringWithAggregatesFilter<"WorkoutProgress"> | string
    workoutId?: StringWithAggregatesFilter<"WorkoutProgress"> | string
    currentExerciseIndex?: IntWithAggregatesFilter<"WorkoutProgress"> | number
    exerciseLogs?: StringWithAggregatesFilter<"WorkoutProgress"> | string
    skippedExercises?: StringNullableWithAggregatesFilter<"WorkoutProgress"> | string | null
    selectedAlternatives?: StringNullableWithAggregatesFilter<"WorkoutProgress"> | string | null
    xpEarned?: IntWithAggregatesFilter<"WorkoutProgress"> | number
    totalVolume?: FloatWithAggregatesFilter<"WorkoutProgress"> | number
    completionPercentage?: FloatWithAggregatesFilter<"WorkoutProgress"> | number
    startTime?: DateTimeWithAggregatesFilter<"WorkoutProgress"> | Date | string
    cardioPreference?: StringNullableWithAggregatesFilter<"WorkoutProgress"> | string | null
    cardioDuration?: IntNullableWithAggregatesFilter<"WorkoutProgress"> | number | null
    selectedCardioType?: StringNullableWithAggregatesFilter<"WorkoutProgress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkoutProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkoutProgress"> | Date | string
  }

  export type WorkoutHistoryWhereInput = {
    AND?: WorkoutHistoryWhereInput | WorkoutHistoryWhereInput[]
    OR?: WorkoutHistoryWhereInput[]
    NOT?: WorkoutHistoryWhereInput | WorkoutHistoryWhereInput[]
    id?: StringFilter<"WorkoutHistory"> | string
    studentId?: StringFilter<"WorkoutHistory"> | string
    workoutId?: StringNullableFilter<"WorkoutHistory"> | string | null
    date?: DateTimeFilter<"WorkoutHistory"> | Date | string
    duration?: IntFilter<"WorkoutHistory"> | number
    totalVolume?: FloatNullableFilter<"WorkoutHistory"> | number | null
    overallFeedback?: StringNullableFilter<"WorkoutHistory"> | string | null
    bodyPartsFatigued?: StringNullableFilter<"WorkoutHistory"> | string | null
    createdAt?: DateTimeFilter<"WorkoutHistory"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    workout?: XOR<WorkoutNullableScalarRelationFilter, WorkoutWhereInput> | null
    exercises?: ExerciseLogListRelationFilter
    records?: PersonalRecordListRelationFilter
  }

  export type WorkoutHistoryOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrderInput | SortOrder
    date?: SortOrder
    duration?: SortOrder
    totalVolume?: SortOrderInput | SortOrder
    overallFeedback?: SortOrderInput | SortOrder
    bodyPartsFatigued?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    workout?: WorkoutOrderByWithRelationInput
    exercises?: ExerciseLogOrderByRelationAggregateInput
    records?: PersonalRecordOrderByRelationAggregateInput
  }

  export type WorkoutHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutHistoryWhereInput | WorkoutHistoryWhereInput[]
    OR?: WorkoutHistoryWhereInput[]
    NOT?: WorkoutHistoryWhereInput | WorkoutHistoryWhereInput[]
    studentId?: StringFilter<"WorkoutHistory"> | string
    workoutId?: StringNullableFilter<"WorkoutHistory"> | string | null
    date?: DateTimeFilter<"WorkoutHistory"> | Date | string
    duration?: IntFilter<"WorkoutHistory"> | number
    totalVolume?: FloatNullableFilter<"WorkoutHistory"> | number | null
    overallFeedback?: StringNullableFilter<"WorkoutHistory"> | string | null
    bodyPartsFatigued?: StringNullableFilter<"WorkoutHistory"> | string | null
    createdAt?: DateTimeFilter<"WorkoutHistory"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    workout?: XOR<WorkoutNullableScalarRelationFilter, WorkoutWhereInput> | null
    exercises?: ExerciseLogListRelationFilter
    records?: PersonalRecordListRelationFilter
  }, "id">

  export type WorkoutHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrderInput | SortOrder
    date?: SortOrder
    duration?: SortOrder
    totalVolume?: SortOrderInput | SortOrder
    overallFeedback?: SortOrderInput | SortOrder
    bodyPartsFatigued?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WorkoutHistoryCountOrderByAggregateInput
    _avg?: WorkoutHistoryAvgOrderByAggregateInput
    _max?: WorkoutHistoryMaxOrderByAggregateInput
    _min?: WorkoutHistoryMinOrderByAggregateInput
    _sum?: WorkoutHistorySumOrderByAggregateInput
  }

  export type WorkoutHistoryScalarWhereWithAggregatesInput = {
    AND?: WorkoutHistoryScalarWhereWithAggregatesInput | WorkoutHistoryScalarWhereWithAggregatesInput[]
    OR?: WorkoutHistoryScalarWhereWithAggregatesInput[]
    NOT?: WorkoutHistoryScalarWhereWithAggregatesInput | WorkoutHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutHistory"> | string
    studentId?: StringWithAggregatesFilter<"WorkoutHistory"> | string
    workoutId?: StringNullableWithAggregatesFilter<"WorkoutHistory"> | string | null
    date?: DateTimeWithAggregatesFilter<"WorkoutHistory"> | Date | string
    duration?: IntWithAggregatesFilter<"WorkoutHistory"> | number
    totalVolume?: FloatNullableWithAggregatesFilter<"WorkoutHistory"> | number | null
    overallFeedback?: StringNullableWithAggregatesFilter<"WorkoutHistory"> | string | null
    bodyPartsFatigued?: StringNullableWithAggregatesFilter<"WorkoutHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkoutHistory"> | Date | string
  }

  export type ExerciseLogWhereInput = {
    AND?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    OR?: ExerciseLogWhereInput[]
    NOT?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    id?: StringFilter<"ExerciseLog"> | string
    workoutHistoryId?: StringFilter<"ExerciseLog"> | string
    exerciseId?: StringFilter<"ExerciseLog"> | string
    exerciseName?: StringFilter<"ExerciseLog"> | string
    sets?: StringFilter<"ExerciseLog"> | string
    notes?: StringNullableFilter<"ExerciseLog"> | string | null
    formCheckScore?: IntNullableFilter<"ExerciseLog"> | number | null
    difficulty?: StringNullableFilter<"ExerciseLog"> | string | null
    workoutHistory?: XOR<WorkoutHistoryScalarRelationFilter, WorkoutHistoryWhereInput>
  }

  export type ExerciseLogOrderByWithRelationInput = {
    id?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    sets?: SortOrder
    notes?: SortOrderInput | SortOrder
    formCheckScore?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    workoutHistory?: WorkoutHistoryOrderByWithRelationInput
  }

  export type ExerciseLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    OR?: ExerciseLogWhereInput[]
    NOT?: ExerciseLogWhereInput | ExerciseLogWhereInput[]
    workoutHistoryId?: StringFilter<"ExerciseLog"> | string
    exerciseId?: StringFilter<"ExerciseLog"> | string
    exerciseName?: StringFilter<"ExerciseLog"> | string
    sets?: StringFilter<"ExerciseLog"> | string
    notes?: StringNullableFilter<"ExerciseLog"> | string | null
    formCheckScore?: IntNullableFilter<"ExerciseLog"> | number | null
    difficulty?: StringNullableFilter<"ExerciseLog"> | string | null
    workoutHistory?: XOR<WorkoutHistoryScalarRelationFilter, WorkoutHistoryWhereInput>
  }, "id">

  export type ExerciseLogOrderByWithAggregationInput = {
    id?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    sets?: SortOrder
    notes?: SortOrderInput | SortOrder
    formCheckScore?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    _count?: ExerciseLogCountOrderByAggregateInput
    _avg?: ExerciseLogAvgOrderByAggregateInput
    _max?: ExerciseLogMaxOrderByAggregateInput
    _min?: ExerciseLogMinOrderByAggregateInput
    _sum?: ExerciseLogSumOrderByAggregateInput
  }

  export type ExerciseLogScalarWhereWithAggregatesInput = {
    AND?: ExerciseLogScalarWhereWithAggregatesInput | ExerciseLogScalarWhereWithAggregatesInput[]
    OR?: ExerciseLogScalarWhereWithAggregatesInput[]
    NOT?: ExerciseLogScalarWhereWithAggregatesInput | ExerciseLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciseLog"> | string
    workoutHistoryId?: StringWithAggregatesFilter<"ExerciseLog"> | string
    exerciseId?: StringWithAggregatesFilter<"ExerciseLog"> | string
    exerciseName?: StringWithAggregatesFilter<"ExerciseLog"> | string
    sets?: StringWithAggregatesFilter<"ExerciseLog"> | string
    notes?: StringNullableWithAggregatesFilter<"ExerciseLog"> | string | null
    formCheckScore?: IntNullableWithAggregatesFilter<"ExerciseLog"> | number | null
    difficulty?: StringNullableWithAggregatesFilter<"ExerciseLog"> | string | null
  }

  export type PersonalRecordWhereInput = {
    AND?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    OR?: PersonalRecordWhereInput[]
    NOT?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    id?: StringFilter<"PersonalRecord"> | string
    studentId?: StringFilter<"PersonalRecord"> | string
    workoutHistoryId?: StringNullableFilter<"PersonalRecord"> | string | null
    exerciseId?: StringFilter<"PersonalRecord"> | string
    exerciseName?: StringFilter<"PersonalRecord"> | string
    type?: StringFilter<"PersonalRecord"> | string
    value?: FloatFilter<"PersonalRecord"> | number
    date?: DateTimeFilter<"PersonalRecord"> | Date | string
    previousBest?: FloatNullableFilter<"PersonalRecord"> | number | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    workoutHistory?: XOR<WorkoutHistoryNullableScalarRelationFilter, WorkoutHistoryWhereInput> | null
  }

  export type PersonalRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutHistoryId?: SortOrderInput | SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    type?: SortOrder
    value?: SortOrder
    date?: SortOrder
    previousBest?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    workoutHistory?: WorkoutHistoryOrderByWithRelationInput
  }

  export type PersonalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    OR?: PersonalRecordWhereInput[]
    NOT?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    studentId?: StringFilter<"PersonalRecord"> | string
    workoutHistoryId?: StringNullableFilter<"PersonalRecord"> | string | null
    exerciseId?: StringFilter<"PersonalRecord"> | string
    exerciseName?: StringFilter<"PersonalRecord"> | string
    type?: StringFilter<"PersonalRecord"> | string
    value?: FloatFilter<"PersonalRecord"> | number
    date?: DateTimeFilter<"PersonalRecord"> | Date | string
    previousBest?: FloatNullableFilter<"PersonalRecord"> | number | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    workoutHistory?: XOR<WorkoutHistoryNullableScalarRelationFilter, WorkoutHistoryWhereInput> | null
  }, "id">

  export type PersonalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutHistoryId?: SortOrderInput | SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    type?: SortOrder
    value?: SortOrder
    date?: SortOrder
    previousBest?: SortOrderInput | SortOrder
    _count?: PersonalRecordCountOrderByAggregateInput
    _avg?: PersonalRecordAvgOrderByAggregateInput
    _max?: PersonalRecordMaxOrderByAggregateInput
    _min?: PersonalRecordMinOrderByAggregateInput
    _sum?: PersonalRecordSumOrderByAggregateInput
  }

  export type PersonalRecordScalarWhereWithAggregatesInput = {
    AND?: PersonalRecordScalarWhereWithAggregatesInput | PersonalRecordScalarWhereWithAggregatesInput[]
    OR?: PersonalRecordScalarWhereWithAggregatesInput[]
    NOT?: PersonalRecordScalarWhereWithAggregatesInput | PersonalRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalRecord"> | string
    studentId?: StringWithAggregatesFilter<"PersonalRecord"> | string
    workoutHistoryId?: StringNullableWithAggregatesFilter<"PersonalRecord"> | string | null
    exerciseId?: StringWithAggregatesFilter<"PersonalRecord"> | string
    exerciseName?: StringWithAggregatesFilter<"PersonalRecord"> | string
    type?: StringWithAggregatesFilter<"PersonalRecord"> | string
    value?: FloatWithAggregatesFilter<"PersonalRecord"> | number
    date?: DateTimeWithAggregatesFilter<"PersonalRecord"> | Date | string
    previousBest?: FloatNullableWithAggregatesFilter<"PersonalRecord"> | number | null
  }

  export type DietPlanWhereInput = {
    AND?: DietPlanWhereInput | DietPlanWhereInput[]
    OR?: DietPlanWhereInput[]
    NOT?: DietPlanWhereInput | DietPlanWhereInput[]
    id?: StringFilter<"DietPlan"> | string
    title?: StringFilter<"DietPlan"> | string
    description?: StringNullableFilter<"DietPlan"> | string | null
    totalCalories?: IntFilter<"DietPlan"> | number
    targetProtein?: FloatFilter<"DietPlan"> | number
    targetCarbs?: FloatFilter<"DietPlan"> | number
    targetFats?: FloatFilter<"DietPlan"> | number
    xpReward?: IntFilter<"DietPlan"> | number
    locked?: BoolFilter<"DietPlan"> | boolean
    order?: IntFilter<"DietPlan"> | number
    createdAt?: DateTimeFilter<"DietPlan"> | Date | string
    updatedAt?: DateTimeFilter<"DietPlan"> | Date | string
    meals?: MealListRelationFilter
    completions?: DietPlanCompletionListRelationFilter
  }

  export type DietPlanOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    locked?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meals?: MealOrderByRelationAggregateInput
    completions?: DietPlanCompletionOrderByRelationAggregateInput
  }

  export type DietPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DietPlanWhereInput | DietPlanWhereInput[]
    OR?: DietPlanWhereInput[]
    NOT?: DietPlanWhereInput | DietPlanWhereInput[]
    title?: StringFilter<"DietPlan"> | string
    description?: StringNullableFilter<"DietPlan"> | string | null
    totalCalories?: IntFilter<"DietPlan"> | number
    targetProtein?: FloatFilter<"DietPlan"> | number
    targetCarbs?: FloatFilter<"DietPlan"> | number
    targetFats?: FloatFilter<"DietPlan"> | number
    xpReward?: IntFilter<"DietPlan"> | number
    locked?: BoolFilter<"DietPlan"> | boolean
    order?: IntFilter<"DietPlan"> | number
    createdAt?: DateTimeFilter<"DietPlan"> | Date | string
    updatedAt?: DateTimeFilter<"DietPlan"> | Date | string
    meals?: MealListRelationFilter
    completions?: DietPlanCompletionListRelationFilter
  }, "id">

  export type DietPlanOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    locked?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DietPlanCountOrderByAggregateInput
    _avg?: DietPlanAvgOrderByAggregateInput
    _max?: DietPlanMaxOrderByAggregateInput
    _min?: DietPlanMinOrderByAggregateInput
    _sum?: DietPlanSumOrderByAggregateInput
  }

  export type DietPlanScalarWhereWithAggregatesInput = {
    AND?: DietPlanScalarWhereWithAggregatesInput | DietPlanScalarWhereWithAggregatesInput[]
    OR?: DietPlanScalarWhereWithAggregatesInput[]
    NOT?: DietPlanScalarWhereWithAggregatesInput | DietPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DietPlan"> | string
    title?: StringWithAggregatesFilter<"DietPlan"> | string
    description?: StringNullableWithAggregatesFilter<"DietPlan"> | string | null
    totalCalories?: IntWithAggregatesFilter<"DietPlan"> | number
    targetProtein?: FloatWithAggregatesFilter<"DietPlan"> | number
    targetCarbs?: FloatWithAggregatesFilter<"DietPlan"> | number
    targetFats?: FloatWithAggregatesFilter<"DietPlan"> | number
    xpReward?: IntWithAggregatesFilter<"DietPlan"> | number
    locked?: BoolWithAggregatesFilter<"DietPlan"> | boolean
    order?: IntWithAggregatesFilter<"DietPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DietPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DietPlan"> | Date | string
  }

  export type MealWhereInput = {
    AND?: MealWhereInput | MealWhereInput[]
    OR?: MealWhereInput[]
    NOT?: MealWhereInput | MealWhereInput[]
    id?: StringFilter<"Meal"> | string
    dietPlanId?: StringFilter<"Meal"> | string
    name?: StringFilter<"Meal"> | string
    type?: StringFilter<"Meal"> | string
    calories?: IntFilter<"Meal"> | number
    protein?: FloatFilter<"Meal"> | number
    carbs?: FloatFilter<"Meal"> | number
    fats?: FloatFilter<"Meal"> | number
    time?: StringNullableFilter<"Meal"> | string | null
    image?: StringNullableFilter<"Meal"> | string | null
    ingredients?: StringNullableFilter<"Meal"> | string | null
    order?: IntFilter<"Meal"> | number
    dietPlan?: XOR<DietPlanScalarRelationFilter, DietPlanWhereInput>
  }

  export type MealOrderByWithRelationInput = {
    id?: SortOrder
    dietPlanId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    ingredients?: SortOrderInput | SortOrder
    order?: SortOrder
    dietPlan?: DietPlanOrderByWithRelationInput
  }

  export type MealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MealWhereInput | MealWhereInput[]
    OR?: MealWhereInput[]
    NOT?: MealWhereInput | MealWhereInput[]
    dietPlanId?: StringFilter<"Meal"> | string
    name?: StringFilter<"Meal"> | string
    type?: StringFilter<"Meal"> | string
    calories?: IntFilter<"Meal"> | number
    protein?: FloatFilter<"Meal"> | number
    carbs?: FloatFilter<"Meal"> | number
    fats?: FloatFilter<"Meal"> | number
    time?: StringNullableFilter<"Meal"> | string | null
    image?: StringNullableFilter<"Meal"> | string | null
    ingredients?: StringNullableFilter<"Meal"> | string | null
    order?: IntFilter<"Meal"> | number
    dietPlan?: XOR<DietPlanScalarRelationFilter, DietPlanWhereInput>
  }, "id">

  export type MealOrderByWithAggregationInput = {
    id?: SortOrder
    dietPlanId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    ingredients?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: MealCountOrderByAggregateInput
    _avg?: MealAvgOrderByAggregateInput
    _max?: MealMaxOrderByAggregateInput
    _min?: MealMinOrderByAggregateInput
    _sum?: MealSumOrderByAggregateInput
  }

  export type MealScalarWhereWithAggregatesInput = {
    AND?: MealScalarWhereWithAggregatesInput | MealScalarWhereWithAggregatesInput[]
    OR?: MealScalarWhereWithAggregatesInput[]
    NOT?: MealScalarWhereWithAggregatesInput | MealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meal"> | string
    dietPlanId?: StringWithAggregatesFilter<"Meal"> | string
    name?: StringWithAggregatesFilter<"Meal"> | string
    type?: StringWithAggregatesFilter<"Meal"> | string
    calories?: IntWithAggregatesFilter<"Meal"> | number
    protein?: FloatWithAggregatesFilter<"Meal"> | number
    carbs?: FloatWithAggregatesFilter<"Meal"> | number
    fats?: FloatWithAggregatesFilter<"Meal"> | number
    time?: StringNullableWithAggregatesFilter<"Meal"> | string | null
    image?: StringNullableWithAggregatesFilter<"Meal"> | string | null
    ingredients?: StringNullableWithAggregatesFilter<"Meal"> | string | null
    order?: IntWithAggregatesFilter<"Meal"> | number
  }

  export type DietPlanCompletionWhereInput = {
    AND?: DietPlanCompletionWhereInput | DietPlanCompletionWhereInput[]
    OR?: DietPlanCompletionWhereInput[]
    NOT?: DietPlanCompletionWhereInput | DietPlanCompletionWhereInput[]
    id?: StringFilter<"DietPlanCompletion"> | string
    studentId?: StringFilter<"DietPlanCompletion"> | string
    dietPlanId?: StringFilter<"DietPlanCompletion"> | string
    date?: DateTimeFilter<"DietPlanCompletion"> | Date | string
    completed?: BoolFilter<"DietPlanCompletion"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    dietPlan?: XOR<DietPlanScalarRelationFilter, DietPlanWhereInput>
  }

  export type DietPlanCompletionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    dietPlanId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    student?: StudentOrderByWithRelationInput
    dietPlan?: DietPlanOrderByWithRelationInput
  }

  export type DietPlanCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DietPlanCompletionWhereInput | DietPlanCompletionWhereInput[]
    OR?: DietPlanCompletionWhereInput[]
    NOT?: DietPlanCompletionWhereInput | DietPlanCompletionWhereInput[]
    studentId?: StringFilter<"DietPlanCompletion"> | string
    dietPlanId?: StringFilter<"DietPlanCompletion"> | string
    date?: DateTimeFilter<"DietPlanCompletion"> | Date | string
    completed?: BoolFilter<"DietPlanCompletion"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    dietPlan?: XOR<DietPlanScalarRelationFilter, DietPlanWhereInput>
  }, "id">

  export type DietPlanCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    dietPlanId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    _count?: DietPlanCompletionCountOrderByAggregateInput
    _max?: DietPlanCompletionMaxOrderByAggregateInput
    _min?: DietPlanCompletionMinOrderByAggregateInput
  }

  export type DietPlanCompletionScalarWhereWithAggregatesInput = {
    AND?: DietPlanCompletionScalarWhereWithAggregatesInput | DietPlanCompletionScalarWhereWithAggregatesInput[]
    OR?: DietPlanCompletionScalarWhereWithAggregatesInput[]
    NOT?: DietPlanCompletionScalarWhereWithAggregatesInput | DietPlanCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DietPlanCompletion"> | string
    studentId?: StringWithAggregatesFilter<"DietPlanCompletion"> | string
    dietPlanId?: StringWithAggregatesFilter<"DietPlanCompletion"> | string
    date?: DateTimeWithAggregatesFilter<"DietPlanCompletion"> | Date | string
    completed?: BoolWithAggregatesFilter<"DietPlanCompletion"> | boolean
  }

  export type DailyNutritionWhereInput = {
    AND?: DailyNutritionWhereInput | DailyNutritionWhereInput[]
    OR?: DailyNutritionWhereInput[]
    NOT?: DailyNutritionWhereInput | DailyNutritionWhereInput[]
    id?: StringFilter<"DailyNutrition"> | string
    studentId?: StringFilter<"DailyNutrition"> | string
    date?: DateTimeFilter<"DailyNutrition"> | Date | string
    waterIntake?: IntFilter<"DailyNutrition"> | number
    createdAt?: DateTimeFilter<"DailyNutrition"> | Date | string
    updatedAt?: DateTimeFilter<"DailyNutrition"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    meals?: NutritionMealListRelationFilter
  }

  export type DailyNutritionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    waterIntake?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    meals?: NutritionMealOrderByRelationAggregateInput
  }

  export type DailyNutritionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date?: DailyNutritionStudentIdDateCompoundUniqueInput
    AND?: DailyNutritionWhereInput | DailyNutritionWhereInput[]
    OR?: DailyNutritionWhereInput[]
    NOT?: DailyNutritionWhereInput | DailyNutritionWhereInput[]
    studentId?: StringFilter<"DailyNutrition"> | string
    date?: DateTimeFilter<"DailyNutrition"> | Date | string
    waterIntake?: IntFilter<"DailyNutrition"> | number
    createdAt?: DateTimeFilter<"DailyNutrition"> | Date | string
    updatedAt?: DateTimeFilter<"DailyNutrition"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    meals?: NutritionMealListRelationFilter
  }, "id" | "studentId_date">

  export type DailyNutritionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    waterIntake?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyNutritionCountOrderByAggregateInput
    _avg?: DailyNutritionAvgOrderByAggregateInput
    _max?: DailyNutritionMaxOrderByAggregateInput
    _min?: DailyNutritionMinOrderByAggregateInput
    _sum?: DailyNutritionSumOrderByAggregateInput
  }

  export type DailyNutritionScalarWhereWithAggregatesInput = {
    AND?: DailyNutritionScalarWhereWithAggregatesInput | DailyNutritionScalarWhereWithAggregatesInput[]
    OR?: DailyNutritionScalarWhereWithAggregatesInput[]
    NOT?: DailyNutritionScalarWhereWithAggregatesInput | DailyNutritionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyNutrition"> | string
    studentId?: StringWithAggregatesFilter<"DailyNutrition"> | string
    date?: DateTimeWithAggregatesFilter<"DailyNutrition"> | Date | string
    waterIntake?: IntWithAggregatesFilter<"DailyNutrition"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyNutrition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyNutrition"> | Date | string
  }

  export type NutritionMealWhereInput = {
    AND?: NutritionMealWhereInput | NutritionMealWhereInput[]
    OR?: NutritionMealWhereInput[]
    NOT?: NutritionMealWhereInput | NutritionMealWhereInput[]
    id?: StringFilter<"NutritionMeal"> | string
    dailyNutritionId?: StringFilter<"NutritionMeal"> | string
    name?: StringFilter<"NutritionMeal"> | string
    type?: StringFilter<"NutritionMeal"> | string
    calories?: IntFilter<"NutritionMeal"> | number
    protein?: FloatFilter<"NutritionMeal"> | number
    carbs?: FloatFilter<"NutritionMeal"> | number
    fats?: FloatFilter<"NutritionMeal"> | number
    time?: StringNullableFilter<"NutritionMeal"> | string | null
    completed?: BoolFilter<"NutritionMeal"> | boolean
    order?: IntFilter<"NutritionMeal"> | number
    createdAt?: DateTimeFilter<"NutritionMeal"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionMeal"> | Date | string
    dailyNutrition?: XOR<DailyNutritionScalarRelationFilter, DailyNutritionWhereInput>
    foods?: NutritionFoodItemListRelationFilter
  }

  export type NutritionMealOrderByWithRelationInput = {
    id?: SortOrder
    dailyNutritionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrderInput | SortOrder
    completed?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dailyNutrition?: DailyNutritionOrderByWithRelationInput
    foods?: NutritionFoodItemOrderByRelationAggregateInput
  }

  export type NutritionMealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NutritionMealWhereInput | NutritionMealWhereInput[]
    OR?: NutritionMealWhereInput[]
    NOT?: NutritionMealWhereInput | NutritionMealWhereInput[]
    dailyNutritionId?: StringFilter<"NutritionMeal"> | string
    name?: StringFilter<"NutritionMeal"> | string
    type?: StringFilter<"NutritionMeal"> | string
    calories?: IntFilter<"NutritionMeal"> | number
    protein?: FloatFilter<"NutritionMeal"> | number
    carbs?: FloatFilter<"NutritionMeal"> | number
    fats?: FloatFilter<"NutritionMeal"> | number
    time?: StringNullableFilter<"NutritionMeal"> | string | null
    completed?: BoolFilter<"NutritionMeal"> | boolean
    order?: IntFilter<"NutritionMeal"> | number
    createdAt?: DateTimeFilter<"NutritionMeal"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionMeal"> | Date | string
    dailyNutrition?: XOR<DailyNutritionScalarRelationFilter, DailyNutritionWhereInput>
    foods?: NutritionFoodItemListRelationFilter
  }, "id">

  export type NutritionMealOrderByWithAggregationInput = {
    id?: SortOrder
    dailyNutritionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrderInput | SortOrder
    completed?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NutritionMealCountOrderByAggregateInput
    _avg?: NutritionMealAvgOrderByAggregateInput
    _max?: NutritionMealMaxOrderByAggregateInput
    _min?: NutritionMealMinOrderByAggregateInput
    _sum?: NutritionMealSumOrderByAggregateInput
  }

  export type NutritionMealScalarWhereWithAggregatesInput = {
    AND?: NutritionMealScalarWhereWithAggregatesInput | NutritionMealScalarWhereWithAggregatesInput[]
    OR?: NutritionMealScalarWhereWithAggregatesInput[]
    NOT?: NutritionMealScalarWhereWithAggregatesInput | NutritionMealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionMeal"> | string
    dailyNutritionId?: StringWithAggregatesFilter<"NutritionMeal"> | string
    name?: StringWithAggregatesFilter<"NutritionMeal"> | string
    type?: StringWithAggregatesFilter<"NutritionMeal"> | string
    calories?: IntWithAggregatesFilter<"NutritionMeal"> | number
    protein?: FloatWithAggregatesFilter<"NutritionMeal"> | number
    carbs?: FloatWithAggregatesFilter<"NutritionMeal"> | number
    fats?: FloatWithAggregatesFilter<"NutritionMeal"> | number
    time?: StringNullableWithAggregatesFilter<"NutritionMeal"> | string | null
    completed?: BoolWithAggregatesFilter<"NutritionMeal"> | boolean
    order?: IntWithAggregatesFilter<"NutritionMeal"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NutritionMeal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NutritionMeal"> | Date | string
  }

  export type NutritionFoodItemWhereInput = {
    AND?: NutritionFoodItemWhereInput | NutritionFoodItemWhereInput[]
    OR?: NutritionFoodItemWhereInput[]
    NOT?: NutritionFoodItemWhereInput | NutritionFoodItemWhereInput[]
    id?: StringFilter<"NutritionFoodItem"> | string
    nutritionMealId?: StringFilter<"NutritionFoodItem"> | string
    foodId?: StringNullableFilter<"NutritionFoodItem"> | string | null
    foodName?: StringFilter<"NutritionFoodItem"> | string
    servings?: FloatFilter<"NutritionFoodItem"> | number
    calories?: IntFilter<"NutritionFoodItem"> | number
    protein?: FloatFilter<"NutritionFoodItem"> | number
    carbs?: FloatFilter<"NutritionFoodItem"> | number
    fats?: FloatFilter<"NutritionFoodItem"> | number
    servingSize?: StringFilter<"NutritionFoodItem"> | string
    createdAt?: DateTimeFilter<"NutritionFoodItem"> | Date | string
    nutritionMeal?: XOR<NutritionMealScalarRelationFilter, NutritionMealWhereInput>
  }

  export type NutritionFoodItemOrderByWithRelationInput = {
    id?: SortOrder
    nutritionMealId?: SortOrder
    foodId?: SortOrderInput | SortOrder
    foodName?: SortOrder
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    createdAt?: SortOrder
    nutritionMeal?: NutritionMealOrderByWithRelationInput
  }

  export type NutritionFoodItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NutritionFoodItemWhereInput | NutritionFoodItemWhereInput[]
    OR?: NutritionFoodItemWhereInput[]
    NOT?: NutritionFoodItemWhereInput | NutritionFoodItemWhereInput[]
    nutritionMealId?: StringFilter<"NutritionFoodItem"> | string
    foodId?: StringNullableFilter<"NutritionFoodItem"> | string | null
    foodName?: StringFilter<"NutritionFoodItem"> | string
    servings?: FloatFilter<"NutritionFoodItem"> | number
    calories?: IntFilter<"NutritionFoodItem"> | number
    protein?: FloatFilter<"NutritionFoodItem"> | number
    carbs?: FloatFilter<"NutritionFoodItem"> | number
    fats?: FloatFilter<"NutritionFoodItem"> | number
    servingSize?: StringFilter<"NutritionFoodItem"> | string
    createdAt?: DateTimeFilter<"NutritionFoodItem"> | Date | string
    nutritionMeal?: XOR<NutritionMealScalarRelationFilter, NutritionMealWhereInput>
  }, "id">

  export type NutritionFoodItemOrderByWithAggregationInput = {
    id?: SortOrder
    nutritionMealId?: SortOrder
    foodId?: SortOrderInput | SortOrder
    foodName?: SortOrder
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    createdAt?: SortOrder
    _count?: NutritionFoodItemCountOrderByAggregateInput
    _avg?: NutritionFoodItemAvgOrderByAggregateInput
    _max?: NutritionFoodItemMaxOrderByAggregateInput
    _min?: NutritionFoodItemMinOrderByAggregateInput
    _sum?: NutritionFoodItemSumOrderByAggregateInput
  }

  export type NutritionFoodItemScalarWhereWithAggregatesInput = {
    AND?: NutritionFoodItemScalarWhereWithAggregatesInput | NutritionFoodItemScalarWhereWithAggregatesInput[]
    OR?: NutritionFoodItemScalarWhereWithAggregatesInput[]
    NOT?: NutritionFoodItemScalarWhereWithAggregatesInput | NutritionFoodItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionFoodItem"> | string
    nutritionMealId?: StringWithAggregatesFilter<"NutritionFoodItem"> | string
    foodId?: StringNullableWithAggregatesFilter<"NutritionFoodItem"> | string | null
    foodName?: StringWithAggregatesFilter<"NutritionFoodItem"> | string
    servings?: FloatWithAggregatesFilter<"NutritionFoodItem"> | number
    calories?: IntWithAggregatesFilter<"NutritionFoodItem"> | number
    protein?: FloatWithAggregatesFilter<"NutritionFoodItem"> | number
    carbs?: FloatWithAggregatesFilter<"NutritionFoodItem"> | number
    fats?: FloatWithAggregatesFilter<"NutritionFoodItem"> | number
    servingSize?: StringWithAggregatesFilter<"NutritionFoodItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NutritionFoodItem"> | Date | string
  }

  export type NutritionChatUsageWhereInput = {
    AND?: NutritionChatUsageWhereInput | NutritionChatUsageWhereInput[]
    OR?: NutritionChatUsageWhereInput[]
    NOT?: NutritionChatUsageWhereInput | NutritionChatUsageWhereInput[]
    id?: StringFilter<"NutritionChatUsage"> | string
    studentId?: StringFilter<"NutritionChatUsage"> | string
    date?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    messageCount?: IntFilter<"NutritionChatUsage"> | number
    createdAt?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type NutritionChatUsageOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type NutritionChatUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date?: NutritionChatUsageStudentIdDateCompoundUniqueInput
    AND?: NutritionChatUsageWhereInput | NutritionChatUsageWhereInput[]
    OR?: NutritionChatUsageWhereInput[]
    NOT?: NutritionChatUsageWhereInput | NutritionChatUsageWhereInput[]
    studentId?: StringFilter<"NutritionChatUsage"> | string
    date?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    messageCount?: IntFilter<"NutritionChatUsage"> | number
    createdAt?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId_date">

  export type NutritionChatUsageOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NutritionChatUsageCountOrderByAggregateInput
    _avg?: NutritionChatUsageAvgOrderByAggregateInput
    _max?: NutritionChatUsageMaxOrderByAggregateInput
    _min?: NutritionChatUsageMinOrderByAggregateInput
    _sum?: NutritionChatUsageSumOrderByAggregateInput
  }

  export type NutritionChatUsageScalarWhereWithAggregatesInput = {
    AND?: NutritionChatUsageScalarWhereWithAggregatesInput | NutritionChatUsageScalarWhereWithAggregatesInput[]
    OR?: NutritionChatUsageScalarWhereWithAggregatesInput[]
    NOT?: NutritionChatUsageScalarWhereWithAggregatesInput | NutritionChatUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionChatUsage"> | string
    studentId?: StringWithAggregatesFilter<"NutritionChatUsage"> | string
    date?: DateTimeWithAggregatesFilter<"NutritionChatUsage"> | Date | string
    messageCount?: IntWithAggregatesFilter<"NutritionChatUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NutritionChatUsage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NutritionChatUsage"> | Date | string
  }

  export type FoodItemWhereInput = {
    AND?: FoodItemWhereInput | FoodItemWhereInput[]
    OR?: FoodItemWhereInput[]
    NOT?: FoodItemWhereInput | FoodItemWhereInput[]
    id?: StringFilter<"FoodItem"> | string
    name?: StringFilter<"FoodItem"> | string
    calories?: IntFilter<"FoodItem"> | number
    protein?: FloatFilter<"FoodItem"> | number
    carbs?: FloatFilter<"FoodItem"> | number
    fats?: FloatFilter<"FoodItem"> | number
    servingSize?: StringFilter<"FoodItem"> | string
    category?: StringFilter<"FoodItem"> | string
    image?: StringNullableFilter<"FoodItem"> | string | null
    createdAt?: DateTimeFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeFilter<"FoodItem"> | Date | string
  }

  export type FoodItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    category?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FoodItemWhereInput | FoodItemWhereInput[]
    OR?: FoodItemWhereInput[]
    NOT?: FoodItemWhereInput | FoodItemWhereInput[]
    name?: StringFilter<"FoodItem"> | string
    calories?: IntFilter<"FoodItem"> | number
    protein?: FloatFilter<"FoodItem"> | number
    carbs?: FloatFilter<"FoodItem"> | number
    fats?: FloatFilter<"FoodItem"> | number
    servingSize?: StringFilter<"FoodItem"> | string
    category?: StringFilter<"FoodItem"> | string
    image?: StringNullableFilter<"FoodItem"> | string | null
    createdAt?: DateTimeFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeFilter<"FoodItem"> | Date | string
  }, "id">

  export type FoodItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    category?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodItemCountOrderByAggregateInput
    _avg?: FoodItemAvgOrderByAggregateInput
    _max?: FoodItemMaxOrderByAggregateInput
    _min?: FoodItemMinOrderByAggregateInput
    _sum?: FoodItemSumOrderByAggregateInput
  }

  export type FoodItemScalarWhereWithAggregatesInput = {
    AND?: FoodItemScalarWhereWithAggregatesInput | FoodItemScalarWhereWithAggregatesInput[]
    OR?: FoodItemScalarWhereWithAggregatesInput[]
    NOT?: FoodItemScalarWhereWithAggregatesInput | FoodItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodItem"> | string
    name?: StringWithAggregatesFilter<"FoodItem"> | string
    calories?: IntWithAggregatesFilter<"FoodItem"> | number
    protein?: FloatWithAggregatesFilter<"FoodItem"> | number
    carbs?: FloatWithAggregatesFilter<"FoodItem"> | number
    fats?: FloatWithAggregatesFilter<"FoodItem"> | number
    servingSize?: StringWithAggregatesFilter<"FoodItem"> | string
    category?: StringWithAggregatesFilter<"FoodItem"> | string
    image?: StringNullableWithAggregatesFilter<"FoodItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodItem"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringFilter<"Achievement"> | string
    level?: IntNullableFilter<"Achievement"> | number | null
    color?: StringNullableFilter<"Achievement"> | string | null
    target?: IntNullableFilter<"Achievement"> | number | null
    xpReward?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    unlocks?: AchievementUnlockListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    level?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    xpReward?: SortOrder
    createdAt?: SortOrder
    unlocks?: AchievementUnlockOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringNullableFilter<"Achievement"> | string | null
    icon?: StringNullableFilter<"Achievement"> | string | null
    category?: StringFilter<"Achievement"> | string
    level?: IntNullableFilter<"Achievement"> | number | null
    color?: StringNullableFilter<"Achievement"> | string | null
    target?: IntNullableFilter<"Achievement"> | number | null
    xpReward?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    unlocks?: AchievementUnlockListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    level?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    xpReward?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    category?: StringWithAggregatesFilter<"Achievement"> | string
    level?: IntNullableWithAggregatesFilter<"Achievement"> | number | null
    color?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    target?: IntNullableWithAggregatesFilter<"Achievement"> | number | null
    xpReward?: IntWithAggregatesFilter<"Achievement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type AchievementUnlockWhereInput = {
    AND?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    OR?: AchievementUnlockWhereInput[]
    NOT?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    id?: StringFilter<"AchievementUnlock"> | string
    studentId?: StringFilter<"AchievementUnlock"> | string
    achievementId?: StringFilter<"AchievementUnlock"> | string
    progress?: IntNullableFilter<"AchievementUnlock"> | number | null
    unlockedAt?: DateTimeFilter<"AchievementUnlock"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type AchievementUnlockOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrderInput | SortOrder
    unlockedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type AchievementUnlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    OR?: AchievementUnlockWhereInput[]
    NOT?: AchievementUnlockWhereInput | AchievementUnlockWhereInput[]
    studentId?: StringFilter<"AchievementUnlock"> | string
    achievementId?: StringFilter<"AchievementUnlock"> | string
    progress?: IntNullableFilter<"AchievementUnlock"> | number | null
    unlockedAt?: DateTimeFilter<"AchievementUnlock"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id">

  export type AchievementUnlockOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrderInput | SortOrder
    unlockedAt?: SortOrder
    _count?: AchievementUnlockCountOrderByAggregateInput
    _avg?: AchievementUnlockAvgOrderByAggregateInput
    _max?: AchievementUnlockMaxOrderByAggregateInput
    _min?: AchievementUnlockMinOrderByAggregateInput
    _sum?: AchievementUnlockSumOrderByAggregateInput
  }

  export type AchievementUnlockScalarWhereWithAggregatesInput = {
    AND?: AchievementUnlockScalarWhereWithAggregatesInput | AchievementUnlockScalarWhereWithAggregatesInput[]
    OR?: AchievementUnlockScalarWhereWithAggregatesInput[]
    NOT?: AchievementUnlockScalarWhereWithAggregatesInput | AchievementUnlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AchievementUnlock"> | string
    studentId?: StringWithAggregatesFilter<"AchievementUnlock"> | string
    achievementId?: StringWithAggregatesFilter<"AchievementUnlock"> | string
    progress?: IntNullableWithAggregatesFilter<"AchievementUnlock"> | number | null
    unlockedAt?: DateTimeWithAggregatesFilter<"AchievementUnlock"> | Date | string
  }

  export type GymUserPreferenceWhereInput = {
    AND?: GymUserPreferenceWhereInput | GymUserPreferenceWhereInput[]
    OR?: GymUserPreferenceWhereInput[]
    NOT?: GymUserPreferenceWhereInput | GymUserPreferenceWhereInput[]
    id?: StringFilter<"GymUserPreference"> | string
    userId?: StringFilter<"GymUserPreference"> | string
    lastActiveGymId?: StringNullableFilter<"GymUserPreference"> | string | null
    createdAt?: DateTimeFilter<"GymUserPreference"> | Date | string
    updatedAt?: DateTimeFilter<"GymUserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GymUserPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lastActiveGymId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GymUserPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GymUserPreferenceWhereInput | GymUserPreferenceWhereInput[]
    OR?: GymUserPreferenceWhereInput[]
    NOT?: GymUserPreferenceWhereInput | GymUserPreferenceWhereInput[]
    lastActiveGymId?: StringNullableFilter<"GymUserPreference"> | string | null
    createdAt?: DateTimeFilter<"GymUserPreference"> | Date | string
    updatedAt?: DateTimeFilter<"GymUserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type GymUserPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lastActiveGymId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymUserPreferenceCountOrderByAggregateInput
    _max?: GymUserPreferenceMaxOrderByAggregateInput
    _min?: GymUserPreferenceMinOrderByAggregateInput
  }

  export type GymUserPreferenceScalarWhereWithAggregatesInput = {
    AND?: GymUserPreferenceScalarWhereWithAggregatesInput | GymUserPreferenceScalarWhereWithAggregatesInput[]
    OR?: GymUserPreferenceScalarWhereWithAggregatesInput[]
    NOT?: GymUserPreferenceScalarWhereWithAggregatesInput | GymUserPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymUserPreference"> | string
    userId?: StringWithAggregatesFilter<"GymUserPreference"> | string
    lastActiveGymId?: StringNullableWithAggregatesFilter<"GymUserPreference"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GymUserPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymUserPreference"> | Date | string
  }

  export type GymMembershipWhereInput = {
    AND?: GymMembershipWhereInput | GymMembershipWhereInput[]
    OR?: GymMembershipWhereInput[]
    NOT?: GymMembershipWhereInput | GymMembershipWhereInput[]
    id?: StringFilter<"GymMembership"> | string
    gymId?: StringFilter<"GymMembership"> | string
    studentId?: StringFilter<"GymMembership"> | string
    planId?: StringNullableFilter<"GymMembership"> | string | null
    startDate?: DateTimeFilter<"GymMembership"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"GymMembership"> | Date | string | null
    amount?: FloatFilter<"GymMembership"> | number
    status?: StringFilter<"GymMembership"> | string
    autoRenew?: BoolFilter<"GymMembership"> | boolean
    createdAt?: DateTimeFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeFilter<"GymMembership"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    plan?: XOR<MembershipPlanNullableScalarRelationFilter, MembershipPlanWhereInput> | null
  }

  export type GymMembershipOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    planId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    plan?: MembershipPlanOrderByWithRelationInput
  }

  export type GymMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GymMembershipWhereInput | GymMembershipWhereInput[]
    OR?: GymMembershipWhereInput[]
    NOT?: GymMembershipWhereInput | GymMembershipWhereInput[]
    gymId?: StringFilter<"GymMembership"> | string
    studentId?: StringFilter<"GymMembership"> | string
    planId?: StringNullableFilter<"GymMembership"> | string | null
    startDate?: DateTimeFilter<"GymMembership"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"GymMembership"> | Date | string | null
    amount?: FloatFilter<"GymMembership"> | number
    status?: StringFilter<"GymMembership"> | string
    autoRenew?: BoolFilter<"GymMembership"> | boolean
    createdAt?: DateTimeFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeFilter<"GymMembership"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    plan?: XOR<MembershipPlanNullableScalarRelationFilter, MembershipPlanWhereInput> | null
  }, "id">

  export type GymMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    planId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymMembershipCountOrderByAggregateInput
    _avg?: GymMembershipAvgOrderByAggregateInput
    _max?: GymMembershipMaxOrderByAggregateInput
    _min?: GymMembershipMinOrderByAggregateInput
    _sum?: GymMembershipSumOrderByAggregateInput
  }

  export type GymMembershipScalarWhereWithAggregatesInput = {
    AND?: GymMembershipScalarWhereWithAggregatesInput | GymMembershipScalarWhereWithAggregatesInput[]
    OR?: GymMembershipScalarWhereWithAggregatesInput[]
    NOT?: GymMembershipScalarWhereWithAggregatesInput | GymMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymMembership"> | string
    gymId?: StringWithAggregatesFilter<"GymMembership"> | string
    studentId?: StringWithAggregatesFilter<"GymMembership"> | string
    planId?: StringNullableWithAggregatesFilter<"GymMembership"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"GymMembership"> | Date | string
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"GymMembership"> | Date | string | null
    amount?: FloatWithAggregatesFilter<"GymMembership"> | number
    status?: StringWithAggregatesFilter<"GymMembership"> | string
    autoRenew?: BoolWithAggregatesFilter<"GymMembership"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymMembership"> | Date | string
  }

  export type MembershipPlanWhereInput = {
    AND?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    OR?: MembershipPlanWhereInput[]
    NOT?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    id?: StringFilter<"MembershipPlan"> | string
    gymId?: StringFilter<"MembershipPlan"> | string
    name?: StringFilter<"MembershipPlan"> | string
    type?: StringFilter<"MembershipPlan"> | string
    price?: FloatFilter<"MembershipPlan"> | number
    duration?: IntFilter<"MembershipPlan"> | number
    benefits?: StringNullableFilter<"MembershipPlan"> | string | null
    isActive?: BoolFilter<"MembershipPlan"> | boolean
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    memberships?: GymMembershipListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type MembershipPlanOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    benefits?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
    memberships?: GymMembershipOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type MembershipPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    OR?: MembershipPlanWhereInput[]
    NOT?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    gymId?: StringFilter<"MembershipPlan"> | string
    name?: StringFilter<"MembershipPlan"> | string
    type?: StringFilter<"MembershipPlan"> | string
    price?: FloatFilter<"MembershipPlan"> | number
    duration?: IntFilter<"MembershipPlan"> | number
    benefits?: StringNullableFilter<"MembershipPlan"> | string | null
    isActive?: BoolFilter<"MembershipPlan"> | boolean
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    memberships?: GymMembershipListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type MembershipPlanOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    benefits?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipPlanCountOrderByAggregateInput
    _avg?: MembershipPlanAvgOrderByAggregateInput
    _max?: MembershipPlanMaxOrderByAggregateInput
    _min?: MembershipPlanMinOrderByAggregateInput
    _sum?: MembershipPlanSumOrderByAggregateInput
  }

  export type MembershipPlanScalarWhereWithAggregatesInput = {
    AND?: MembershipPlanScalarWhereWithAggregatesInput | MembershipPlanScalarWhereWithAggregatesInput[]
    OR?: MembershipPlanScalarWhereWithAggregatesInput[]
    NOT?: MembershipPlanScalarWhereWithAggregatesInput | MembershipPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipPlan"> | string
    gymId?: StringWithAggregatesFilter<"MembershipPlan"> | string
    name?: StringWithAggregatesFilter<"MembershipPlan"> | string
    type?: StringWithAggregatesFilter<"MembershipPlan"> | string
    price?: FloatWithAggregatesFilter<"MembershipPlan"> | number
    duration?: IntWithAggregatesFilter<"MembershipPlan"> | number
    benefits?: StringNullableWithAggregatesFilter<"MembershipPlan"> | string | null
    isActive?: BoolWithAggregatesFilter<"MembershipPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipPlan"> | Date | string
  }

  export type DayPassWhereInput = {
    AND?: DayPassWhereInput | DayPassWhereInput[]
    OR?: DayPassWhereInput[]
    NOT?: DayPassWhereInput | DayPassWhereInput[]
    id?: StringFilter<"DayPass"> | string
    studentId?: StringFilter<"DayPass"> | string
    gymId?: StringFilter<"DayPass"> | string
    gymName?: StringFilter<"DayPass"> | string
    purchaseDate?: DateTimeFilter<"DayPass"> | Date | string
    validDate?: DateTimeFilter<"DayPass"> | Date | string
    price?: FloatFilter<"DayPass"> | number
    status?: StringFilter<"DayPass"> | string
    qrCode?: StringNullableFilter<"DayPass"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type DayPassOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    gymId?: SortOrder
    gymName?: SortOrder
    purchaseDate?: SortOrder
    validDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type DayPassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DayPassWhereInput | DayPassWhereInput[]
    OR?: DayPassWhereInput[]
    NOT?: DayPassWhereInput | DayPassWhereInput[]
    studentId?: StringFilter<"DayPass"> | string
    gymId?: StringFilter<"DayPass"> | string
    gymName?: StringFilter<"DayPass"> | string
    purchaseDate?: DateTimeFilter<"DayPass"> | Date | string
    validDate?: DateTimeFilter<"DayPass"> | Date | string
    price?: FloatFilter<"DayPass"> | number
    status?: StringFilter<"DayPass"> | string
    qrCode?: StringNullableFilter<"DayPass"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type DayPassOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    gymId?: SortOrder
    gymName?: SortOrder
    purchaseDate?: SortOrder
    validDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    _count?: DayPassCountOrderByAggregateInput
    _avg?: DayPassAvgOrderByAggregateInput
    _max?: DayPassMaxOrderByAggregateInput
    _min?: DayPassMinOrderByAggregateInput
    _sum?: DayPassSumOrderByAggregateInput
  }

  export type DayPassScalarWhereWithAggregatesInput = {
    AND?: DayPassScalarWhereWithAggregatesInput | DayPassScalarWhereWithAggregatesInput[]
    OR?: DayPassScalarWhereWithAggregatesInput[]
    NOT?: DayPassScalarWhereWithAggregatesInput | DayPassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DayPass"> | string
    studentId?: StringWithAggregatesFilter<"DayPass"> | string
    gymId?: StringWithAggregatesFilter<"DayPass"> | string
    gymName?: StringWithAggregatesFilter<"DayPass"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"DayPass"> | Date | string
    validDate?: DateTimeWithAggregatesFilter<"DayPass"> | Date | string
    price?: FloatWithAggregatesFilter<"DayPass"> | number
    status?: StringWithAggregatesFilter<"DayPass"> | string
    qrCode?: StringNullableWithAggregatesFilter<"DayPass"> | string | null
  }

  export type CheckInWhereInput = {
    AND?: CheckInWhereInput | CheckInWhereInput[]
    OR?: CheckInWhereInput[]
    NOT?: CheckInWhereInput | CheckInWhereInput[]
    id?: StringFilter<"CheckIn"> | string
    gymId?: StringFilter<"CheckIn"> | string
    studentId?: StringFilter<"CheckIn"> | string
    studentName?: StringFilter<"CheckIn"> | string
    timestamp?: DateTimeFilter<"CheckIn"> | Date | string
    checkOut?: DateTimeNullableFilter<"CheckIn"> | Date | string | null
    duration?: IntNullableFilter<"CheckIn"> | number | null
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type CheckInOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    timestamp?: SortOrder
    checkOut?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type CheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckInWhereInput | CheckInWhereInput[]
    OR?: CheckInWhereInput[]
    NOT?: CheckInWhereInput | CheckInWhereInput[]
    gymId?: StringFilter<"CheckIn"> | string
    studentId?: StringFilter<"CheckIn"> | string
    studentName?: StringFilter<"CheckIn"> | string
    timestamp?: DateTimeFilter<"CheckIn"> | Date | string
    checkOut?: DateTimeNullableFilter<"CheckIn"> | Date | string | null
    duration?: IntNullableFilter<"CheckIn"> | number | null
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id">

  export type CheckInOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    timestamp?: SortOrder
    checkOut?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: CheckInCountOrderByAggregateInput
    _avg?: CheckInAvgOrderByAggregateInput
    _max?: CheckInMaxOrderByAggregateInput
    _min?: CheckInMinOrderByAggregateInput
    _sum?: CheckInSumOrderByAggregateInput
  }

  export type CheckInScalarWhereWithAggregatesInput = {
    AND?: CheckInScalarWhereWithAggregatesInput | CheckInScalarWhereWithAggregatesInput[]
    OR?: CheckInScalarWhereWithAggregatesInput[]
    NOT?: CheckInScalarWhereWithAggregatesInput | CheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckIn"> | string
    gymId?: StringWithAggregatesFilter<"CheckIn"> | string
    studentId?: StringWithAggregatesFilter<"CheckIn"> | string
    studentName?: StringWithAggregatesFilter<"CheckIn"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CheckIn"> | Date | string
    checkOut?: DateTimeNullableWithAggregatesFilter<"CheckIn"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"CheckIn"> | number | null
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    gymId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    brand?: StringNullableFilter<"Equipment"> | string | null
    model?: StringNullableFilter<"Equipment"> | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    status?: StringFilter<"Equipment"> | string
    currentUserId?: StringNullableFilter<"Equipment"> | string | null
    currentUserName?: StringNullableFilter<"Equipment"> | string | null
    currentStartTime?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    qrCode?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    maintenanceHistory?: MaintenanceRecordListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    status?: SortOrder
    currentUserId?: SortOrderInput | SortOrder
    currentUserName?: SortOrderInput | SortOrder
    currentStartTime?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
    maintenanceHistory?: MaintenanceRecordOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    gymId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    brand?: StringNullableFilter<"Equipment"> | string | null
    model?: StringNullableFilter<"Equipment"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    status?: StringFilter<"Equipment"> | string
    currentUserId?: StringNullableFilter<"Equipment"> | string | null
    currentUserName?: StringNullableFilter<"Equipment"> | string | null
    currentStartTime?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    qrCode?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    maintenanceHistory?: MaintenanceRecordListRelationFilter
  }, "id" | "serialNumber">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    status?: SortOrder
    currentUserId?: SortOrderInput | SortOrder
    currentUserName?: SortOrderInput | SortOrder
    currentStartTime?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    gymId?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    type?: StringWithAggregatesFilter<"Equipment"> | string
    brand?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    model?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    status?: StringWithAggregatesFilter<"Equipment"> | string
    currentUserId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    currentUserName?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    currentStartTime?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
  }

  export type MaintenanceRecordWhereInput = {
    AND?: MaintenanceRecordWhereInput | MaintenanceRecordWhereInput[]
    OR?: MaintenanceRecordWhereInput[]
    NOT?: MaintenanceRecordWhereInput | MaintenanceRecordWhereInput[]
    id?: StringFilter<"MaintenanceRecord"> | string
    equipmentId?: StringFilter<"MaintenanceRecord"> | string
    date?: DateTimeFilter<"MaintenanceRecord"> | Date | string
    type?: StringFilter<"MaintenanceRecord"> | string
    description?: StringNullableFilter<"MaintenanceRecord"> | string | null
    performedBy?: StringNullableFilter<"MaintenanceRecord"> | string | null
    cost?: FloatNullableFilter<"MaintenanceRecord"> | number | null
    nextScheduled?: DateTimeNullableFilter<"MaintenanceRecord"> | Date | string | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type MaintenanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    nextScheduled?: SortOrderInput | SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type MaintenanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceRecordWhereInput | MaintenanceRecordWhereInput[]
    OR?: MaintenanceRecordWhereInput[]
    NOT?: MaintenanceRecordWhereInput | MaintenanceRecordWhereInput[]
    equipmentId?: StringFilter<"MaintenanceRecord"> | string
    date?: DateTimeFilter<"MaintenanceRecord"> | Date | string
    type?: StringFilter<"MaintenanceRecord"> | string
    description?: StringNullableFilter<"MaintenanceRecord"> | string | null
    performedBy?: StringNullableFilter<"MaintenanceRecord"> | string | null
    cost?: FloatNullableFilter<"MaintenanceRecord"> | number | null
    nextScheduled?: DateTimeNullableFilter<"MaintenanceRecord"> | Date | string | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type MaintenanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    nextScheduled?: SortOrderInput | SortOrder
    _count?: MaintenanceRecordCountOrderByAggregateInput
    _avg?: MaintenanceRecordAvgOrderByAggregateInput
    _max?: MaintenanceRecordMaxOrderByAggregateInput
    _min?: MaintenanceRecordMinOrderByAggregateInput
    _sum?: MaintenanceRecordSumOrderByAggregateInput
  }

  export type MaintenanceRecordScalarWhereWithAggregatesInput = {
    AND?: MaintenanceRecordScalarWhereWithAggregatesInput | MaintenanceRecordScalarWhereWithAggregatesInput[]
    OR?: MaintenanceRecordScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceRecordScalarWhereWithAggregatesInput | MaintenanceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceRecord"> | string
    equipmentId?: StringWithAggregatesFilter<"MaintenanceRecord"> | string
    date?: DateTimeWithAggregatesFilter<"MaintenanceRecord"> | Date | string
    type?: StringWithAggregatesFilter<"MaintenanceRecord"> | string
    description?: StringNullableWithAggregatesFilter<"MaintenanceRecord"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"MaintenanceRecord"> | string | null
    cost?: FloatNullableWithAggregatesFilter<"MaintenanceRecord"> | number | null
    nextScheduled?: DateTimeNullableWithAggregatesFilter<"MaintenanceRecord"> | Date | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    gymId?: StringFilter<"Payment"> | string
    studentId?: StringFilter<"Payment"> | string
    studentName?: StringFilter<"Payment"> | string
    planId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    date?: DateTimeFilter<"Payment"> | Date | string
    dueDate?: DateTimeFilter<"Payment"> | Date | string
    status?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    plan?: XOR<MembershipPlanNullableScalarRelationFilter, MembershipPlanWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    planId?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
    plan?: MembershipPlanOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    gymId?: StringFilter<"Payment"> | string
    studentId?: StringFilter<"Payment"> | string
    studentName?: StringFilter<"Payment"> | string
    planId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    date?: DateTimeFilter<"Payment"> | Date | string
    dueDate?: DateTimeFilter<"Payment"> | Date | string
    status?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    plan?: XOR<MembershipPlanNullableScalarRelationFilter, MembershipPlanWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    planId?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    gymId?: StringWithAggregatesFilter<"Payment"> | string
    studentId?: StringWithAggregatesFilter<"Payment"> | string
    studentName?: StringWithAggregatesFilter<"Payment"> | string
    planId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    gymId?: StringFilter<"Expense"> | string
    type?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    category?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    gymId?: StringFilter<"Expense"> | string
    type?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    category?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    gymId?: StringWithAggregatesFilter<"Expense"> | string
    type?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    category?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    cardBrand?: StringNullableFilter<"PaymentMethod"> | string | null
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    holderName?: StringNullableFilter<"PaymentMethod"> | string | null
    pixKey?: StringNullableFilter<"PaymentMethod"> | string | null
    pixKeyType?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    cardBrand?: SortOrderInput | SortOrder
    last4?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    holderName?: SortOrderInput | SortOrder
    pixKey?: SortOrderInput | SortOrder
    pixKeyType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    userId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    cardBrand?: StringNullableFilter<"PaymentMethod"> | string | null
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    holderName?: StringNullableFilter<"PaymentMethod"> | string | null
    pixKey?: StringNullableFilter<"PaymentMethod"> | string | null
    pixKeyType?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    cardBrand?: SortOrderInput | SortOrder
    last4?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    holderName?: SortOrderInput | SortOrder
    pixKey?: SortOrderInput | SortOrder
    pixKeyType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    userId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    type?: StringWithAggregatesFilter<"PaymentMethod"> | string
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    cardBrand?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    last4?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    holderName?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    pixKey?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    pixKeyType?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    status?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    user?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    friend?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: StudentOrderByWithRelationInput
    friend?: StudentOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_friendId?: FriendshipUserIdFriendIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    status?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    user?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    friend?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "userId_friendId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    userId?: StringWithAggregatesFilter<"Friendship"> | string
    friendId?: StringWithAggregatesFilter<"Friendship"> | string
    status?: StringWithAggregatesFilter<"Friendship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    studentId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    abacatePayBillingId?: StringNullableFilter<"Subscription"> | string | null
    abacatePayCustomerId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    abacatePayBillingId?: SortOrderInput | SortOrder
    abacatePayCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    abacatePayBillingId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    abacatePayCustomerId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId" | "abacatePayBillingId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    abacatePayBillingId?: SortOrderInput | SortOrder
    abacatePayCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    studentId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    abacatePayBillingId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    abacatePayCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type GymSubscriptionWhereInput = {
    AND?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    OR?: GymSubscriptionWhereInput[]
    NOT?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    id?: StringFilter<"GymSubscription"> | string
    gymId?: StringFilter<"GymSubscription"> | string
    plan?: StringFilter<"GymSubscription"> | string
    billingPeriod?: StringFilter<"GymSubscription"> | string
    status?: StringFilter<"GymSubscription"> | string
    basePrice?: FloatFilter<"GymSubscription"> | number
    pricePerStudent?: FloatFilter<"GymSubscription"> | number
    currentPeriodStart?: DateTimeFilter<"GymSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"GymSubscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"GymSubscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"GymSubscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"GymSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"GymSubscription"> | Date | string | null
    abacatePayBillingId?: StringNullableFilter<"GymSubscription"> | string | null
    abacatePayCustomerId?: StringNullableFilter<"GymSubscription"> | string | null
    createdAt?: DateTimeFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"GymSubscription"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type GymSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    plan?: SortOrder
    billingPeriod?: SortOrder
    status?: SortOrder
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    abacatePayBillingId?: SortOrderInput | SortOrder
    abacatePayCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type GymSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gymId?: string
    abacatePayBillingId?: string
    AND?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    OR?: GymSubscriptionWhereInput[]
    NOT?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    plan?: StringFilter<"GymSubscription"> | string
    billingPeriod?: StringFilter<"GymSubscription"> | string
    status?: StringFilter<"GymSubscription"> | string
    basePrice?: FloatFilter<"GymSubscription"> | number
    pricePerStudent?: FloatFilter<"GymSubscription"> | number
    currentPeriodStart?: DateTimeFilter<"GymSubscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"GymSubscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"GymSubscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"GymSubscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"GymSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"GymSubscription"> | Date | string | null
    abacatePayCustomerId?: StringNullableFilter<"GymSubscription"> | string | null
    createdAt?: DateTimeFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"GymSubscription"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id" | "gymId" | "abacatePayBillingId">

  export type GymSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    plan?: SortOrder
    billingPeriod?: SortOrder
    status?: SortOrder
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    abacatePayBillingId?: SortOrderInput | SortOrder
    abacatePayCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymSubscriptionCountOrderByAggregateInput
    _avg?: GymSubscriptionAvgOrderByAggregateInput
    _max?: GymSubscriptionMaxOrderByAggregateInput
    _min?: GymSubscriptionMinOrderByAggregateInput
    _sum?: GymSubscriptionSumOrderByAggregateInput
  }

  export type GymSubscriptionScalarWhereWithAggregatesInput = {
    AND?: GymSubscriptionScalarWhereWithAggregatesInput | GymSubscriptionScalarWhereWithAggregatesInput[]
    OR?: GymSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: GymSubscriptionScalarWhereWithAggregatesInput | GymSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymSubscription"> | string
    gymId?: StringWithAggregatesFilter<"GymSubscription"> | string
    plan?: StringWithAggregatesFilter<"GymSubscription"> | string
    billingPeriod?: StringWithAggregatesFilter<"GymSubscription"> | string
    status?: StringWithAggregatesFilter<"GymSubscription"> | string
    basePrice?: FloatWithAggregatesFilter<"GymSubscription"> | number
    pricePerStudent?: FloatWithAggregatesFilter<"GymSubscription"> | number
    currentPeriodStart?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"GymSubscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"GymSubscription"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"GymSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"GymSubscription"> | Date | string | null
    abacatePayBillingId?: StringNullableWithAggregatesFilter<"GymSubscription"> | string | null
    abacatePayCustomerId?: StringNullableWithAggregatesFilter<"GymSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
  }

  export type SubscriptionFeatureWhereInput = {
    AND?: SubscriptionFeatureWhereInput | SubscriptionFeatureWhereInput[]
    OR?: SubscriptionFeatureWhereInput[]
    NOT?: SubscriptionFeatureWhereInput | SubscriptionFeatureWhereInput[]
    id?: StringFilter<"SubscriptionFeature"> | string
    featureKey?: StringFilter<"SubscriptionFeature"> | string
    name?: StringFilter<"SubscriptionFeature"> | string
    description?: StringNullableFilter<"SubscriptionFeature"> | string | null
    category?: StringFilter<"SubscriptionFeature"> | string
    icon?: StringNullableFilter<"SubscriptionFeature"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionFeature"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionFeature"> | Date | string
  }

  export type SubscriptionFeatureOrderByWithRelationInput = {
    id?: SortOrder
    featureKey?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    featureKey?: string
    AND?: SubscriptionFeatureWhereInput | SubscriptionFeatureWhereInput[]
    OR?: SubscriptionFeatureWhereInput[]
    NOT?: SubscriptionFeatureWhereInput | SubscriptionFeatureWhereInput[]
    name?: StringFilter<"SubscriptionFeature"> | string
    description?: StringNullableFilter<"SubscriptionFeature"> | string | null
    category?: StringFilter<"SubscriptionFeature"> | string
    icon?: StringNullableFilter<"SubscriptionFeature"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionFeature"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionFeature"> | Date | string
  }, "id" | "featureKey">

  export type SubscriptionFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    featureKey?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionFeatureCountOrderByAggregateInput
    _max?: SubscriptionFeatureMaxOrderByAggregateInput
    _min?: SubscriptionFeatureMinOrderByAggregateInput
  }

  export type SubscriptionFeatureScalarWhereWithAggregatesInput = {
    AND?: SubscriptionFeatureScalarWhereWithAggregatesInput | SubscriptionFeatureScalarWhereWithAggregatesInput[]
    OR?: SubscriptionFeatureScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionFeatureScalarWhereWithAggregatesInput | SubscriptionFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionFeature"> | string
    featureKey?: StringWithAggregatesFilter<"SubscriptionFeature"> | string
    name?: StringWithAggregatesFilter<"SubscriptionFeature"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionFeature"> | string | null
    category?: StringWithAggregatesFilter<"SubscriptionFeature"> | string
    icon?: StringNullableWithAggregatesFilter<"SubscriptionFeature"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionFeature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionFeature"> | Date | string
  }

  export type SubscriptionPaymentWhereInput = {
    AND?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    OR?: SubscriptionPaymentWhereInput[]
    NOT?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    id?: StringFilter<"SubscriptionPayment"> | string
    subscriptionId?: StringNullableFilter<"SubscriptionPayment"> | string | null
    gymSubscriptionId?: StringNullableFilter<"SubscriptionPayment"> | string | null
    amount?: FloatFilter<"SubscriptionPayment"> | number
    currency?: StringFilter<"SubscriptionPayment"> | string
    status?: StringFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableFilter<"SubscriptionPayment"> | string | null
    abacatePayBillingId?: StringNullableFilter<"SubscriptionPayment"> | string | null
    paidAt?: DateTimeNullableFilter<"SubscriptionPayment"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"SubscriptionPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
  }

  export type SubscriptionPaymentOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    gymSubscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    abacatePayBillingId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    abacatePayBillingId?: string
    AND?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    OR?: SubscriptionPaymentWhereInput[]
    NOT?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    subscriptionId?: StringNullableFilter<"SubscriptionPayment"> | string | null
    gymSubscriptionId?: StringNullableFilter<"SubscriptionPayment"> | string | null
    amount?: FloatFilter<"SubscriptionPayment"> | number
    currency?: StringFilter<"SubscriptionPayment"> | string
    status?: StringFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableFilter<"SubscriptionPayment"> | string | null
    paidAt?: DateTimeNullableFilter<"SubscriptionPayment"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"SubscriptionPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
  }, "id" | "abacatePayBillingId">

  export type SubscriptionPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    gymSubscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    abacatePayBillingId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPaymentCountOrderByAggregateInput
    _avg?: SubscriptionPaymentAvgOrderByAggregateInput
    _max?: SubscriptionPaymentMaxOrderByAggregateInput
    _min?: SubscriptionPaymentMinOrderByAggregateInput
    _sum?: SubscriptionPaymentSumOrderByAggregateInput
  }

  export type SubscriptionPaymentScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPaymentScalarWhereWithAggregatesInput | SubscriptionPaymentScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPaymentScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPaymentScalarWhereWithAggregatesInput | SubscriptionPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPayment"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"SubscriptionPayment"> | string | null
    gymSubscriptionId?: StringNullableWithAggregatesFilter<"SubscriptionPayment"> | string | null
    amount?: FloatWithAggregatesFilter<"SubscriptionPayment"> | number
    currency?: StringWithAggregatesFilter<"SubscriptionPayment"> | string
    status?: StringWithAggregatesFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"SubscriptionPayment"> | string | null
    abacatePayBillingId?: StringNullableWithAggregatesFilter<"SubscriptionPayment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"SubscriptionPayment"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"SubscriptionPayment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPayment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentCreateNestedOneWithoutUserInput
    gyms?: GymCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    gyms?: GymUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutUserNestedInput
    gyms?: GymUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    gyms?: GymUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type?: string | null
    provider?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId?: string | null
    providerId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    idToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type?: string | null
    provider?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId?: string | null
    providerId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    idToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type?: string | null
    provider?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId?: string | null
    providerId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    idToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionToken?: string | null
    expires?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionToken?: string | null
    expires?: Date | string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionToken?: string | null
    expires?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProgressCreateInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    workoutsCompleted?: number
    lastActivityDate?: Date | string | null
    dailyGoalXP?: number
    todayXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProgressInput
  }

  export type StudentProgressUncheckedCreateInput = {
    id?: string
    studentId: string
    currentStreak?: number
    longestStreak?: number
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    workoutsCompleted?: number
    lastActivityDate?: Date | string | null
    dailyGoalXP?: number
    todayXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    workoutsCompleted?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyGoalXP?: IntFieldUpdateOperationsInput | number
    todayXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProgressNestedInput
  }

  export type StudentProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    workoutsCompleted?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyGoalXP?: IntFieldUpdateOperationsInput | number
    todayXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProgressCreateManyInput = {
    id?: string
    studentId: string
    currentStreak?: number
    longestStreak?: number
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    workoutsCompleted?: number
    lastActivityDate?: Date | string | null
    dailyGoalXP?: number
    todayXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    workoutsCompleted?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyGoalXP?: IntFieldUpdateOperationsInput | number
    todayXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    workoutsCompleted?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyGoalXP?: IntFieldUpdateOperationsInput | number
    todayXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileCreateInput = {
    id?: string
    height?: number | null
    weight?: number | null
    fitnessLevel?: string | null
    weeklyWorkoutFrequency?: number | null
    workoutDuration?: number | null
    goals?: string | null
    injuries?: string | null
    availableEquipment?: string | null
    gymType?: string | null
    preferredWorkoutTime?: string | null
    preferredSets?: number | null
    preferredRepRange?: string | null
    restTime?: string | null
    dietType?: string | null
    allergies?: string | null
    targetCalories?: number | null
    targetProtein?: number | null
    targetCarbs?: number | null
    targetFats?: number | null
    mealsPerDay?: number | null
    bmr?: number | null
    tdee?: number | null
    activityLevel?: number | null
    hormoneTreatmentDuration?: number | null
    physicalLimitations?: string | null
    motorLimitations?: string | null
    medicalConditions?: string | null
    limitationDetails?: string | null
    dailyAvailableHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateInput = {
    id?: string
    studentId: string
    height?: number | null
    weight?: number | null
    fitnessLevel?: string | null
    weeklyWorkoutFrequency?: number | null
    workoutDuration?: number | null
    goals?: string | null
    injuries?: string | null
    availableEquipment?: string | null
    gymType?: string | null
    preferredWorkoutTime?: string | null
    preferredSets?: number | null
    preferredRepRange?: string | null
    restTime?: string | null
    dietType?: string | null
    allergies?: string | null
    targetCalories?: number | null
    targetProtein?: number | null
    targetCarbs?: number | null
    targetFats?: number | null
    mealsPerDay?: number | null
    bmr?: number | null
    tdee?: number | null
    activityLevel?: number | null
    hormoneTreatmentDuration?: number | null
    physicalLimitations?: string | null
    motorLimitations?: string | null
    medicalConditions?: string | null
    limitationDetails?: string | null
    dailyAvailableHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyWorkoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: NullableStringFieldUpdateOperationsInput | string | null
    availableEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    gymType?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredSets?: NullableIntFieldUpdateOperationsInput | number | null
    preferredRepRange?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    targetProtein?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCarbs?: NullableFloatFieldUpdateOperationsInput | number | null
    targetFats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    bmr?: NullableFloatFieldUpdateOperationsInput | number | null
    tdee?: NullableFloatFieldUpdateOperationsInput | number | null
    activityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    hormoneTreatmentDuration?: NullableIntFieldUpdateOperationsInput | number | null
    physicalLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    motorLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    limitationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    dailyAvailableHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyWorkoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: NullableStringFieldUpdateOperationsInput | string | null
    availableEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    gymType?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredSets?: NullableIntFieldUpdateOperationsInput | number | null
    preferredRepRange?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    targetProtein?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCarbs?: NullableFloatFieldUpdateOperationsInput | number | null
    targetFats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    bmr?: NullableFloatFieldUpdateOperationsInput | number | null
    tdee?: NullableFloatFieldUpdateOperationsInput | number | null
    activityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    hormoneTreatmentDuration?: NullableIntFieldUpdateOperationsInput | number | null
    physicalLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    motorLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    limitationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    dailyAvailableHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileCreateManyInput = {
    id?: string
    studentId: string
    height?: number | null
    weight?: number | null
    fitnessLevel?: string | null
    weeklyWorkoutFrequency?: number | null
    workoutDuration?: number | null
    goals?: string | null
    injuries?: string | null
    availableEquipment?: string | null
    gymType?: string | null
    preferredWorkoutTime?: string | null
    preferredSets?: number | null
    preferredRepRange?: string | null
    restTime?: string | null
    dietType?: string | null
    allergies?: string | null
    targetCalories?: number | null
    targetProtein?: number | null
    targetCarbs?: number | null
    targetFats?: number | null
    mealsPerDay?: number | null
    bmr?: number | null
    tdee?: number | null
    activityLevel?: number | null
    hormoneTreatmentDuration?: number | null
    physicalLimitations?: string | null
    motorLimitations?: string | null
    medicalConditions?: string | null
    limitationDetails?: string | null
    dailyAvailableHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyWorkoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: NullableStringFieldUpdateOperationsInput | string | null
    availableEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    gymType?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredSets?: NullableIntFieldUpdateOperationsInput | number | null
    preferredRepRange?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    targetProtein?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCarbs?: NullableFloatFieldUpdateOperationsInput | number | null
    targetFats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    bmr?: NullableFloatFieldUpdateOperationsInput | number | null
    tdee?: NullableFloatFieldUpdateOperationsInput | number | null
    activityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    hormoneTreatmentDuration?: NullableIntFieldUpdateOperationsInput | number | null
    physicalLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    motorLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    limitationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    dailyAvailableHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyWorkoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: NullableStringFieldUpdateOperationsInput | string | null
    availableEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    gymType?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredSets?: NullableIntFieldUpdateOperationsInput | number | null
    preferredRepRange?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    targetProtein?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCarbs?: NullableFloatFieldUpdateOperationsInput | number | null
    targetFats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    bmr?: NullableFloatFieldUpdateOperationsInput | number | null
    tdee?: NullableFloatFieldUpdateOperationsInput | number | null
    activityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    hormoneTreatmentDuration?: NullableIntFieldUpdateOperationsInput | number | null
    physicalLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    motorLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    limitationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    dailyAvailableHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightHistoryCreateInput = {
    id?: string
    weight: number
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutWeightHistoryInput
  }

  export type WeightHistoryUncheckedCreateInput = {
    id?: string
    studentId: string
    weight: number
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeightHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWeightHistoryNestedInput
  }

  export type WeightHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightHistoryCreateManyInput = {
    id?: string
    studentId: string
    weight: number
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeightHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCreateInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type GymCreateManyInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymProfileCreateInput = {
    id?: string
    totalStudents?: number
    activeStudents?: number
    equipmentCount?: number
    level?: number
    xp?: number
    xpToNextLevel?: number
    currentStreak?: number
    longestStreak?: number
    monthlyStudentGoal?: number | null
    avgStudentFrequency?: number | null
    equipmentUtilization?: number | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutProfileInput
  }

  export type GymProfileUncheckedCreateInput = {
    id?: string
    gymId: string
    totalStudents?: number
    activeStudents?: number
    equipmentCount?: number
    level?: number
    xp?: number
    xpToNextLevel?: number
    currentStreak?: number
    longestStreak?: number
    monthlyStudentGoal?: number | null
    avgStudentFrequency?: number | null
    equipmentUtilization?: number | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    activeStudents?: IntFieldUpdateOperationsInput | number
    equipmentCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    monthlyStudentGoal?: NullableIntFieldUpdateOperationsInput | number | null
    avgStudentFrequency?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutProfileNestedInput
  }

  export type GymProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    activeStudents?: IntFieldUpdateOperationsInput | number
    equipmentCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    monthlyStudentGoal?: NullableIntFieldUpdateOperationsInput | number | null
    avgStudentFrequency?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymProfileCreateManyInput = {
    id?: string
    gymId: string
    totalStudents?: number
    activeStudents?: number
    equipmentCount?: number
    level?: number
    xp?: number
    xpToNextLevel?: number
    currentStreak?: number
    longestStreak?: number
    monthlyStudentGoal?: number | null
    avgStudentFrequency?: number | null
    equipmentUtilization?: number | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    activeStudents?: IntFieldUpdateOperationsInput | number
    equipmentCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    monthlyStudentGoal?: NullableIntFieldUpdateOperationsInput | number | null
    avgStudentFrequency?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    activeStudents?: IntFieldUpdateOperationsInput | number
    equipmentCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    monthlyStudentGoal?: NullableIntFieldUpdateOperationsInput | number | null
    avgStudentFrequency?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymStatsCreateInput = {
    id?: string
    todayCheckins?: number
    todayActiveStudents?: number
    todayEquipmentInUse?: number
    weekTotalCheckins?: number
    weekAvgDailyCheckins?: number
    weekNewMembers?: number
    weekCanceledMembers?: number
    monthTotalCheckins?: number
    monthRetentionRate?: number
    monthGrowthRate?: number
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutStatsInput
  }

  export type GymStatsUncheckedCreateInput = {
    id?: string
    gymId: string
    todayCheckins?: number
    todayActiveStudents?: number
    todayEquipmentInUse?: number
    weekTotalCheckins?: number
    weekAvgDailyCheckins?: number
    weekNewMembers?: number
    weekCanceledMembers?: number
    monthTotalCheckins?: number
    monthRetentionRate?: number
    monthGrowthRate?: number
    updatedAt?: Date | string
  }

  export type GymStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    todayCheckins?: IntFieldUpdateOperationsInput | number
    todayActiveStudents?: IntFieldUpdateOperationsInput | number
    todayEquipmentInUse?: IntFieldUpdateOperationsInput | number
    weekTotalCheckins?: IntFieldUpdateOperationsInput | number
    weekAvgDailyCheckins?: FloatFieldUpdateOperationsInput | number
    weekNewMembers?: IntFieldUpdateOperationsInput | number
    weekCanceledMembers?: IntFieldUpdateOperationsInput | number
    monthTotalCheckins?: IntFieldUpdateOperationsInput | number
    monthRetentionRate?: FloatFieldUpdateOperationsInput | number
    monthGrowthRate?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutStatsNestedInput
  }

  export type GymStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    todayCheckins?: IntFieldUpdateOperationsInput | number
    todayActiveStudents?: IntFieldUpdateOperationsInput | number
    todayEquipmentInUse?: IntFieldUpdateOperationsInput | number
    weekTotalCheckins?: IntFieldUpdateOperationsInput | number
    weekAvgDailyCheckins?: FloatFieldUpdateOperationsInput | number
    weekNewMembers?: IntFieldUpdateOperationsInput | number
    weekCanceledMembers?: IntFieldUpdateOperationsInput | number
    monthTotalCheckins?: IntFieldUpdateOperationsInput | number
    monthRetentionRate?: FloatFieldUpdateOperationsInput | number
    monthGrowthRate?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymStatsCreateManyInput = {
    id?: string
    gymId: string
    todayCheckins?: number
    todayActiveStudents?: number
    todayEquipmentInUse?: number
    weekTotalCheckins?: number
    weekAvgDailyCheckins?: number
    weekNewMembers?: number
    weekCanceledMembers?: number
    monthTotalCheckins?: number
    monthRetentionRate?: number
    monthGrowthRate?: number
    updatedAt?: Date | string
  }

  export type GymStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    todayCheckins?: IntFieldUpdateOperationsInput | number
    todayActiveStudents?: IntFieldUpdateOperationsInput | number
    todayEquipmentInUse?: IntFieldUpdateOperationsInput | number
    weekTotalCheckins?: IntFieldUpdateOperationsInput | number
    weekAvgDailyCheckins?: FloatFieldUpdateOperationsInput | number
    weekNewMembers?: IntFieldUpdateOperationsInput | number
    weekCanceledMembers?: IntFieldUpdateOperationsInput | number
    monthTotalCheckins?: IntFieldUpdateOperationsInput | number
    monthRetentionRate?: FloatFieldUpdateOperationsInput | number
    monthGrowthRate?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    todayCheckins?: IntFieldUpdateOperationsInput | number
    todayActiveStudents?: IntFieldUpdateOperationsInput | number
    todayEquipmentInUse?: IntFieldUpdateOperationsInput | number
    weekTotalCheckins?: IntFieldUpdateOperationsInput | number
    weekAvgDailyCheckins?: FloatFieldUpdateOperationsInput | number
    weekNewMembers?: IntFieldUpdateOperationsInput | number
    weekCanceledMembers?: IntFieldUpdateOperationsInput | number
    monthTotalCheckins?: IntFieldUpdateOperationsInput | number
    monthRetentionRate?: FloatFieldUpdateOperationsInput | number
    monthGrowthRate?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUnitsInput
    workouts?: WorkoutCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUnitsNestedInput
    workouts?: WorkoutUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workouts?: WorkoutUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit?: UnitCreateNestedOneWithoutWorkoutsInput
    exercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
    completions?: WorkoutHistoryCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateInput = {
    id?: string
    unitId?: string | null
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    completions?: WorkoutHistoryUncheckedCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutWorkoutsNestedInput
    exercises?: WorkoutExerciseUpdateManyWithoutWorkoutNestedInput
    completions?: WorkoutHistoryUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    completions?: WorkoutHistoryUncheckedUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutCreateManyInput = {
    id?: string
    unitId?: string | null
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseCreateInput = {
    id?: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workout: WorkoutCreateNestedOneWithoutExercisesInput
    alternatives?: AlternativeExerciseCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateInput = {
    id?: string
    workoutId: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeExerciseUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneRequiredWithoutExercisesNestedInput
    alternatives?: AlternativeExerciseUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeExerciseUncheckedUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseCreateManyInput = {
    id?: string
    workoutId: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeExerciseCreateInput = {
    id?: string
    name: string
    reason: string
    educationalId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workoutExercise: WorkoutExerciseCreateNestedOneWithoutAlternativesInput
  }

  export type AlternativeExerciseUncheckedCreateInput = {
    id?: string
    workoutExerciseId: string
    name: string
    reason: string
    educationalId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercise?: WorkoutExerciseUpdateOneRequiredWithoutAlternativesNestedInput
  }

  export type AlternativeExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutExerciseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeExerciseCreateManyInput = {
    id?: string
    workoutExerciseId: string
    name: string
    reason: string
    educationalId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutExerciseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressCreateInput = {
    id?: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutWorkoutProgressInput
    workout: WorkoutCreateNestedOneWithoutProgressInput
  }

  export type WorkoutProgressUncheckedCreateInput = {
    id?: string
    studentId: string
    workoutId: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWorkoutProgressNestedInput
    workout?: WorkoutUpdateOneRequiredWithoutProgressNestedInput
  }

  export type WorkoutProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressCreateManyInput = {
    id?: string
    studentId: string
    workoutId: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutHistoryCreateInput = {
    id?: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutWorkoutsInput
    workout?: WorkoutCreateNestedOneWithoutCompletionsInput
    exercises?: ExerciseLogCreateNestedManyWithoutWorkoutHistoryInput
    records?: PersonalRecordCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryUncheckedCreateInput = {
    id?: string
    studentId: string
    workoutId?: string | null
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    exercises?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutHistoryInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWorkoutsNestedInput
    workout?: WorkoutUpdateOneWithoutCompletionsNestedInput
    exercises?: ExerciseLogUpdateManyWithoutWorkoutHistoryNestedInput
    records?: PersonalRecordUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryCreateManyInput = {
    id?: string
    studentId: string
    workoutId?: string | null
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
  }

  export type WorkoutHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseLogCreateInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes?: string | null
    formCheckScore?: number | null
    difficulty?: string | null
    workoutHistory: WorkoutHistoryCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseLogUncheckedCreateInput = {
    id?: string
    workoutHistoryId: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes?: string | null
    formCheckScore?: number | null
    difficulty?: string | null
  }

  export type ExerciseLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    workoutHistory?: WorkoutHistoryUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutHistoryId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExerciseLogCreateManyInput = {
    id?: string
    workoutHistoryId: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes?: string | null
    formCheckScore?: number | null
    difficulty?: string | null
  }

  export type ExerciseLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExerciseLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutHistoryId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalRecordCreateInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
    student: StudentCreateNestedOneWithoutRecordsInput
    workoutHistory?: WorkoutHistoryCreateNestedOneWithoutRecordsInput
  }

  export type PersonalRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    workoutHistoryId?: string | null
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
  }

  export type PersonalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutRecordsNestedInput
    workoutHistory?: WorkoutHistoryUpdateOneWithoutRecordsNestedInput
  }

  export type PersonalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutHistoryId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PersonalRecordCreateManyInput = {
    id?: string
    studentId: string
    workoutHistoryId?: string | null
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
  }

  export type PersonalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PersonalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutHistoryId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietPlanCreateInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealCreateNestedManyWithoutDietPlanInput
    completions?: DietPlanCompletionCreateNestedManyWithoutDietPlanInput
  }

  export type DietPlanUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealUncheckedCreateNestedManyWithoutDietPlanInput
    completions?: DietPlanCompletionUncheckedCreateNestedManyWithoutDietPlanInput
  }

  export type DietPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealUpdateManyWithoutDietPlanNestedInput
    completions?: DietPlanCompletionUpdateManyWithoutDietPlanNestedInput
  }

  export type DietPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealUncheckedUpdateManyWithoutDietPlanNestedInput
    completions?: DietPlanCompletionUncheckedUpdateManyWithoutDietPlanNestedInput
  }

  export type DietPlanCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DietPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DietPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealCreateInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    image?: string | null
    ingredients?: string | null
    order?: number
    dietPlan: DietPlanCreateNestedOneWithoutMealsInput
  }

  export type MealUncheckedCreateInput = {
    id?: string
    dietPlanId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    image?: string | null
    ingredients?: string | null
    order?: number
  }

  export type MealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    dietPlan?: DietPlanUpdateOneRequiredWithoutMealsNestedInput
  }

  export type MealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietPlanId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MealCreateManyInput = {
    id?: string
    dietPlanId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    image?: string | null
    ingredients?: string | null
    order?: number
  }

  export type MealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietPlanId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DietPlanCompletionCreateInput = {
    id?: string
    date?: Date | string
    completed?: boolean
    student: StudentCreateNestedOneWithoutDietsInput
    dietPlan: DietPlanCreateNestedOneWithoutCompletionsInput
  }

  export type DietPlanCompletionUncheckedCreateInput = {
    id?: string
    studentId: string
    dietPlanId: string
    date?: Date | string
    completed?: boolean
  }

  export type DietPlanCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutDietsNestedInput
    dietPlan?: DietPlanUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type DietPlanCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    dietPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DietPlanCompletionCreateManyInput = {
    id?: string
    studentId: string
    dietPlanId: string
    date?: Date | string
    completed?: boolean
  }

  export type DietPlanCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DietPlanCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    dietPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyNutritionCreateInput = {
    id?: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutDailyNutritionInput
    meals?: NutritionMealCreateNestedManyWithoutDailyNutritionInput
  }

  export type DailyNutritionUncheckedCreateInput = {
    id?: string
    studentId: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: NutritionMealUncheckedCreateNestedManyWithoutDailyNutritionInput
  }

  export type DailyNutritionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutDailyNutritionNestedInput
    meals?: NutritionMealUpdateManyWithoutDailyNutritionNestedInput
  }

  export type DailyNutritionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: NutritionMealUncheckedUpdateManyWithoutDailyNutritionNestedInput
  }

  export type DailyNutritionCreateManyInput = {
    id?: string
    studentId: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyNutritionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyNutritionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionMealCreateInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dailyNutrition: DailyNutritionCreateNestedOneWithoutMealsInput
    foods?: NutritionFoodItemCreateNestedManyWithoutNutritionMealInput
  }

  export type NutritionMealUncheckedCreateInput = {
    id?: string
    dailyNutritionId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foods?: NutritionFoodItemUncheckedCreateNestedManyWithoutNutritionMealInput
  }

  export type NutritionMealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyNutrition?: DailyNutritionUpdateOneRequiredWithoutMealsNestedInput
    foods?: NutritionFoodItemUpdateManyWithoutNutritionMealNestedInput
  }

  export type NutritionMealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyNutritionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foods?: NutritionFoodItemUncheckedUpdateManyWithoutNutritionMealNestedInput
  }

  export type NutritionMealCreateManyInput = {
    id?: string
    dailyNutritionId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionMealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionMealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyNutritionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemCreateInput = {
    id?: string
    foodId?: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt?: Date | string
    nutritionMeal: NutritionMealCreateNestedOneWithoutFoodsInput
  }

  export type NutritionFoodItemUncheckedCreateInput = {
    id?: string
    nutritionMealId: string
    foodId?: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt?: Date | string
  }

  export type NutritionFoodItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionMeal?: NutritionMealUpdateOneRequiredWithoutFoodsNestedInput
  }

  export type NutritionFoodItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nutritionMealId?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemCreateManyInput = {
    id?: string
    nutritionMealId: string
    foodId?: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt?: Date | string
  }

  export type NutritionFoodItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nutritionMealId?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionChatUsageCreateInput = {
    id?: string
    date?: Date | string
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutNutritionChatUsageInput
  }

  export type NutritionChatUsageUncheckedCreateInput = {
    id?: string
    studentId: string
    date?: Date | string
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionChatUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutNutritionChatUsageNestedInput
  }

  export type NutritionChatUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionChatUsageCreateManyInput = {
    id?: string
    studentId: string
    date?: Date | string
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionChatUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionChatUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemCreateInput = {
    id?: string
    name: string
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    category: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodItemUncheckedCreateInput = {
    id?: string
    name: string
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    category: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemCreateManyInput = {
    id?: string
    name: string
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    category: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    category: string
    level?: number | null
    color?: string | null
    target?: number | null
    xpReward?: number
    createdAt?: Date | string
    unlocks?: AchievementUnlockCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    category: string
    level?: number | null
    color?: string | null
    target?: number | null
    xpReward?: number
    createdAt?: Date | string
    unlocks?: AchievementUnlockUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    xpReward?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlocks?: AchievementUnlockUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    xpReward?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlocks?: AchievementUnlockUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    category: string
    level?: number | null
    color?: string | null
    target?: number | null
    xpReward?: number
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    xpReward?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    xpReward?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockCreateInput = {
    id?: string
    progress?: number | null
    unlockedAt?: Date | string
    student: StudentCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUnlocksInput
  }

  export type AchievementUnlockUncheckedCreateInput = {
    id?: string
    studentId: string
    achievementId: string
    progress?: number | null
    unlockedAt?: Date | string
  }

  export type AchievementUnlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUnlocksNestedInput
  }

  export type AchievementUnlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockCreateManyInput = {
    id?: string
    studentId: string
    achievementId: string
    progress?: number | null
    unlockedAt?: Date | string
  }

  export type AchievementUnlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymUserPreferenceCreateInput = {
    id?: string
    lastActiveGymId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymPreferenceInput
  }

  export type GymUserPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    lastActiveGymId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUserPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastActiveGymId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymPreferenceNestedInput
  }

  export type GymUserPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastActiveGymId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymUserPreferenceCreateManyInput = {
    id?: string
    userId: string
    lastActiveGymId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUserPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastActiveGymId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymUserPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastActiveGymId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipCreateInput = {
    id?: string
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutStudentsInput
    student: StudentCreateNestedOneWithoutMembershipsInput
    plan?: MembershipPlanCreateNestedOneWithoutMembershipsInput
  }

  export type GymMembershipUncheckedCreateInput = {
    id?: string
    gymId: string
    studentId: string
    planId?: string | null
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutStudentsNestedInput
    student?: StudentUpdateOneRequiredWithoutMembershipsNestedInput
    plan?: MembershipPlanUpdateOneWithoutMembershipsNestedInput
  }

  export type GymMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipCreateManyInput = {
    id?: string
    gymId: string
    studentId: string
    planId?: string | null
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanCreateInput = {
    id?: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutPlansInput
    memberships?: GymMembershipCreateNestedManyWithoutPlanInput
    payments?: PaymentCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUncheckedCreateInput = {
    id?: string
    gymId: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutPlanInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutPlansNestedInput
    memberships?: GymMembershipUpdateManyWithoutPlanNestedInput
    payments?: PaymentUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: GymMembershipUncheckedUpdateManyWithoutPlanNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanCreateManyInput = {
    id?: string
    gymId: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayPassCreateInput = {
    id?: string
    gymId: string
    gymName: string
    purchaseDate?: Date | string
    validDate: Date | string
    price: number
    status?: string
    qrCode?: string | null
    student: StudentCreateNestedOneWithoutDayPassesInput
  }

  export type DayPassUncheckedCreateInput = {
    id?: string
    studentId: string
    gymId: string
    gymName: string
    purchaseDate?: Date | string
    validDate: Date | string
    price: number
    status?: string
    qrCode?: string | null
  }

  export type DayPassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutDayPassesNestedInput
  }

  export type DayPassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DayPassCreateManyInput = {
    id?: string
    studentId: string
    gymId: string
    gymName: string
    purchaseDate?: Date | string
    validDate: Date | string
    price: number
    status?: string
    qrCode?: string | null
  }

  export type DayPassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DayPassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckInCreateInput = {
    id?: string
    studentId: string
    studentName: string
    timestamp?: Date | string
    checkOut?: Date | string | null
    duration?: number | null
    gym: GymCreateNestedOneWithoutCheckInsInput
  }

  export type CheckInUncheckedCreateInput = {
    id?: string
    gymId: string
    studentId: string
    studentName: string
    timestamp?: Date | string
    checkOut?: Date | string | null
    duration?: number | null
  }

  export type CheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    gym?: GymUpdateOneRequiredWithoutCheckInsNestedInput
  }

  export type CheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckInCreateManyInput = {
    id?: string
    gymId: string
    studentId: string
    studentName: string
    timestamp?: Date | string
    checkOut?: Date | string | null
    duration?: number | null
  }

  export type CheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutEquipmentInput
    maintenanceHistory?: MaintenanceRecordCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    gymId: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maintenanceHistory?: MaintenanceRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutEquipmentNestedInput
    maintenanceHistory?: MaintenanceRecordUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceHistory?: MaintenanceRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    gymId: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRecordCreateInput = {
    id?: string
    date?: Date | string
    type: string
    description?: string | null
    performedBy?: string | null
    cost?: number | null
    nextScheduled?: Date | string | null
    equipment: EquipmentCreateNestedOneWithoutMaintenanceHistoryInput
  }

  export type MaintenanceRecordUncheckedCreateInput = {
    id?: string
    equipmentId: string
    date?: Date | string
    type: string
    description?: string | null
    performedBy?: string | null
    cost?: number | null
    nextScheduled?: Date | string | null
  }

  export type MaintenanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: EquipmentUpdateOneRequiredWithoutMaintenanceHistoryNestedInput
  }

  export type MaintenanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceRecordCreateManyInput = {
    id?: string
    equipmentId: string
    date?: Date | string
    type: string
    description?: string | null
    performedBy?: string | null
    cost?: number | null
    nextScheduled?: Date | string | null
  }

  export type MaintenanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    studentId: string
    studentName: string
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutPaymentsInput
    plan?: MembershipPlanCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    gymId: string
    studentId: string
    studentName: string
    planId?: string | null
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutPaymentsNestedInput
    plan?: MembershipPlanUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    gymId: string
    studentId: string
    studentName: string
    planId?: string | null
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    type: string
    description?: string | null
    amount: number
    date?: Date | string
    category?: string | null
    createdAt?: Date | string
    gym: GymCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    gymId: string
    type: string
    description?: string | null
    amount: number
    date?: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    gymId: string
    type: string
    description?: string | null
    amount: number
    date?: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    type: string
    isDefault?: boolean
    cardBrand?: string | null
    last4?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    holderName?: string | null
    pixKey?: string | null
    pixKeyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    isDefault?: boolean
    cardBrand?: string | null
    last4?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    holderName?: string | null
    pixKey?: string | null
    pixKeyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    userId: string
    type: string
    isDefault?: boolean
    cardBrand?: string | null
    last4?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    holderName?: string | null
    pixKey?: string | null
    pixKeyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    user: StudentCreateNestedOneWithoutFriendsInput
    friend: StudentCreateNestedOneWithoutFriendOfInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    userId: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: StudentUpdateOneRequiredWithoutFriendsNestedInput
    friend?: StudentUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    userId: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    studentId: string
    plan?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    studentId: string
    plan?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionCreateInput = {
    id?: string
    plan: string
    billingPeriod?: string
    status?: string
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutSubscriptionInput
  }

  export type GymSubscriptionUncheckedCreateInput = {
    id?: string
    gymId: string
    plan: string
    billingPeriod?: string
    status?: string
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    pricePerStudent?: FloatFieldUpdateOperationsInput | number
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type GymSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    pricePerStudent?: FloatFieldUpdateOperationsInput | number
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionCreateManyInput = {
    id?: string
    gymId: string
    plan: string
    billingPeriod?: string
    status?: string
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    pricePerStudent?: FloatFieldUpdateOperationsInput | number
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    pricePerStudent?: FloatFieldUpdateOperationsInput | number
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionFeatureCreateInput = {
    id?: string
    featureKey: string
    name: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionFeatureUncheckedCreateInput = {
    id?: string
    featureKey: string
    name: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionFeatureCreateManyInput = {
    id?: string
    featureKey: string
    name: string
    description?: string | null
    category: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureKey?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentCreateInput = {
    id?: string
    subscriptionId?: string | null
    gymSubscriptionId?: string | null
    amount: number
    currency?: string
    status: string
    paymentMethod?: string | null
    abacatePayBillingId?: string | null
    paidAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUncheckedCreateInput = {
    id?: string
    subscriptionId?: string | null
    gymSubscriptionId?: string | null
    amount: number
    currency?: string
    status: string
    paymentMethod?: string | null
    abacatePayBillingId?: string | null
    paidAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    gymSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    gymSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentCreateManyInput = {
    id?: string
    subscriptionId?: string | null
    gymSubscriptionId?: string | null
    amount: number
    currency?: string
    status: string
    paymentMethod?: string | null
    abacatePayBillingId?: string | null
    paidAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    gymSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    gymSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type GymListRelationFilter = {
    every?: GymWhereInput
    some?: GymWhereInput
    none?: GymWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type GymUserPreferenceNullableScalarRelationFilter = {
    is?: GymUserPreferenceWhereInput | null
    isNot?: GymUserPreferenceWhereInput | null
  }

  export type PaymentMethodListRelationFilter = {
    every?: PaymentMethodWhereInput
    some?: PaymentMethodWhereInput
    none?: PaymentMethodWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type GymOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activeGymId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activeGymId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activeGymId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountAccounts_provider_providerAccountId_keyCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    idToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    idToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    idToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionToken?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProgressNullableScalarRelationFilter = {
    is?: StudentProgressWhereInput | null
    isNot?: StudentProgressWhereInput | null
  }

  export type StudentProfileNullableScalarRelationFilter = {
    is?: StudentProfileWhereInput | null
    isNot?: StudentProfileWhereInput | null
  }

  export type WorkoutHistoryListRelationFilter = {
    every?: WorkoutHistoryWhereInput
    some?: WorkoutHistoryWhereInput
    none?: WorkoutHistoryWhereInput
  }

  export type WorkoutProgressListRelationFilter = {
    every?: WorkoutProgressWhereInput
    some?: WorkoutProgressWhereInput
    none?: WorkoutProgressWhereInput
  }

  export type PersonalRecordListRelationFilter = {
    every?: PersonalRecordWhereInput
    some?: PersonalRecordWhereInput
    none?: PersonalRecordWhereInput
  }

  export type DietPlanCompletionListRelationFilter = {
    every?: DietPlanCompletionWhereInput
    some?: DietPlanCompletionWhereInput
    none?: DietPlanCompletionWhereInput
  }

  export type AchievementUnlockListRelationFilter = {
    every?: AchievementUnlockWhereInput
    some?: AchievementUnlockWhereInput
    none?: AchievementUnlockWhereInput
  }

  export type WeightHistoryListRelationFilter = {
    every?: WeightHistoryWhereInput
    some?: WeightHistoryWhereInput
    none?: WeightHistoryWhereInput
  }

  export type DailyNutritionListRelationFilter = {
    every?: DailyNutritionWhereInput
    some?: DailyNutritionWhereInput
    none?: DailyNutritionWhereInput
  }

  export type NutritionChatUsageListRelationFilter = {
    every?: NutritionChatUsageWhereInput
    some?: NutritionChatUsageWhereInput
    none?: NutritionChatUsageWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type GymMembershipListRelationFilter = {
    every?: GymMembershipWhereInput
    some?: GymMembershipWhereInput
    none?: GymMembershipWhereInput
  }

  export type DayPassListRelationFilter = {
    every?: DayPassWhereInput
    some?: DayPassWhereInput
    none?: DayPassWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type WorkoutHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DietPlanCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementUnlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeightHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyNutritionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NutritionChatUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GymMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DayPassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    isTrans?: SortOrder
    usesHormones?: SortOrder
    hormoneType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    isTrans?: SortOrder
    usesHormones?: SortOrder
    hormoneType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    isTrans?: SortOrder
    usesHormones?: SortOrder
    hormoneType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentProgressCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    lastActivityDate?: SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProgressAvgOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
  }

  export type StudentProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    lastActivityDate?: SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProgressMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    lastActivityDate?: SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProgressSumOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    workoutsCompleted?: SortOrder
    dailyGoalXP?: SortOrder
    todayXP?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StudentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    fitnessLevel?: SortOrder
    weeklyWorkoutFrequency?: SortOrder
    workoutDuration?: SortOrder
    goals?: SortOrder
    injuries?: SortOrder
    availableEquipment?: SortOrder
    gymType?: SortOrder
    preferredWorkoutTime?: SortOrder
    preferredSets?: SortOrder
    preferredRepRange?: SortOrder
    restTime?: SortOrder
    dietType?: SortOrder
    allergies?: SortOrder
    targetCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    mealsPerDay?: SortOrder
    bmr?: SortOrder
    tdee?: SortOrder
    activityLevel?: SortOrder
    hormoneTreatmentDuration?: SortOrder
    physicalLimitations?: SortOrder
    motorLimitations?: SortOrder
    medicalConditions?: SortOrder
    limitationDetails?: SortOrder
    dailyAvailableHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
    weeklyWorkoutFrequency?: SortOrder
    workoutDuration?: SortOrder
    preferredSets?: SortOrder
    targetCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    mealsPerDay?: SortOrder
    bmr?: SortOrder
    tdee?: SortOrder
    activityLevel?: SortOrder
    hormoneTreatmentDuration?: SortOrder
    dailyAvailableHours?: SortOrder
  }

  export type StudentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    fitnessLevel?: SortOrder
    weeklyWorkoutFrequency?: SortOrder
    workoutDuration?: SortOrder
    goals?: SortOrder
    injuries?: SortOrder
    availableEquipment?: SortOrder
    gymType?: SortOrder
    preferredWorkoutTime?: SortOrder
    preferredSets?: SortOrder
    preferredRepRange?: SortOrder
    restTime?: SortOrder
    dietType?: SortOrder
    allergies?: SortOrder
    targetCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    mealsPerDay?: SortOrder
    bmr?: SortOrder
    tdee?: SortOrder
    activityLevel?: SortOrder
    hormoneTreatmentDuration?: SortOrder
    physicalLimitations?: SortOrder
    motorLimitations?: SortOrder
    medicalConditions?: SortOrder
    limitationDetails?: SortOrder
    dailyAvailableHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    fitnessLevel?: SortOrder
    weeklyWorkoutFrequency?: SortOrder
    workoutDuration?: SortOrder
    goals?: SortOrder
    injuries?: SortOrder
    availableEquipment?: SortOrder
    gymType?: SortOrder
    preferredWorkoutTime?: SortOrder
    preferredSets?: SortOrder
    preferredRepRange?: SortOrder
    restTime?: SortOrder
    dietType?: SortOrder
    allergies?: SortOrder
    targetCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    mealsPerDay?: SortOrder
    bmr?: SortOrder
    tdee?: SortOrder
    activityLevel?: SortOrder
    hormoneTreatmentDuration?: SortOrder
    physicalLimitations?: SortOrder
    motorLimitations?: SortOrder
    medicalConditions?: SortOrder
    limitationDetails?: SortOrder
    dailyAvailableHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
    weeklyWorkoutFrequency?: SortOrder
    workoutDuration?: SortOrder
    preferredSets?: SortOrder
    targetCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    mealsPerDay?: SortOrder
    bmr?: SortOrder
    tdee?: SortOrder
    activityLevel?: SortOrder
    hormoneTreatmentDuration?: SortOrder
    dailyAvailableHours?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WeightHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    weight?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeightHistoryAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type WeightHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    weight?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeightHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    weight?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeightHistorySumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type GymProfileNullableScalarRelationFilter = {
    is?: GymProfileWhereInput | null
    isNot?: GymProfileWhereInput | null
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type MembershipPlanListRelationFilter = {
    every?: MembershipPlanWhereInput
    some?: MembershipPlanWhereInput
    none?: MembershipPlanWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type CheckInListRelationFilter = {
    every?: CheckInWhereInput
    some?: CheckInWhereInput
    none?: CheckInWhereInput
  }

  export type GymStatsNullableScalarRelationFilter = {
    is?: GymStatsWhereInput | null
    isNot?: GymStatsWhereInput | null
  }

  export type GymSubscriptionNullableScalarRelationFilter = {
    is?: GymSubscriptionWhereInput | null
    isNot?: GymSubscriptionWhereInput | null
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GymCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cnpj?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    amenities?: SortOrder
    openingHours?: SortOrder
    photos?: SortOrder
    isPartner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
  }

  export type GymMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cnpj?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    amenities?: SortOrder
    openingHours?: SortOrder
    photos?: SortOrder
    isPartner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cnpj?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
    amenities?: SortOrder
    openingHours?: SortOrder
    photos?: SortOrder
    isPartner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    totalReviews?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type GymScalarRelationFilter = {
    is?: GymWhereInput
    isNot?: GymWhereInput
  }

  export type GymProfileCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrder
    avgStudentFrequency?: SortOrder
    equipmentUtilization?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymProfileAvgOrderByAggregateInput = {
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrder
    avgStudentFrequency?: SortOrder
    equipmentUtilization?: SortOrder
    ranking?: SortOrder
  }

  export type GymProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrder
    avgStudentFrequency?: SortOrder
    equipmentUtilization?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymProfileMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrder
    avgStudentFrequency?: SortOrder
    equipmentUtilization?: SortOrder
    ranking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymProfileSumOrderByAggregateInput = {
    totalStudents?: SortOrder
    activeStudents?: SortOrder
    equipmentCount?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    xpToNextLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    monthlyStudentGoal?: SortOrder
    avgStudentFrequency?: SortOrder
    equipmentUtilization?: SortOrder
    ranking?: SortOrder
  }

  export type GymStatsCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymStatsAvgOrderByAggregateInput = {
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
  }

  export type GymStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymStatsMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymStatsSumOrderByAggregateInput = {
    todayCheckins?: SortOrder
    todayActiveStudents?: SortOrder
    todayEquipmentInUse?: SortOrder
    weekTotalCheckins?: SortOrder
    weekAvgDailyCheckins?: SortOrder
    weekNewMembers?: SortOrder
    weekCanceledMembers?: SortOrder
    monthTotalCheckins?: SortOrder
    monthRetentionRate?: SortOrder
    monthGrowthRate?: SortOrder
  }

  export type WorkoutListRelationFilter = {
    every?: WorkoutWhereInput
    some?: WorkoutWhereInput
    none?: WorkoutWhereInput
  }

  export type WorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type WorkoutExerciseListRelationFilter = {
    every?: WorkoutExerciseWhereInput
    some?: WorkoutExerciseWhereInput
    none?: WorkoutExerciseWhereInput
  }

  export type WorkoutExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    muscleGroup?: SortOrder
    difficulty?: SortOrder
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutAvgOrderByAggregateInput = {
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
  }

  export type WorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    muscleGroup?: SortOrder
    difficulty?: SortOrder
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    muscleGroup?: SortOrder
    difficulty?: SortOrder
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutSumOrderByAggregateInput = {
    xpReward?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
  }

  export type WorkoutScalarRelationFilter = {
    is?: WorkoutWhereInput
    isNot?: WorkoutWhereInput
  }

  export type AlternativeExerciseListRelationFilter = {
    every?: AlternativeExerciseWhereInput
    some?: AlternativeExerciseWhereInput
    none?: AlternativeExerciseWhereInput
  }

  export type AlternativeExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    rest?: SortOrder
    notes?: SortOrder
    videoUrl?: SortOrder
    educationalId?: SortOrder
    order?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    difficulty?: SortOrder
    equipment?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    benefits?: SortOrder
    scientificEvidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutExerciseAvgOrderByAggregateInput = {
    sets?: SortOrder
    rest?: SortOrder
    order?: SortOrder
  }

  export type WorkoutExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    rest?: SortOrder
    notes?: SortOrder
    videoUrl?: SortOrder
    educationalId?: SortOrder
    order?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    difficulty?: SortOrder
    equipment?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    benefits?: SortOrder
    scientificEvidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    rest?: SortOrder
    notes?: SortOrder
    videoUrl?: SortOrder
    educationalId?: SortOrder
    order?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    difficulty?: SortOrder
    equipment?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    benefits?: SortOrder
    scientificEvidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutExerciseSumOrderByAggregateInput = {
    sets?: SortOrder
    rest?: SortOrder
    order?: SortOrder
  }

  export type WorkoutExerciseScalarRelationFilter = {
    is?: WorkoutExerciseWhereInput
    isNot?: WorkoutExerciseWhereInput
  }

  export type AlternativeExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    educationalId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlternativeExerciseAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AlternativeExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    educationalId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlternativeExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    educationalId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlternativeExerciseSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WorkoutProgressStudentIdWorkoutIdCompoundUniqueInput = {
    studentId: string
    workoutId: string
  }

  export type WorkoutProgressCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    currentExerciseIndex?: SortOrder
    exerciseLogs?: SortOrder
    skippedExercises?: SortOrder
    selectedAlternatives?: SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    startTime?: SortOrder
    cardioPreference?: SortOrder
    cardioDuration?: SortOrder
    selectedCardioType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutProgressAvgOrderByAggregateInput = {
    currentExerciseIndex?: SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    cardioDuration?: SortOrder
  }

  export type WorkoutProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    currentExerciseIndex?: SortOrder
    exerciseLogs?: SortOrder
    skippedExercises?: SortOrder
    selectedAlternatives?: SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    startTime?: SortOrder
    cardioPreference?: SortOrder
    cardioDuration?: SortOrder
    selectedCardioType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutProgressMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    currentExerciseIndex?: SortOrder
    exerciseLogs?: SortOrder
    skippedExercises?: SortOrder
    selectedAlternatives?: SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    startTime?: SortOrder
    cardioPreference?: SortOrder
    cardioDuration?: SortOrder
    selectedCardioType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutProgressSumOrderByAggregateInput = {
    currentExerciseIndex?: SortOrder
    xpEarned?: SortOrder
    totalVolume?: SortOrder
    completionPercentage?: SortOrder
    cardioDuration?: SortOrder
  }

  export type WorkoutNullableScalarRelationFilter = {
    is?: WorkoutWhereInput | null
    isNot?: WorkoutWhereInput | null
  }

  export type ExerciseLogListRelationFilter = {
    every?: ExerciseLogWhereInput
    some?: ExerciseLogWhereInput
    none?: ExerciseLogWhereInput
  }

  export type ExerciseLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    totalVolume?: SortOrder
    overallFeedback?: SortOrder
    bodyPartsFatigued?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutHistoryAvgOrderByAggregateInput = {
    duration?: SortOrder
    totalVolume?: SortOrder
  }

  export type WorkoutHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    totalVolume?: SortOrder
    overallFeedback?: SortOrder
    bodyPartsFatigued?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    totalVolume?: SortOrder
    overallFeedback?: SortOrder
    bodyPartsFatigued?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutHistorySumOrderByAggregateInput = {
    duration?: SortOrder
    totalVolume?: SortOrder
  }

  export type WorkoutHistoryScalarRelationFilter = {
    is?: WorkoutHistoryWhereInput
    isNot?: WorkoutHistoryWhereInput
  }

  export type ExerciseLogCountOrderByAggregateInput = {
    id?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    sets?: SortOrder
    notes?: SortOrder
    formCheckScore?: SortOrder
    difficulty?: SortOrder
  }

  export type ExerciseLogAvgOrderByAggregateInput = {
    formCheckScore?: SortOrder
  }

  export type ExerciseLogMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    sets?: SortOrder
    notes?: SortOrder
    formCheckScore?: SortOrder
    difficulty?: SortOrder
  }

  export type ExerciseLogMinOrderByAggregateInput = {
    id?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    sets?: SortOrder
    notes?: SortOrder
    formCheckScore?: SortOrder
    difficulty?: SortOrder
  }

  export type ExerciseLogSumOrderByAggregateInput = {
    formCheckScore?: SortOrder
  }

  export type WorkoutHistoryNullableScalarRelationFilter = {
    is?: WorkoutHistoryWhereInput | null
    isNot?: WorkoutHistoryWhereInput | null
  }

  export type PersonalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    type?: SortOrder
    value?: SortOrder
    date?: SortOrder
    previousBest?: SortOrder
  }

  export type PersonalRecordAvgOrderByAggregateInput = {
    value?: SortOrder
    previousBest?: SortOrder
  }

  export type PersonalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    type?: SortOrder
    value?: SortOrder
    date?: SortOrder
    previousBest?: SortOrder
  }

  export type PersonalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    workoutHistoryId?: SortOrder
    exerciseId?: SortOrder
    exerciseName?: SortOrder
    type?: SortOrder
    value?: SortOrder
    date?: SortOrder
    previousBest?: SortOrder
  }

  export type PersonalRecordSumOrderByAggregateInput = {
    value?: SortOrder
    previousBest?: SortOrder
  }

  export type MealListRelationFilter = {
    every?: MealWhereInput
    some?: MealWhereInput
    none?: MealWhereInput
  }

  export type MealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DietPlanCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    locked?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DietPlanAvgOrderByAggregateInput = {
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    order?: SortOrder
  }

  export type DietPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    locked?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DietPlanMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    locked?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DietPlanSumOrderByAggregateInput = {
    totalCalories?: SortOrder
    targetProtein?: SortOrder
    targetCarbs?: SortOrder
    targetFats?: SortOrder
    xpReward?: SortOrder
    order?: SortOrder
  }

  export type DietPlanScalarRelationFilter = {
    is?: DietPlanWhereInput
    isNot?: DietPlanWhereInput
  }

  export type MealCountOrderByAggregateInput = {
    id?: SortOrder
    dietPlanId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrder
    image?: SortOrder
    ingredients?: SortOrder
    order?: SortOrder
  }

  export type MealAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    order?: SortOrder
  }

  export type MealMaxOrderByAggregateInput = {
    id?: SortOrder
    dietPlanId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrder
    image?: SortOrder
    ingredients?: SortOrder
    order?: SortOrder
  }

  export type MealMinOrderByAggregateInput = {
    id?: SortOrder
    dietPlanId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrder
    image?: SortOrder
    ingredients?: SortOrder
    order?: SortOrder
  }

  export type MealSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    order?: SortOrder
  }

  export type DietPlanCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    dietPlanId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
  }

  export type DietPlanCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    dietPlanId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
  }

  export type DietPlanCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    dietPlanId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
  }

  export type NutritionMealListRelationFilter = {
    every?: NutritionMealWhereInput
    some?: NutritionMealWhereInput
    none?: NutritionMealWhereInput
  }

  export type NutritionMealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyNutritionStudentIdDateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type DailyNutritionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    waterIntake?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyNutritionAvgOrderByAggregateInput = {
    waterIntake?: SortOrder
  }

  export type DailyNutritionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    waterIntake?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyNutritionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    waterIntake?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyNutritionSumOrderByAggregateInput = {
    waterIntake?: SortOrder
  }

  export type DailyNutritionScalarRelationFilter = {
    is?: DailyNutritionWhereInput
    isNot?: DailyNutritionWhereInput
  }

  export type NutritionFoodItemListRelationFilter = {
    every?: NutritionFoodItemWhereInput
    some?: NutritionFoodItemWhereInput
    none?: NutritionFoodItemWhereInput
  }

  export type NutritionFoodItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NutritionMealCountOrderByAggregateInput = {
    id?: SortOrder
    dailyNutritionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrder
    completed?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionMealAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    order?: SortOrder
  }

  export type NutritionMealMaxOrderByAggregateInput = {
    id?: SortOrder
    dailyNutritionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrder
    completed?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionMealMinOrderByAggregateInput = {
    id?: SortOrder
    dailyNutritionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    time?: SortOrder
    completed?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionMealSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    order?: SortOrder
  }

  export type NutritionMealScalarRelationFilter = {
    is?: NutritionMealWhereInput
    isNot?: NutritionMealWhereInput
  }

  export type NutritionFoodItemCountOrderByAggregateInput = {
    id?: SortOrder
    nutritionMealId?: SortOrder
    foodId?: SortOrder
    foodName?: SortOrder
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    createdAt?: SortOrder
  }

  export type NutritionFoodItemAvgOrderByAggregateInput = {
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type NutritionFoodItemMaxOrderByAggregateInput = {
    id?: SortOrder
    nutritionMealId?: SortOrder
    foodId?: SortOrder
    foodName?: SortOrder
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    createdAt?: SortOrder
  }

  export type NutritionFoodItemMinOrderByAggregateInput = {
    id?: SortOrder
    nutritionMealId?: SortOrder
    foodId?: SortOrder
    foodName?: SortOrder
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    createdAt?: SortOrder
  }

  export type NutritionFoodItemSumOrderByAggregateInput = {
    servings?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type NutritionChatUsageStudentIdDateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type NutritionChatUsageCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionChatUsageAvgOrderByAggregateInput = {
    messageCount?: SortOrder
  }

  export type NutritionChatUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionChatUsageMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionChatUsageSumOrderByAggregateInput = {
    messageCount?: SortOrder
  }

  export type FoodItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    category?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type FoodItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    category?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    servingSize?: SortOrder
    category?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    level?: SortOrder
    color?: SortOrder
    target?: SortOrder
    xpReward?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    level?: SortOrder
    target?: SortOrder
    xpReward?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    level?: SortOrder
    color?: SortOrder
    target?: SortOrder
    xpReward?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    level?: SortOrder
    color?: SortOrder
    target?: SortOrder
    xpReward?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    level?: SortOrder
    target?: SortOrder
    xpReward?: SortOrder
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type AchievementUnlockCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlockedAt?: SortOrder
  }

  export type AchievementUnlockAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type AchievementUnlockMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlockedAt?: SortOrder
  }

  export type AchievementUnlockMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlockedAt?: SortOrder
  }

  export type AchievementUnlockSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type GymUserPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lastActiveGymId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymUserPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lastActiveGymId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymUserPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lastActiveGymId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanNullableScalarRelationFilter = {
    is?: MembershipPlanWhereInput | null
    isNot?: MembershipPlanWhereInput | null
  }

  export type GymMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMembershipAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type GymMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMembershipSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MembershipPlanCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    benefits?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type MembershipPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    benefits?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    benefits?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type DayPassCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    gymId?: SortOrder
    gymName?: SortOrder
    purchaseDate?: SortOrder
    validDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
  }

  export type DayPassAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DayPassMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    gymId?: SortOrder
    gymName?: SortOrder
    purchaseDate?: SortOrder
    validDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
  }

  export type DayPassMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    gymId?: SortOrder
    gymName?: SortOrder
    purchaseDate?: SortOrder
    validDate?: SortOrder
    price?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
  }

  export type DayPassSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CheckInCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    timestamp?: SortOrder
    checkOut?: SortOrder
    duration?: SortOrder
  }

  export type CheckInAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    timestamp?: SortOrder
    checkOut?: SortOrder
    duration?: SortOrder
  }

  export type CheckInMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    timestamp?: SortOrder
    checkOut?: SortOrder
    duration?: SortOrder
  }

  export type CheckInSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type MaintenanceRecordListRelationFilter = {
    every?: MaintenanceRecordWhereInput
    some?: MaintenanceRecordWhereInput
    none?: MaintenanceRecordWhereInput
  }

  export type MaintenanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    status?: SortOrder
    currentUserId?: SortOrder
    currentUserName?: SortOrder
    currentStartTime?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    status?: SortOrder
    currentUserId?: SortOrder
    currentUserName?: SortOrder
    currentStartTime?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    purchaseDate?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    status?: SortOrder
    currentUserId?: SortOrder
    currentUserName?: SortOrder
    currentStartTime?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type MaintenanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    nextScheduled?: SortOrder
  }

  export type MaintenanceRecordAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type MaintenanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    nextScheduled?: SortOrder
  }

  export type MaintenanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    nextScheduled?: SortOrder
  }

  export type MaintenanceRecordSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    planId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    planId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    planId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    cardBrand?: SortOrder
    last4?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    holderName?: SortOrder
    pixKey?: SortOrder
    pixKeyType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    cardBrand?: SortOrder
    last4?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    holderName?: SortOrder
    pixKey?: SortOrder
    pixKeyType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    cardBrand?: SortOrder
    last4?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    holderName?: SortOrder
    pixKey?: SortOrder
    pixKeyType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type FriendshipUserIdFriendIdCompoundUniqueInput = {
    userId: string
    friendId: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    abacatePayBillingId?: SortOrder
    abacatePayCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    abacatePayBillingId?: SortOrder
    abacatePayCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    abacatePayBillingId?: SortOrder
    abacatePayCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    plan?: SortOrder
    billingPeriod?: SortOrder
    status?: SortOrder
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    abacatePayBillingId?: SortOrder
    abacatePayCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSubscriptionAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
  }

  export type GymSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    plan?: SortOrder
    billingPeriod?: SortOrder
    status?: SortOrder
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    abacatePayBillingId?: SortOrder
    abacatePayCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    plan?: SortOrder
    billingPeriod?: SortOrder
    status?: SortOrder
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    abacatePayBillingId?: SortOrder
    abacatePayCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSubscriptionSumOrderByAggregateInput = {
    basePrice?: SortOrder
    pricePerStudent?: SortOrder
  }

  export type SubscriptionFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    featureKey?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    featureKey?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    featureKey?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    gymSubscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    abacatePayBillingId?: SortOrder
    paidAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    gymSubscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    abacatePayBillingId?: SortOrder
    paidAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    gymSubscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    abacatePayBillingId?: SortOrder
    paidAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type GymCreateNestedManyWithoutUserInput = {
    create?: XOR<GymCreateWithoutUserInput, GymUncheckedCreateWithoutUserInput> | GymCreateWithoutUserInput[] | GymUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GymCreateOrConnectWithoutUserInput | GymCreateOrConnectWithoutUserInput[]
    createMany?: GymCreateManyUserInputEnvelope
    connect?: GymWhereUniqueInput | GymWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type GymUserPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<GymUserPreferenceCreateWithoutUserInput, GymUserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: GymUserPreferenceCreateOrConnectWithoutUserInput
    connect?: GymUserPreferenceWhereUniqueInput
  }

  export type PaymentMethodCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type GymUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GymCreateWithoutUserInput, GymUncheckedCreateWithoutUserInput> | GymCreateWithoutUserInput[] | GymUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GymCreateOrConnectWithoutUserInput | GymCreateOrConnectWithoutUserInput[]
    createMany?: GymCreateManyUserInputEnvelope
    connect?: GymWhereUniqueInput | GymWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GymUserPreferenceCreateWithoutUserInput, GymUserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: GymUserPreferenceCreateOrConnectWithoutUserInput
    connect?: GymUserPreferenceWhereUniqueInput
  }

  export type PaymentMethodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type GymUpdateManyWithoutUserNestedInput = {
    create?: XOR<GymCreateWithoutUserInput, GymUncheckedCreateWithoutUserInput> | GymCreateWithoutUserInput[] | GymUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GymCreateOrConnectWithoutUserInput | GymCreateOrConnectWithoutUserInput[]
    upsert?: GymUpsertWithWhereUniqueWithoutUserInput | GymUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GymCreateManyUserInputEnvelope
    set?: GymWhereUniqueInput | GymWhereUniqueInput[]
    disconnect?: GymWhereUniqueInput | GymWhereUniqueInput[]
    delete?: GymWhereUniqueInput | GymWhereUniqueInput[]
    connect?: GymWhereUniqueInput | GymWhereUniqueInput[]
    update?: GymUpdateWithWhereUniqueWithoutUserInput | GymUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GymUpdateManyWithWhereWithoutUserInput | GymUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GymScalarWhereInput | GymScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type GymUserPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<GymUserPreferenceCreateWithoutUserInput, GymUserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: GymUserPreferenceCreateOrConnectWithoutUserInput
    upsert?: GymUserPreferenceUpsertWithoutUserInput
    disconnect?: GymUserPreferenceWhereInput | boolean
    delete?: GymUserPreferenceWhereInput | boolean
    connect?: GymUserPreferenceWhereUniqueInput
    update?: XOR<XOR<GymUserPreferenceUpdateToOneWithWhereWithoutUserInput, GymUserPreferenceUpdateWithoutUserInput>, GymUserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type PaymentMethodUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutUserInput | PaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutUserInput | PaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutUserInput | PaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type GymUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GymCreateWithoutUserInput, GymUncheckedCreateWithoutUserInput> | GymCreateWithoutUserInput[] | GymUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GymCreateOrConnectWithoutUserInput | GymCreateOrConnectWithoutUserInput[]
    upsert?: GymUpsertWithWhereUniqueWithoutUserInput | GymUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GymCreateManyUserInputEnvelope
    set?: GymWhereUniqueInput | GymWhereUniqueInput[]
    disconnect?: GymWhereUniqueInput | GymWhereUniqueInput[]
    delete?: GymWhereUniqueInput | GymWhereUniqueInput[]
    connect?: GymWhereUniqueInput | GymWhereUniqueInput[]
    update?: GymUpdateWithWhereUniqueWithoutUserInput | GymUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GymUpdateManyWithWhereWithoutUserInput | GymUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GymScalarWhereInput | GymScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GymUserPreferenceCreateWithoutUserInput, GymUserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: GymUserPreferenceCreateOrConnectWithoutUserInput
    upsert?: GymUserPreferenceUpsertWithoutUserInput
    disconnect?: GymUserPreferenceWhereInput | boolean
    delete?: GymUserPreferenceWhereInput | boolean
    connect?: GymUserPreferenceWhereUniqueInput
    update?: XOR<XOR<GymUserPreferenceUpdateToOneWithWhereWithoutUserInput, GymUserPreferenceUpdateWithoutUserInput>, GymUserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type PaymentMethodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutUserInput | PaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutUserInput | PaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutUserInput | PaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type StudentProgressCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentProgressCreateWithoutStudentInput, StudentProgressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentInput
    connect?: StudentProgressWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentProfileCreateWithoutStudentInput, StudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutStudentInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type WorkoutHistoryCreateNestedManyWithoutStudentInput = {
    create?: XOR<WorkoutHistoryCreateWithoutStudentInput, WorkoutHistoryUncheckedCreateWithoutStudentInput> | WorkoutHistoryCreateWithoutStudentInput[] | WorkoutHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutStudentInput | WorkoutHistoryCreateOrConnectWithoutStudentInput[]
    createMany?: WorkoutHistoryCreateManyStudentInputEnvelope
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
  }

  export type WorkoutProgressCreateNestedManyWithoutStudentInput = {
    create?: XOR<WorkoutProgressCreateWithoutStudentInput, WorkoutProgressUncheckedCreateWithoutStudentInput> | WorkoutProgressCreateWithoutStudentInput[] | WorkoutProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutStudentInput | WorkoutProgressCreateOrConnectWithoutStudentInput[]
    createMany?: WorkoutProgressCreateManyStudentInputEnvelope
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
  }

  export type PersonalRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<PersonalRecordCreateWithoutStudentInput, PersonalRecordUncheckedCreateWithoutStudentInput> | PersonalRecordCreateWithoutStudentInput[] | PersonalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutStudentInput | PersonalRecordCreateOrConnectWithoutStudentInput[]
    createMany?: PersonalRecordCreateManyStudentInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type DietPlanCompletionCreateNestedManyWithoutStudentInput = {
    create?: XOR<DietPlanCompletionCreateWithoutStudentInput, DietPlanCompletionUncheckedCreateWithoutStudentInput> | DietPlanCompletionCreateWithoutStudentInput[] | DietPlanCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutStudentInput | DietPlanCompletionCreateOrConnectWithoutStudentInput[]
    createMany?: DietPlanCompletionCreateManyStudentInputEnvelope
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
  }

  export type AchievementUnlockCreateNestedManyWithoutStudentInput = {
    create?: XOR<AchievementUnlockCreateWithoutStudentInput, AchievementUnlockUncheckedCreateWithoutStudentInput> | AchievementUnlockCreateWithoutStudentInput[] | AchievementUnlockUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutStudentInput | AchievementUnlockCreateOrConnectWithoutStudentInput[]
    createMany?: AchievementUnlockCreateManyStudentInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type WeightHistoryCreateNestedManyWithoutStudentInput = {
    create?: XOR<WeightHistoryCreateWithoutStudentInput, WeightHistoryUncheckedCreateWithoutStudentInput> | WeightHistoryCreateWithoutStudentInput[] | WeightHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WeightHistoryCreateOrConnectWithoutStudentInput | WeightHistoryCreateOrConnectWithoutStudentInput[]
    createMany?: WeightHistoryCreateManyStudentInputEnvelope
    connect?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
  }

  export type DailyNutritionCreateNestedManyWithoutStudentInput = {
    create?: XOR<DailyNutritionCreateWithoutStudentInput, DailyNutritionUncheckedCreateWithoutStudentInput> | DailyNutritionCreateWithoutStudentInput[] | DailyNutritionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DailyNutritionCreateOrConnectWithoutStudentInput | DailyNutritionCreateOrConnectWithoutStudentInput[]
    createMany?: DailyNutritionCreateManyStudentInputEnvelope
    connect?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
  }

  export type NutritionChatUsageCreateNestedManyWithoutStudentInput = {
    create?: XOR<NutritionChatUsageCreateWithoutStudentInput, NutritionChatUsageUncheckedCreateWithoutStudentInput> | NutritionChatUsageCreateWithoutStudentInput[] | NutritionChatUsageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NutritionChatUsageCreateOrConnectWithoutStudentInput | NutritionChatUsageCreateOrConnectWithoutStudentInput[]
    createMany?: NutritionChatUsageCreateManyStudentInputEnvelope
    connect?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutStudentInput = {
    create?: XOR<UnitCreateWithoutStudentInput, UnitUncheckedCreateWithoutStudentInput> | UnitCreateWithoutStudentInput[] | UnitUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutStudentInput | UnitCreateOrConnectWithoutStudentInput[]
    createMany?: UnitCreateManyStudentInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type GymMembershipCreateNestedManyWithoutStudentInput = {
    create?: XOR<GymMembershipCreateWithoutStudentInput, GymMembershipUncheckedCreateWithoutStudentInput> | GymMembershipCreateWithoutStudentInput[] | GymMembershipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutStudentInput | GymMembershipCreateOrConnectWithoutStudentInput[]
    createMany?: GymMembershipCreateManyStudentInputEnvelope
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
  }

  export type DayPassCreateNestedManyWithoutStudentInput = {
    create?: XOR<DayPassCreateWithoutStudentInput, DayPassUncheckedCreateWithoutStudentInput> | DayPassCreateWithoutStudentInput[] | DayPassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DayPassCreateOrConnectWithoutStudentInput | DayPassCreateOrConnectWithoutStudentInput[]
    createMany?: DayPassCreateManyStudentInputEnvelope
    connect?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutStudentInput = {
    create?: XOR<SubscriptionCreateWithoutStudentInput, SubscriptionUncheckedCreateWithoutStudentInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStudentInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type StudentProgressUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentProgressCreateWithoutStudentInput, StudentProgressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentInput
    connect?: StudentProgressWhereUniqueInput
  }

  export type StudentProfileUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentProfileCreateWithoutStudentInput, StudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutStudentInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<WorkoutHistoryCreateWithoutStudentInput, WorkoutHistoryUncheckedCreateWithoutStudentInput> | WorkoutHistoryCreateWithoutStudentInput[] | WorkoutHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutStudentInput | WorkoutHistoryCreateOrConnectWithoutStudentInput[]
    createMany?: WorkoutHistoryCreateManyStudentInputEnvelope
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
  }

  export type WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<WorkoutProgressCreateWithoutStudentInput, WorkoutProgressUncheckedCreateWithoutStudentInput> | WorkoutProgressCreateWithoutStudentInput[] | WorkoutProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutStudentInput | WorkoutProgressCreateOrConnectWithoutStudentInput[]
    createMany?: WorkoutProgressCreateManyStudentInputEnvelope
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
  }

  export type PersonalRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PersonalRecordCreateWithoutStudentInput, PersonalRecordUncheckedCreateWithoutStudentInput> | PersonalRecordCreateWithoutStudentInput[] | PersonalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutStudentInput | PersonalRecordCreateOrConnectWithoutStudentInput[]
    createMany?: PersonalRecordCreateManyStudentInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<DietPlanCompletionCreateWithoutStudentInput, DietPlanCompletionUncheckedCreateWithoutStudentInput> | DietPlanCompletionCreateWithoutStudentInput[] | DietPlanCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutStudentInput | DietPlanCompletionCreateOrConnectWithoutStudentInput[]
    createMany?: DietPlanCompletionCreateManyStudentInputEnvelope
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
  }

  export type AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AchievementUnlockCreateWithoutStudentInput, AchievementUnlockUncheckedCreateWithoutStudentInput> | AchievementUnlockCreateWithoutStudentInput[] | AchievementUnlockUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutStudentInput | AchievementUnlockCreateOrConnectWithoutStudentInput[]
    createMany?: AchievementUnlockCreateManyStudentInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type WeightHistoryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<WeightHistoryCreateWithoutStudentInput, WeightHistoryUncheckedCreateWithoutStudentInput> | WeightHistoryCreateWithoutStudentInput[] | WeightHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WeightHistoryCreateOrConnectWithoutStudentInput | WeightHistoryCreateOrConnectWithoutStudentInput[]
    createMany?: WeightHistoryCreateManyStudentInputEnvelope
    connect?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
  }

  export type DailyNutritionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<DailyNutritionCreateWithoutStudentInput, DailyNutritionUncheckedCreateWithoutStudentInput> | DailyNutritionCreateWithoutStudentInput[] | DailyNutritionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DailyNutritionCreateOrConnectWithoutStudentInput | DailyNutritionCreateOrConnectWithoutStudentInput[]
    createMany?: DailyNutritionCreateManyStudentInputEnvelope
    connect?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
  }

  export type NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NutritionChatUsageCreateWithoutStudentInput, NutritionChatUsageUncheckedCreateWithoutStudentInput> | NutritionChatUsageCreateWithoutStudentInput[] | NutritionChatUsageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NutritionChatUsageCreateOrConnectWithoutStudentInput | NutritionChatUsageCreateOrConnectWithoutStudentInput[]
    createMany?: NutritionChatUsageCreateManyStudentInputEnvelope
    connect?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<UnitCreateWithoutStudentInput, UnitUncheckedCreateWithoutStudentInput> | UnitCreateWithoutStudentInput[] | UnitUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutStudentInput | UnitCreateOrConnectWithoutStudentInput[]
    createMany?: UnitCreateManyStudentInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type GymMembershipUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<GymMembershipCreateWithoutStudentInput, GymMembershipUncheckedCreateWithoutStudentInput> | GymMembershipCreateWithoutStudentInput[] | GymMembershipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutStudentInput | GymMembershipCreateOrConnectWithoutStudentInput[]
    createMany?: GymMembershipCreateManyStudentInputEnvelope
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
  }

  export type DayPassUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<DayPassCreateWithoutStudentInput, DayPassUncheckedCreateWithoutStudentInput> | DayPassCreateWithoutStudentInput[] | DayPassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DayPassCreateOrConnectWithoutStudentInput | DayPassCreateOrConnectWithoutStudentInput[]
    createMany?: DayPassCreateManyStudentInputEnvelope
    connect?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<SubscriptionCreateWithoutStudentInput, SubscriptionUncheckedCreateWithoutStudentInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStudentInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type StudentProgressUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentProgressCreateWithoutStudentInput, StudentProgressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentInput
    upsert?: StudentProgressUpsertWithoutStudentInput
    disconnect?: StudentProgressWhereInput | boolean
    delete?: StudentProgressWhereInput | boolean
    connect?: StudentProgressWhereUniqueInput
    update?: XOR<XOR<StudentProgressUpdateToOneWithWhereWithoutStudentInput, StudentProgressUpdateWithoutStudentInput>, StudentProgressUncheckedUpdateWithoutStudentInput>
  }

  export type StudentProfileUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentProfileCreateWithoutStudentInput, StudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutStudentInput
    upsert?: StudentProfileUpsertWithoutStudentInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutStudentInput, StudentProfileUpdateWithoutStudentInput>, StudentProfileUncheckedUpdateWithoutStudentInput>
  }

  export type WorkoutHistoryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<WorkoutHistoryCreateWithoutStudentInput, WorkoutHistoryUncheckedCreateWithoutStudentInput> | WorkoutHistoryCreateWithoutStudentInput[] | WorkoutHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutStudentInput | WorkoutHistoryCreateOrConnectWithoutStudentInput[]
    upsert?: WorkoutHistoryUpsertWithWhereUniqueWithoutStudentInput | WorkoutHistoryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: WorkoutHistoryCreateManyStudentInputEnvelope
    set?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    disconnect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    delete?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    update?: WorkoutHistoryUpdateWithWhereUniqueWithoutStudentInput | WorkoutHistoryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: WorkoutHistoryUpdateManyWithWhereWithoutStudentInput | WorkoutHistoryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: WorkoutHistoryScalarWhereInput | WorkoutHistoryScalarWhereInput[]
  }

  export type WorkoutProgressUpdateManyWithoutStudentNestedInput = {
    create?: XOR<WorkoutProgressCreateWithoutStudentInput, WorkoutProgressUncheckedCreateWithoutStudentInput> | WorkoutProgressCreateWithoutStudentInput[] | WorkoutProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutStudentInput | WorkoutProgressCreateOrConnectWithoutStudentInput[]
    upsert?: WorkoutProgressUpsertWithWhereUniqueWithoutStudentInput | WorkoutProgressUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: WorkoutProgressCreateManyStudentInputEnvelope
    set?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    disconnect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    delete?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    update?: WorkoutProgressUpdateWithWhereUniqueWithoutStudentInput | WorkoutProgressUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: WorkoutProgressUpdateManyWithWhereWithoutStudentInput | WorkoutProgressUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: WorkoutProgressScalarWhereInput | WorkoutProgressScalarWhereInput[]
  }

  export type PersonalRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutStudentInput, PersonalRecordUncheckedCreateWithoutStudentInput> | PersonalRecordCreateWithoutStudentInput[] | PersonalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutStudentInput | PersonalRecordCreateOrConnectWithoutStudentInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutStudentInput | PersonalRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PersonalRecordCreateManyStudentInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutStudentInput | PersonalRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutStudentInput | PersonalRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type DietPlanCompletionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DietPlanCompletionCreateWithoutStudentInput, DietPlanCompletionUncheckedCreateWithoutStudentInput> | DietPlanCompletionCreateWithoutStudentInput[] | DietPlanCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutStudentInput | DietPlanCompletionCreateOrConnectWithoutStudentInput[]
    upsert?: DietPlanCompletionUpsertWithWhereUniqueWithoutStudentInput | DietPlanCompletionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DietPlanCompletionCreateManyStudentInputEnvelope
    set?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    disconnect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    delete?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    update?: DietPlanCompletionUpdateWithWhereUniqueWithoutStudentInput | DietPlanCompletionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DietPlanCompletionUpdateManyWithWhereWithoutStudentInput | DietPlanCompletionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DietPlanCompletionScalarWhereInput | DietPlanCompletionScalarWhereInput[]
  }

  export type AchievementUnlockUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutStudentInput, AchievementUnlockUncheckedCreateWithoutStudentInput> | AchievementUnlockCreateWithoutStudentInput[] | AchievementUnlockUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutStudentInput | AchievementUnlockCreateOrConnectWithoutStudentInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutStudentInput | AchievementUnlockUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AchievementUnlockCreateManyStudentInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutStudentInput | AchievementUnlockUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutStudentInput | AchievementUnlockUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type WeightHistoryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<WeightHistoryCreateWithoutStudentInput, WeightHistoryUncheckedCreateWithoutStudentInput> | WeightHistoryCreateWithoutStudentInput[] | WeightHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WeightHistoryCreateOrConnectWithoutStudentInput | WeightHistoryCreateOrConnectWithoutStudentInput[]
    upsert?: WeightHistoryUpsertWithWhereUniqueWithoutStudentInput | WeightHistoryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: WeightHistoryCreateManyStudentInputEnvelope
    set?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    disconnect?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    delete?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    connect?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    update?: WeightHistoryUpdateWithWhereUniqueWithoutStudentInput | WeightHistoryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: WeightHistoryUpdateManyWithWhereWithoutStudentInput | WeightHistoryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: WeightHistoryScalarWhereInput | WeightHistoryScalarWhereInput[]
  }

  export type DailyNutritionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DailyNutritionCreateWithoutStudentInput, DailyNutritionUncheckedCreateWithoutStudentInput> | DailyNutritionCreateWithoutStudentInput[] | DailyNutritionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DailyNutritionCreateOrConnectWithoutStudentInput | DailyNutritionCreateOrConnectWithoutStudentInput[]
    upsert?: DailyNutritionUpsertWithWhereUniqueWithoutStudentInput | DailyNutritionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DailyNutritionCreateManyStudentInputEnvelope
    set?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    disconnect?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    delete?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    connect?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    update?: DailyNutritionUpdateWithWhereUniqueWithoutStudentInput | DailyNutritionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DailyNutritionUpdateManyWithWhereWithoutStudentInput | DailyNutritionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DailyNutritionScalarWhereInput | DailyNutritionScalarWhereInput[]
  }

  export type NutritionChatUsageUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NutritionChatUsageCreateWithoutStudentInput, NutritionChatUsageUncheckedCreateWithoutStudentInput> | NutritionChatUsageCreateWithoutStudentInput[] | NutritionChatUsageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NutritionChatUsageCreateOrConnectWithoutStudentInput | NutritionChatUsageCreateOrConnectWithoutStudentInput[]
    upsert?: NutritionChatUsageUpsertWithWhereUniqueWithoutStudentInput | NutritionChatUsageUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NutritionChatUsageCreateManyStudentInputEnvelope
    set?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    disconnect?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    delete?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    connect?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    update?: NutritionChatUsageUpdateWithWhereUniqueWithoutStudentInput | NutritionChatUsageUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NutritionChatUsageUpdateManyWithWhereWithoutStudentInput | NutritionChatUsageUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NutritionChatUsageScalarWhereInput | NutritionChatUsageScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutStudentNestedInput = {
    create?: XOR<UnitCreateWithoutStudentInput, UnitUncheckedCreateWithoutStudentInput> | UnitCreateWithoutStudentInput[] | UnitUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutStudentInput | UnitCreateOrConnectWithoutStudentInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutStudentInput | UnitUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: UnitCreateManyStudentInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutStudentInput | UnitUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutStudentInput | UnitUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type GymMembershipUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GymMembershipCreateWithoutStudentInput, GymMembershipUncheckedCreateWithoutStudentInput> | GymMembershipCreateWithoutStudentInput[] | GymMembershipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutStudentInput | GymMembershipCreateOrConnectWithoutStudentInput[]
    upsert?: GymMembershipUpsertWithWhereUniqueWithoutStudentInput | GymMembershipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GymMembershipCreateManyStudentInputEnvelope
    set?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    disconnect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    delete?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    update?: GymMembershipUpdateWithWhereUniqueWithoutStudentInput | GymMembershipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GymMembershipUpdateManyWithWhereWithoutStudentInput | GymMembershipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
  }

  export type DayPassUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DayPassCreateWithoutStudentInput, DayPassUncheckedCreateWithoutStudentInput> | DayPassCreateWithoutStudentInput[] | DayPassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DayPassCreateOrConnectWithoutStudentInput | DayPassCreateOrConnectWithoutStudentInput[]
    upsert?: DayPassUpsertWithWhereUniqueWithoutStudentInput | DayPassUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DayPassCreateManyStudentInputEnvelope
    set?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    disconnect?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    delete?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    connect?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    update?: DayPassUpdateWithWhereUniqueWithoutStudentInput | DayPassUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DayPassUpdateManyWithWhereWithoutStudentInput | DayPassUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DayPassScalarWhereInput | DayPassScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserInput | FriendshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserInput | FriendshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserInput | FriendshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutFriendInput | FriendshipUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutFriendInput | FriendshipUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutFriendInput | FriendshipUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutStudentNestedInput = {
    create?: XOR<SubscriptionCreateWithoutStudentInput, SubscriptionUncheckedCreateWithoutStudentInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStudentInput
    upsert?: SubscriptionUpsertWithoutStudentInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutStudentInput, SubscriptionUpdateWithoutStudentInput>, SubscriptionUncheckedUpdateWithoutStudentInput>
  }

  export type StudentProgressUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentProgressCreateWithoutStudentInput, StudentProgressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentInput
    upsert?: StudentProgressUpsertWithoutStudentInput
    disconnect?: StudentProgressWhereInput | boolean
    delete?: StudentProgressWhereInput | boolean
    connect?: StudentProgressWhereUniqueInput
    update?: XOR<XOR<StudentProgressUpdateToOneWithWhereWithoutStudentInput, StudentProgressUpdateWithoutStudentInput>, StudentProgressUncheckedUpdateWithoutStudentInput>
  }

  export type StudentProfileUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentProfileCreateWithoutStudentInput, StudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutStudentInput
    upsert?: StudentProfileUpsertWithoutStudentInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutStudentInput, StudentProfileUpdateWithoutStudentInput>, StudentProfileUncheckedUpdateWithoutStudentInput>
  }

  export type WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<WorkoutHistoryCreateWithoutStudentInput, WorkoutHistoryUncheckedCreateWithoutStudentInput> | WorkoutHistoryCreateWithoutStudentInput[] | WorkoutHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutStudentInput | WorkoutHistoryCreateOrConnectWithoutStudentInput[]
    upsert?: WorkoutHistoryUpsertWithWhereUniqueWithoutStudentInput | WorkoutHistoryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: WorkoutHistoryCreateManyStudentInputEnvelope
    set?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    disconnect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    delete?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    update?: WorkoutHistoryUpdateWithWhereUniqueWithoutStudentInput | WorkoutHistoryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: WorkoutHistoryUpdateManyWithWhereWithoutStudentInput | WorkoutHistoryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: WorkoutHistoryScalarWhereInput | WorkoutHistoryScalarWhereInput[]
  }

  export type WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<WorkoutProgressCreateWithoutStudentInput, WorkoutProgressUncheckedCreateWithoutStudentInput> | WorkoutProgressCreateWithoutStudentInput[] | WorkoutProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutStudentInput | WorkoutProgressCreateOrConnectWithoutStudentInput[]
    upsert?: WorkoutProgressUpsertWithWhereUniqueWithoutStudentInput | WorkoutProgressUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: WorkoutProgressCreateManyStudentInputEnvelope
    set?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    disconnect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    delete?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    update?: WorkoutProgressUpdateWithWhereUniqueWithoutStudentInput | WorkoutProgressUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: WorkoutProgressUpdateManyWithWhereWithoutStudentInput | WorkoutProgressUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: WorkoutProgressScalarWhereInput | WorkoutProgressScalarWhereInput[]
  }

  export type PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutStudentInput, PersonalRecordUncheckedCreateWithoutStudentInput> | PersonalRecordCreateWithoutStudentInput[] | PersonalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutStudentInput | PersonalRecordCreateOrConnectWithoutStudentInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutStudentInput | PersonalRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PersonalRecordCreateManyStudentInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutStudentInput | PersonalRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutStudentInput | PersonalRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DietPlanCompletionCreateWithoutStudentInput, DietPlanCompletionUncheckedCreateWithoutStudentInput> | DietPlanCompletionCreateWithoutStudentInput[] | DietPlanCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutStudentInput | DietPlanCompletionCreateOrConnectWithoutStudentInput[]
    upsert?: DietPlanCompletionUpsertWithWhereUniqueWithoutStudentInput | DietPlanCompletionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DietPlanCompletionCreateManyStudentInputEnvelope
    set?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    disconnect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    delete?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    update?: DietPlanCompletionUpdateWithWhereUniqueWithoutStudentInput | DietPlanCompletionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DietPlanCompletionUpdateManyWithWhereWithoutStudentInput | DietPlanCompletionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DietPlanCompletionScalarWhereInput | DietPlanCompletionScalarWhereInput[]
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutStudentInput, AchievementUnlockUncheckedCreateWithoutStudentInput> | AchievementUnlockCreateWithoutStudentInput[] | AchievementUnlockUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutStudentInput | AchievementUnlockCreateOrConnectWithoutStudentInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutStudentInput | AchievementUnlockUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AchievementUnlockCreateManyStudentInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutStudentInput | AchievementUnlockUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutStudentInput | AchievementUnlockUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<WeightHistoryCreateWithoutStudentInput, WeightHistoryUncheckedCreateWithoutStudentInput> | WeightHistoryCreateWithoutStudentInput[] | WeightHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: WeightHistoryCreateOrConnectWithoutStudentInput | WeightHistoryCreateOrConnectWithoutStudentInput[]
    upsert?: WeightHistoryUpsertWithWhereUniqueWithoutStudentInput | WeightHistoryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: WeightHistoryCreateManyStudentInputEnvelope
    set?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    disconnect?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    delete?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    connect?: WeightHistoryWhereUniqueInput | WeightHistoryWhereUniqueInput[]
    update?: WeightHistoryUpdateWithWhereUniqueWithoutStudentInput | WeightHistoryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: WeightHistoryUpdateManyWithWhereWithoutStudentInput | WeightHistoryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: WeightHistoryScalarWhereInput | WeightHistoryScalarWhereInput[]
  }

  export type DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DailyNutritionCreateWithoutStudentInput, DailyNutritionUncheckedCreateWithoutStudentInput> | DailyNutritionCreateWithoutStudentInput[] | DailyNutritionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DailyNutritionCreateOrConnectWithoutStudentInput | DailyNutritionCreateOrConnectWithoutStudentInput[]
    upsert?: DailyNutritionUpsertWithWhereUniqueWithoutStudentInput | DailyNutritionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DailyNutritionCreateManyStudentInputEnvelope
    set?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    disconnect?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    delete?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    connect?: DailyNutritionWhereUniqueInput | DailyNutritionWhereUniqueInput[]
    update?: DailyNutritionUpdateWithWhereUniqueWithoutStudentInput | DailyNutritionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DailyNutritionUpdateManyWithWhereWithoutStudentInput | DailyNutritionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DailyNutritionScalarWhereInput | DailyNutritionScalarWhereInput[]
  }

  export type NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NutritionChatUsageCreateWithoutStudentInput, NutritionChatUsageUncheckedCreateWithoutStudentInput> | NutritionChatUsageCreateWithoutStudentInput[] | NutritionChatUsageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NutritionChatUsageCreateOrConnectWithoutStudentInput | NutritionChatUsageCreateOrConnectWithoutStudentInput[]
    upsert?: NutritionChatUsageUpsertWithWhereUniqueWithoutStudentInput | NutritionChatUsageUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NutritionChatUsageCreateManyStudentInputEnvelope
    set?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    disconnect?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    delete?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    connect?: NutritionChatUsageWhereUniqueInput | NutritionChatUsageWhereUniqueInput[]
    update?: NutritionChatUsageUpdateWithWhereUniqueWithoutStudentInput | NutritionChatUsageUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NutritionChatUsageUpdateManyWithWhereWithoutStudentInput | NutritionChatUsageUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NutritionChatUsageScalarWhereInput | NutritionChatUsageScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<UnitCreateWithoutStudentInput, UnitUncheckedCreateWithoutStudentInput> | UnitCreateWithoutStudentInput[] | UnitUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutStudentInput | UnitCreateOrConnectWithoutStudentInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutStudentInput | UnitUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: UnitCreateManyStudentInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutStudentInput | UnitUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutStudentInput | UnitUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type GymMembershipUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GymMembershipCreateWithoutStudentInput, GymMembershipUncheckedCreateWithoutStudentInput> | GymMembershipCreateWithoutStudentInput[] | GymMembershipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutStudentInput | GymMembershipCreateOrConnectWithoutStudentInput[]
    upsert?: GymMembershipUpsertWithWhereUniqueWithoutStudentInput | GymMembershipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GymMembershipCreateManyStudentInputEnvelope
    set?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    disconnect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    delete?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    update?: GymMembershipUpdateWithWhereUniqueWithoutStudentInput | GymMembershipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GymMembershipUpdateManyWithWhereWithoutStudentInput | GymMembershipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
  }

  export type DayPassUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DayPassCreateWithoutStudentInput, DayPassUncheckedCreateWithoutStudentInput> | DayPassCreateWithoutStudentInput[] | DayPassUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DayPassCreateOrConnectWithoutStudentInput | DayPassCreateOrConnectWithoutStudentInput[]
    upsert?: DayPassUpsertWithWhereUniqueWithoutStudentInput | DayPassUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DayPassCreateManyStudentInputEnvelope
    set?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    disconnect?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    delete?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    connect?: DayPassWhereUniqueInput | DayPassWhereUniqueInput[]
    update?: DayPassUpdateWithWhereUniqueWithoutStudentInput | DayPassUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DayPassUpdateManyWithWhereWithoutStudentInput | DayPassUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DayPassScalarWhereInput | DayPassScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserInput | FriendshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserInput | FriendshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserInput | FriendshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutFriendInput | FriendshipUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutFriendInput | FriendshipUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutFriendInput | FriendshipUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<SubscriptionCreateWithoutStudentInput, SubscriptionUncheckedCreateWithoutStudentInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStudentInput
    upsert?: SubscriptionUpsertWithoutStudentInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutStudentInput, SubscriptionUpdateWithoutStudentInput>, SubscriptionUncheckedUpdateWithoutStudentInput>
  }

  export type StudentCreateNestedOneWithoutProgressInput = {
    create?: XOR<StudentCreateWithoutProgressInput, StudentUncheckedCreateWithoutProgressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProgressInput
    connect?: StudentWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<StudentCreateWithoutProgressInput, StudentUncheckedCreateWithoutProgressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProgressInput
    upsert?: StudentUpsertWithoutProgressInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutProgressInput, StudentUpdateWithoutProgressInput>, StudentUncheckedUpdateWithoutProgressInput>
  }

  export type StudentCreateNestedOneWithoutProfileInput = {
    create?: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProfileInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProfileInput
    upsert?: StudentUpsertWithoutProfileInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutProfileInput, StudentUpdateWithoutProfileInput>, StudentUncheckedUpdateWithoutProfileInput>
  }

  export type StudentCreateNestedOneWithoutWeightHistoryInput = {
    create?: XOR<StudentCreateWithoutWeightHistoryInput, StudentUncheckedCreateWithoutWeightHistoryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutWeightHistoryInput
    connect?: StudentWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutWeightHistoryNestedInput = {
    create?: XOR<StudentCreateWithoutWeightHistoryInput, StudentUncheckedCreateWithoutWeightHistoryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutWeightHistoryInput
    upsert?: StudentUpsertWithoutWeightHistoryInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutWeightHistoryInput, StudentUpdateWithoutWeightHistoryInput>, StudentUncheckedUpdateWithoutWeightHistoryInput>
  }

  export type UserCreateNestedOneWithoutGymsInput = {
    create?: XOR<UserCreateWithoutGymsInput, UserUncheckedCreateWithoutGymsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGymsInput
    connect?: UserWhereUniqueInput
  }

  export type GymProfileCreateNestedOneWithoutGymInput = {
    create?: XOR<GymProfileCreateWithoutGymInput, GymProfileUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymProfileCreateOrConnectWithoutGymInput
    connect?: GymProfileWhereUniqueInput
  }

  export type GymMembershipCreateNestedManyWithoutGymInput = {
    create?: XOR<GymMembershipCreateWithoutGymInput, GymMembershipUncheckedCreateWithoutGymInput> | GymMembershipCreateWithoutGymInput[] | GymMembershipUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutGymInput | GymMembershipCreateOrConnectWithoutGymInput[]
    createMany?: GymMembershipCreateManyGymInputEnvelope
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutGymInput = {
    create?: XOR<EquipmentCreateWithoutGymInput, EquipmentUncheckedCreateWithoutGymInput> | EquipmentCreateWithoutGymInput[] | EquipmentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutGymInput | EquipmentCreateOrConnectWithoutGymInput[]
    createMany?: EquipmentCreateManyGymInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type MembershipPlanCreateNestedManyWithoutGymInput = {
    create?: XOR<MembershipPlanCreateWithoutGymInput, MembershipPlanUncheckedCreateWithoutGymInput> | MembershipPlanCreateWithoutGymInput[] | MembershipPlanUncheckedCreateWithoutGymInput[]
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutGymInput | MembershipPlanCreateOrConnectWithoutGymInput[]
    createMany?: MembershipPlanCreateManyGymInputEnvelope
    connect?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutGymInput = {
    create?: XOR<PaymentCreateWithoutGymInput, PaymentUncheckedCreateWithoutGymInput> | PaymentCreateWithoutGymInput[] | PaymentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutGymInput | PaymentCreateOrConnectWithoutGymInput[]
    createMany?: PaymentCreateManyGymInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutGymInput = {
    create?: XOR<ExpenseCreateWithoutGymInput, ExpenseUncheckedCreateWithoutGymInput> | ExpenseCreateWithoutGymInput[] | ExpenseUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutGymInput | ExpenseCreateOrConnectWithoutGymInput[]
    createMany?: ExpenseCreateManyGymInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type CheckInCreateNestedManyWithoutGymInput = {
    create?: XOR<CheckInCreateWithoutGymInput, CheckInUncheckedCreateWithoutGymInput> | CheckInCreateWithoutGymInput[] | CheckInUncheckedCreateWithoutGymInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutGymInput | CheckInCreateOrConnectWithoutGymInput[]
    createMany?: CheckInCreateManyGymInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type GymStatsCreateNestedOneWithoutGymInput = {
    create?: XOR<GymStatsCreateWithoutGymInput, GymStatsUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymStatsCreateOrConnectWithoutGymInput
    connect?: GymStatsWhereUniqueInput
  }

  export type GymSubscriptionCreateNestedOneWithoutGymInput = {
    create?: XOR<GymSubscriptionCreateWithoutGymInput, GymSubscriptionUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutGymInput
    connect?: GymSubscriptionWhereUniqueInput
  }

  export type GymProfileUncheckedCreateNestedOneWithoutGymInput = {
    create?: XOR<GymProfileCreateWithoutGymInput, GymProfileUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymProfileCreateOrConnectWithoutGymInput
    connect?: GymProfileWhereUniqueInput
  }

  export type GymMembershipUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<GymMembershipCreateWithoutGymInput, GymMembershipUncheckedCreateWithoutGymInput> | GymMembershipCreateWithoutGymInput[] | GymMembershipUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutGymInput | GymMembershipCreateOrConnectWithoutGymInput[]
    createMany?: GymMembershipCreateManyGymInputEnvelope
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<EquipmentCreateWithoutGymInput, EquipmentUncheckedCreateWithoutGymInput> | EquipmentCreateWithoutGymInput[] | EquipmentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutGymInput | EquipmentCreateOrConnectWithoutGymInput[]
    createMany?: EquipmentCreateManyGymInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type MembershipPlanUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<MembershipPlanCreateWithoutGymInput, MembershipPlanUncheckedCreateWithoutGymInput> | MembershipPlanCreateWithoutGymInput[] | MembershipPlanUncheckedCreateWithoutGymInput[]
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutGymInput | MembershipPlanCreateOrConnectWithoutGymInput[]
    createMany?: MembershipPlanCreateManyGymInputEnvelope
    connect?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<PaymentCreateWithoutGymInput, PaymentUncheckedCreateWithoutGymInput> | PaymentCreateWithoutGymInput[] | PaymentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutGymInput | PaymentCreateOrConnectWithoutGymInput[]
    createMany?: PaymentCreateManyGymInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<ExpenseCreateWithoutGymInput, ExpenseUncheckedCreateWithoutGymInput> | ExpenseCreateWithoutGymInput[] | ExpenseUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutGymInput | ExpenseCreateOrConnectWithoutGymInput[]
    createMany?: ExpenseCreateManyGymInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type CheckInUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<CheckInCreateWithoutGymInput, CheckInUncheckedCreateWithoutGymInput> | CheckInCreateWithoutGymInput[] | CheckInUncheckedCreateWithoutGymInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutGymInput | CheckInCreateOrConnectWithoutGymInput[]
    createMany?: CheckInCreateManyGymInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type GymStatsUncheckedCreateNestedOneWithoutGymInput = {
    create?: XOR<GymStatsCreateWithoutGymInput, GymStatsUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymStatsCreateOrConnectWithoutGymInput
    connect?: GymStatsWhereUniqueInput
  }

  export type GymSubscriptionUncheckedCreateNestedOneWithoutGymInput = {
    create?: XOR<GymSubscriptionCreateWithoutGymInput, GymSubscriptionUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutGymInput
    connect?: GymSubscriptionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutGymsNestedInput = {
    create?: XOR<UserCreateWithoutGymsInput, UserUncheckedCreateWithoutGymsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGymsInput
    upsert?: UserUpsertWithoutGymsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGymsInput, UserUpdateWithoutGymsInput>, UserUncheckedUpdateWithoutGymsInput>
  }

  export type GymProfileUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymProfileCreateWithoutGymInput, GymProfileUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymProfileCreateOrConnectWithoutGymInput
    upsert?: GymProfileUpsertWithoutGymInput
    disconnect?: GymProfileWhereInput | boolean
    delete?: GymProfileWhereInput | boolean
    connect?: GymProfileWhereUniqueInput
    update?: XOR<XOR<GymProfileUpdateToOneWithWhereWithoutGymInput, GymProfileUpdateWithoutGymInput>, GymProfileUncheckedUpdateWithoutGymInput>
  }

  export type GymMembershipUpdateManyWithoutGymNestedInput = {
    create?: XOR<GymMembershipCreateWithoutGymInput, GymMembershipUncheckedCreateWithoutGymInput> | GymMembershipCreateWithoutGymInput[] | GymMembershipUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutGymInput | GymMembershipCreateOrConnectWithoutGymInput[]
    upsert?: GymMembershipUpsertWithWhereUniqueWithoutGymInput | GymMembershipUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: GymMembershipCreateManyGymInputEnvelope
    set?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    disconnect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    delete?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    update?: GymMembershipUpdateWithWhereUniqueWithoutGymInput | GymMembershipUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: GymMembershipUpdateManyWithWhereWithoutGymInput | GymMembershipUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutGymNestedInput = {
    create?: XOR<EquipmentCreateWithoutGymInput, EquipmentUncheckedCreateWithoutGymInput> | EquipmentCreateWithoutGymInput[] | EquipmentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutGymInput | EquipmentCreateOrConnectWithoutGymInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutGymInput | EquipmentUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: EquipmentCreateManyGymInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutGymInput | EquipmentUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutGymInput | EquipmentUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type MembershipPlanUpdateManyWithoutGymNestedInput = {
    create?: XOR<MembershipPlanCreateWithoutGymInput, MembershipPlanUncheckedCreateWithoutGymInput> | MembershipPlanCreateWithoutGymInput[] | MembershipPlanUncheckedCreateWithoutGymInput[]
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutGymInput | MembershipPlanCreateOrConnectWithoutGymInput[]
    upsert?: MembershipPlanUpsertWithWhereUniqueWithoutGymInput | MembershipPlanUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: MembershipPlanCreateManyGymInputEnvelope
    set?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    disconnect?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    delete?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    connect?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    update?: MembershipPlanUpdateWithWhereUniqueWithoutGymInput | MembershipPlanUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: MembershipPlanUpdateManyWithWhereWithoutGymInput | MembershipPlanUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: MembershipPlanScalarWhereInput | MembershipPlanScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutGymNestedInput = {
    create?: XOR<PaymentCreateWithoutGymInput, PaymentUncheckedCreateWithoutGymInput> | PaymentCreateWithoutGymInput[] | PaymentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutGymInput | PaymentCreateOrConnectWithoutGymInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutGymInput | PaymentUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: PaymentCreateManyGymInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutGymInput | PaymentUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutGymInput | PaymentUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutGymNestedInput = {
    create?: XOR<ExpenseCreateWithoutGymInput, ExpenseUncheckedCreateWithoutGymInput> | ExpenseCreateWithoutGymInput[] | ExpenseUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutGymInput | ExpenseCreateOrConnectWithoutGymInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutGymInput | ExpenseUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: ExpenseCreateManyGymInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutGymInput | ExpenseUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutGymInput | ExpenseUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type CheckInUpdateManyWithoutGymNestedInput = {
    create?: XOR<CheckInCreateWithoutGymInput, CheckInUncheckedCreateWithoutGymInput> | CheckInCreateWithoutGymInput[] | CheckInUncheckedCreateWithoutGymInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutGymInput | CheckInCreateOrConnectWithoutGymInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutGymInput | CheckInUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: CheckInCreateManyGymInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutGymInput | CheckInUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutGymInput | CheckInUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type GymStatsUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymStatsCreateWithoutGymInput, GymStatsUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymStatsCreateOrConnectWithoutGymInput
    upsert?: GymStatsUpsertWithoutGymInput
    disconnect?: GymStatsWhereInput | boolean
    delete?: GymStatsWhereInput | boolean
    connect?: GymStatsWhereUniqueInput
    update?: XOR<XOR<GymStatsUpdateToOneWithWhereWithoutGymInput, GymStatsUpdateWithoutGymInput>, GymStatsUncheckedUpdateWithoutGymInput>
  }

  export type GymSubscriptionUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymSubscriptionCreateWithoutGymInput, GymSubscriptionUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutGymInput
    upsert?: GymSubscriptionUpsertWithoutGymInput
    disconnect?: GymSubscriptionWhereInput | boolean
    delete?: GymSubscriptionWhereInput | boolean
    connect?: GymSubscriptionWhereUniqueInput
    update?: XOR<XOR<GymSubscriptionUpdateToOneWithWhereWithoutGymInput, GymSubscriptionUpdateWithoutGymInput>, GymSubscriptionUncheckedUpdateWithoutGymInput>
  }

  export type GymProfileUncheckedUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymProfileCreateWithoutGymInput, GymProfileUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymProfileCreateOrConnectWithoutGymInput
    upsert?: GymProfileUpsertWithoutGymInput
    disconnect?: GymProfileWhereInput | boolean
    delete?: GymProfileWhereInput | boolean
    connect?: GymProfileWhereUniqueInput
    update?: XOR<XOR<GymProfileUpdateToOneWithWhereWithoutGymInput, GymProfileUpdateWithoutGymInput>, GymProfileUncheckedUpdateWithoutGymInput>
  }

  export type GymMembershipUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<GymMembershipCreateWithoutGymInput, GymMembershipUncheckedCreateWithoutGymInput> | GymMembershipCreateWithoutGymInput[] | GymMembershipUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutGymInput | GymMembershipCreateOrConnectWithoutGymInput[]
    upsert?: GymMembershipUpsertWithWhereUniqueWithoutGymInput | GymMembershipUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: GymMembershipCreateManyGymInputEnvelope
    set?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    disconnect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    delete?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    update?: GymMembershipUpdateWithWhereUniqueWithoutGymInput | GymMembershipUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: GymMembershipUpdateManyWithWhereWithoutGymInput | GymMembershipUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<EquipmentCreateWithoutGymInput, EquipmentUncheckedCreateWithoutGymInput> | EquipmentCreateWithoutGymInput[] | EquipmentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutGymInput | EquipmentCreateOrConnectWithoutGymInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutGymInput | EquipmentUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: EquipmentCreateManyGymInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutGymInput | EquipmentUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutGymInput | EquipmentUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type MembershipPlanUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<MembershipPlanCreateWithoutGymInput, MembershipPlanUncheckedCreateWithoutGymInput> | MembershipPlanCreateWithoutGymInput[] | MembershipPlanUncheckedCreateWithoutGymInput[]
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutGymInput | MembershipPlanCreateOrConnectWithoutGymInput[]
    upsert?: MembershipPlanUpsertWithWhereUniqueWithoutGymInput | MembershipPlanUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: MembershipPlanCreateManyGymInputEnvelope
    set?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    disconnect?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    delete?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    connect?: MembershipPlanWhereUniqueInput | MembershipPlanWhereUniqueInput[]
    update?: MembershipPlanUpdateWithWhereUniqueWithoutGymInput | MembershipPlanUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: MembershipPlanUpdateManyWithWhereWithoutGymInput | MembershipPlanUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: MembershipPlanScalarWhereInput | MembershipPlanScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<PaymentCreateWithoutGymInput, PaymentUncheckedCreateWithoutGymInput> | PaymentCreateWithoutGymInput[] | PaymentUncheckedCreateWithoutGymInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutGymInput | PaymentCreateOrConnectWithoutGymInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutGymInput | PaymentUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: PaymentCreateManyGymInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutGymInput | PaymentUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutGymInput | PaymentUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<ExpenseCreateWithoutGymInput, ExpenseUncheckedCreateWithoutGymInput> | ExpenseCreateWithoutGymInput[] | ExpenseUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutGymInput | ExpenseCreateOrConnectWithoutGymInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutGymInput | ExpenseUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: ExpenseCreateManyGymInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutGymInput | ExpenseUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutGymInput | ExpenseUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type CheckInUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<CheckInCreateWithoutGymInput, CheckInUncheckedCreateWithoutGymInput> | CheckInCreateWithoutGymInput[] | CheckInUncheckedCreateWithoutGymInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutGymInput | CheckInCreateOrConnectWithoutGymInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutGymInput | CheckInUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: CheckInCreateManyGymInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutGymInput | CheckInUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutGymInput | CheckInUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type GymStatsUncheckedUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymStatsCreateWithoutGymInput, GymStatsUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymStatsCreateOrConnectWithoutGymInput
    upsert?: GymStatsUpsertWithoutGymInput
    disconnect?: GymStatsWhereInput | boolean
    delete?: GymStatsWhereInput | boolean
    connect?: GymStatsWhereUniqueInput
    update?: XOR<XOR<GymStatsUpdateToOneWithWhereWithoutGymInput, GymStatsUpdateWithoutGymInput>, GymStatsUncheckedUpdateWithoutGymInput>
  }

  export type GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymSubscriptionCreateWithoutGymInput, GymSubscriptionUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutGymInput
    upsert?: GymSubscriptionUpsertWithoutGymInput
    disconnect?: GymSubscriptionWhereInput | boolean
    delete?: GymSubscriptionWhereInput | boolean
    connect?: GymSubscriptionWhereUniqueInput
    update?: XOR<XOR<GymSubscriptionUpdateToOneWithWhereWithoutGymInput, GymSubscriptionUpdateWithoutGymInput>, GymSubscriptionUncheckedUpdateWithoutGymInput>
  }

  export type GymCreateNestedOneWithoutProfileInput = {
    create?: XOR<GymCreateWithoutProfileInput, GymUncheckedCreateWithoutProfileInput>
    connectOrCreate?: GymCreateOrConnectWithoutProfileInput
    connect?: GymWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<GymCreateWithoutProfileInput, GymUncheckedCreateWithoutProfileInput>
    connectOrCreate?: GymCreateOrConnectWithoutProfileInput
    upsert?: GymUpsertWithoutProfileInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutProfileInput, GymUpdateWithoutProfileInput>, GymUncheckedUpdateWithoutProfileInput>
  }

  export type GymCreateNestedOneWithoutStatsInput = {
    create?: XOR<GymCreateWithoutStatsInput, GymUncheckedCreateWithoutStatsInput>
    connectOrCreate?: GymCreateOrConnectWithoutStatsInput
    connect?: GymWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<GymCreateWithoutStatsInput, GymUncheckedCreateWithoutStatsInput>
    connectOrCreate?: GymCreateOrConnectWithoutStatsInput
    upsert?: GymUpsertWithoutStatsInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutStatsInput, GymUpdateWithoutStatsInput>, GymUncheckedUpdateWithoutStatsInput>
  }

  export type StudentCreateNestedOneWithoutUnitsInput = {
    create?: XOR<StudentCreateWithoutUnitsInput, StudentUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUnitsInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkoutCreateNestedManyWithoutUnitInput = {
    create?: XOR<WorkoutCreateWithoutUnitInput, WorkoutUncheckedCreateWithoutUnitInput> | WorkoutCreateWithoutUnitInput[] | WorkoutUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUnitInput | WorkoutCreateOrConnectWithoutUnitInput[]
    createMany?: WorkoutCreateManyUnitInputEnvelope
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
  }

  export type WorkoutUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<WorkoutCreateWithoutUnitInput, WorkoutUncheckedCreateWithoutUnitInput> | WorkoutCreateWithoutUnitInput[] | WorkoutUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUnitInput | WorkoutCreateOrConnectWithoutUnitInput[]
    createMany?: WorkoutCreateManyUnitInputEnvelope
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
  }

  export type StudentUpdateOneWithoutUnitsNestedInput = {
    create?: XOR<StudentCreateWithoutUnitsInput, StudentUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUnitsInput
    upsert?: StudentUpsertWithoutUnitsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUnitsInput, StudentUpdateWithoutUnitsInput>, StudentUncheckedUpdateWithoutUnitsInput>
  }

  export type WorkoutUpdateManyWithoutUnitNestedInput = {
    create?: XOR<WorkoutCreateWithoutUnitInput, WorkoutUncheckedCreateWithoutUnitInput> | WorkoutCreateWithoutUnitInput[] | WorkoutUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUnitInput | WorkoutCreateOrConnectWithoutUnitInput[]
    upsert?: WorkoutUpsertWithWhereUniqueWithoutUnitInput | WorkoutUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: WorkoutCreateManyUnitInputEnvelope
    set?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    disconnect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    delete?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    update?: WorkoutUpdateWithWhereUniqueWithoutUnitInput | WorkoutUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: WorkoutUpdateManyWithWhereWithoutUnitInput | WorkoutUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
  }

  export type WorkoutUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<WorkoutCreateWithoutUnitInput, WorkoutUncheckedCreateWithoutUnitInput> | WorkoutCreateWithoutUnitInput[] | WorkoutUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutUnitInput | WorkoutCreateOrConnectWithoutUnitInput[]
    upsert?: WorkoutUpsertWithWhereUniqueWithoutUnitInput | WorkoutUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: WorkoutCreateManyUnitInputEnvelope
    set?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    disconnect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    delete?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    update?: WorkoutUpdateWithWhereUniqueWithoutUnitInput | WorkoutUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: WorkoutUpdateManyWithWhereWithoutUnitInput | WorkoutUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutWorkoutsInput = {
    create?: XOR<UnitCreateWithoutWorkoutsInput, UnitUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutWorkoutsInput
    connect?: UnitWhereUniqueInput
  }

  export type WorkoutExerciseCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
  }

  export type WorkoutHistoryCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutHistoryCreateWithoutWorkoutInput, WorkoutHistoryUncheckedCreateWithoutWorkoutInput> | WorkoutHistoryCreateWithoutWorkoutInput[] | WorkoutHistoryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutWorkoutInput | WorkoutHistoryCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutHistoryCreateManyWorkoutInputEnvelope
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
  }

  export type WorkoutProgressCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutProgressCreateWithoutWorkoutInput, WorkoutProgressUncheckedCreateWithoutWorkoutInput> | WorkoutProgressCreateWithoutWorkoutInput[] | WorkoutProgressUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutWorkoutInput | WorkoutProgressCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutProgressCreateManyWorkoutInputEnvelope
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
  }

  export type WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
  }

  export type WorkoutHistoryUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutHistoryCreateWithoutWorkoutInput, WorkoutHistoryUncheckedCreateWithoutWorkoutInput> | WorkoutHistoryCreateWithoutWorkoutInput[] | WorkoutHistoryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutWorkoutInput | WorkoutHistoryCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutHistoryCreateManyWorkoutInputEnvelope
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
  }

  export type WorkoutProgressUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutProgressCreateWithoutWorkoutInput, WorkoutProgressUncheckedCreateWithoutWorkoutInput> | WorkoutProgressCreateWithoutWorkoutInput[] | WorkoutProgressUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutWorkoutInput | WorkoutProgressCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutProgressCreateManyWorkoutInputEnvelope
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
  }

  export type UnitUpdateOneWithoutWorkoutsNestedInput = {
    create?: XOR<UnitCreateWithoutWorkoutsInput, UnitUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutWorkoutsInput
    upsert?: UnitUpsertWithoutWorkoutsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutWorkoutsInput, UnitUpdateWithoutWorkoutsInput>, UnitUncheckedUpdateWithoutWorkoutsInput>
  }

  export type WorkoutExerciseUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    set?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    disconnect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    delete?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    update?: WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput | WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
  }

  export type WorkoutHistoryUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutHistoryCreateWithoutWorkoutInput, WorkoutHistoryUncheckedCreateWithoutWorkoutInput> | WorkoutHistoryCreateWithoutWorkoutInput[] | WorkoutHistoryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutWorkoutInput | WorkoutHistoryCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutHistoryUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutHistoryUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutHistoryCreateManyWorkoutInputEnvelope
    set?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    disconnect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    delete?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    update?: WorkoutHistoryUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutHistoryUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutHistoryUpdateManyWithWhereWithoutWorkoutInput | WorkoutHistoryUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutHistoryScalarWhereInput | WorkoutHistoryScalarWhereInput[]
  }

  export type WorkoutProgressUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutProgressCreateWithoutWorkoutInput, WorkoutProgressUncheckedCreateWithoutWorkoutInput> | WorkoutProgressCreateWithoutWorkoutInput[] | WorkoutProgressUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutWorkoutInput | WorkoutProgressCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutProgressUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutProgressUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutProgressCreateManyWorkoutInputEnvelope
    set?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    disconnect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    delete?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    update?: WorkoutProgressUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutProgressUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutProgressUpdateManyWithWhereWithoutWorkoutInput | WorkoutProgressUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutProgressScalarWhereInput | WorkoutProgressScalarWhereInput[]
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    set?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    disconnect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    delete?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    update?: WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput | WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
  }

  export type WorkoutHistoryUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutHistoryCreateWithoutWorkoutInput, WorkoutHistoryUncheckedCreateWithoutWorkoutInput> | WorkoutHistoryCreateWithoutWorkoutInput[] | WorkoutHistoryUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutWorkoutInput | WorkoutHistoryCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutHistoryUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutHistoryUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutHistoryCreateManyWorkoutInputEnvelope
    set?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    disconnect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    delete?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    connect?: WorkoutHistoryWhereUniqueInput | WorkoutHistoryWhereUniqueInput[]
    update?: WorkoutHistoryUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutHistoryUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutHistoryUpdateManyWithWhereWithoutWorkoutInput | WorkoutHistoryUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutHistoryScalarWhereInput | WorkoutHistoryScalarWhereInput[]
  }

  export type WorkoutProgressUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutProgressCreateWithoutWorkoutInput, WorkoutProgressUncheckedCreateWithoutWorkoutInput> | WorkoutProgressCreateWithoutWorkoutInput[] | WorkoutProgressUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutProgressCreateOrConnectWithoutWorkoutInput | WorkoutProgressCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutProgressUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutProgressUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutProgressCreateManyWorkoutInputEnvelope
    set?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    disconnect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    delete?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    connect?: WorkoutProgressWhereUniqueInput | WorkoutProgressWhereUniqueInput[]
    update?: WorkoutProgressUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutProgressUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutProgressUpdateManyWithWhereWithoutWorkoutInput | WorkoutProgressUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutProgressScalarWhereInput | WorkoutProgressScalarWhereInput[]
  }

  export type WorkoutCreateNestedOneWithoutExercisesInput = {
    create?: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutExercisesInput
    connect?: WorkoutWhereUniqueInput
  }

  export type AlternativeExerciseCreateNestedManyWithoutWorkoutExerciseInput = {
    create?: XOR<AlternativeExerciseCreateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput> | AlternativeExerciseCreateWithoutWorkoutExerciseInput[] | AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput | AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput[]
    createMany?: AlternativeExerciseCreateManyWorkoutExerciseInputEnvelope
    connect?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
  }

  export type AlternativeExerciseUncheckedCreateNestedManyWithoutWorkoutExerciseInput = {
    create?: XOR<AlternativeExerciseCreateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput> | AlternativeExerciseCreateWithoutWorkoutExerciseInput[] | AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput | AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput[]
    createMany?: AlternativeExerciseCreateManyWorkoutExerciseInputEnvelope
    connect?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
  }

  export type WorkoutUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutExercisesInput
    upsert?: WorkoutUpsertWithoutExercisesInput
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutExercisesInput, WorkoutUpdateWithoutExercisesInput>, WorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type AlternativeExerciseUpdateManyWithoutWorkoutExerciseNestedInput = {
    create?: XOR<AlternativeExerciseCreateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput> | AlternativeExerciseCreateWithoutWorkoutExerciseInput[] | AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput | AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput[]
    upsert?: AlternativeExerciseUpsertWithWhereUniqueWithoutWorkoutExerciseInput | AlternativeExerciseUpsertWithWhereUniqueWithoutWorkoutExerciseInput[]
    createMany?: AlternativeExerciseCreateManyWorkoutExerciseInputEnvelope
    set?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    disconnect?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    delete?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    connect?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    update?: AlternativeExerciseUpdateWithWhereUniqueWithoutWorkoutExerciseInput | AlternativeExerciseUpdateWithWhereUniqueWithoutWorkoutExerciseInput[]
    updateMany?: AlternativeExerciseUpdateManyWithWhereWithoutWorkoutExerciseInput | AlternativeExerciseUpdateManyWithWhereWithoutWorkoutExerciseInput[]
    deleteMany?: AlternativeExerciseScalarWhereInput | AlternativeExerciseScalarWhereInput[]
  }

  export type AlternativeExerciseUncheckedUpdateManyWithoutWorkoutExerciseNestedInput = {
    create?: XOR<AlternativeExerciseCreateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput> | AlternativeExerciseCreateWithoutWorkoutExerciseInput[] | AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput | AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput[]
    upsert?: AlternativeExerciseUpsertWithWhereUniqueWithoutWorkoutExerciseInput | AlternativeExerciseUpsertWithWhereUniqueWithoutWorkoutExerciseInput[]
    createMany?: AlternativeExerciseCreateManyWorkoutExerciseInputEnvelope
    set?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    disconnect?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    delete?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    connect?: AlternativeExerciseWhereUniqueInput | AlternativeExerciseWhereUniqueInput[]
    update?: AlternativeExerciseUpdateWithWhereUniqueWithoutWorkoutExerciseInput | AlternativeExerciseUpdateWithWhereUniqueWithoutWorkoutExerciseInput[]
    updateMany?: AlternativeExerciseUpdateManyWithWhereWithoutWorkoutExerciseInput | AlternativeExerciseUpdateManyWithWhereWithoutWorkoutExerciseInput[]
    deleteMany?: AlternativeExerciseScalarWhereInput | AlternativeExerciseScalarWhereInput[]
  }

  export type WorkoutExerciseCreateNestedOneWithoutAlternativesInput = {
    create?: XOR<WorkoutExerciseCreateWithoutAlternativesInput, WorkoutExerciseUncheckedCreateWithoutAlternativesInput>
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutAlternativesInput
    connect?: WorkoutExerciseWhereUniqueInput
  }

  export type WorkoutExerciseUpdateOneRequiredWithoutAlternativesNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutAlternativesInput, WorkoutExerciseUncheckedCreateWithoutAlternativesInput>
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutAlternativesInput
    upsert?: WorkoutExerciseUpsertWithoutAlternativesInput
    connect?: WorkoutExerciseWhereUniqueInput
    update?: XOR<XOR<WorkoutExerciseUpdateToOneWithWhereWithoutAlternativesInput, WorkoutExerciseUpdateWithoutAlternativesInput>, WorkoutExerciseUncheckedUpdateWithoutAlternativesInput>
  }

  export type StudentCreateNestedOneWithoutWorkoutProgressInput = {
    create?: XOR<StudentCreateWithoutWorkoutProgressInput, StudentUncheckedCreateWithoutWorkoutProgressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutWorkoutProgressInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkoutCreateNestedOneWithoutProgressInput = {
    create?: XOR<WorkoutCreateWithoutProgressInput, WorkoutUncheckedCreateWithoutProgressInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutProgressInput
    connect?: WorkoutWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutWorkoutProgressNestedInput = {
    create?: XOR<StudentCreateWithoutWorkoutProgressInput, StudentUncheckedCreateWithoutWorkoutProgressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutWorkoutProgressInput
    upsert?: StudentUpsertWithoutWorkoutProgressInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutWorkoutProgressInput, StudentUpdateWithoutWorkoutProgressInput>, StudentUncheckedUpdateWithoutWorkoutProgressInput>
  }

  export type WorkoutUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<WorkoutCreateWithoutProgressInput, WorkoutUncheckedCreateWithoutProgressInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutProgressInput
    upsert?: WorkoutUpsertWithoutProgressInput
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutProgressInput, WorkoutUpdateWithoutProgressInput>, WorkoutUncheckedUpdateWithoutProgressInput>
  }

  export type StudentCreateNestedOneWithoutWorkoutsInput = {
    create?: XOR<StudentCreateWithoutWorkoutsInput, StudentUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutWorkoutsInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkoutCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<WorkoutCreateWithoutCompletionsInput, WorkoutUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutCompletionsInput
    connect?: WorkoutWhereUniqueInput
  }

  export type ExerciseLogCreateNestedManyWithoutWorkoutHistoryInput = {
    create?: XOR<ExerciseLogCreateWithoutWorkoutHistoryInput, ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput> | ExerciseLogCreateWithoutWorkoutHistoryInput[] | ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput | ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput[]
    createMany?: ExerciseLogCreateManyWorkoutHistoryInputEnvelope
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
  }

  export type PersonalRecordCreateNestedManyWithoutWorkoutHistoryInput = {
    create?: XOR<PersonalRecordCreateWithoutWorkoutHistoryInput, PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput> | PersonalRecordCreateWithoutWorkoutHistoryInput[] | PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput | PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput[]
    createMany?: PersonalRecordCreateManyWorkoutHistoryInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type ExerciseLogUncheckedCreateNestedManyWithoutWorkoutHistoryInput = {
    create?: XOR<ExerciseLogCreateWithoutWorkoutHistoryInput, ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput> | ExerciseLogCreateWithoutWorkoutHistoryInput[] | ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput | ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput[]
    createMany?: ExerciseLogCreateManyWorkoutHistoryInputEnvelope
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
  }

  export type PersonalRecordUncheckedCreateNestedManyWithoutWorkoutHistoryInput = {
    create?: XOR<PersonalRecordCreateWithoutWorkoutHistoryInput, PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput> | PersonalRecordCreateWithoutWorkoutHistoryInput[] | PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput | PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput[]
    createMany?: PersonalRecordCreateManyWorkoutHistoryInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutWorkoutsNestedInput = {
    create?: XOR<StudentCreateWithoutWorkoutsInput, StudentUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutWorkoutsInput
    upsert?: StudentUpsertWithoutWorkoutsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutWorkoutsInput, StudentUpdateWithoutWorkoutsInput>, StudentUncheckedUpdateWithoutWorkoutsInput>
  }

  export type WorkoutUpdateOneWithoutCompletionsNestedInput = {
    create?: XOR<WorkoutCreateWithoutCompletionsInput, WorkoutUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutCompletionsInput
    upsert?: WorkoutUpsertWithoutCompletionsInput
    disconnect?: WorkoutWhereInput | boolean
    delete?: WorkoutWhereInput | boolean
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutCompletionsInput, WorkoutUpdateWithoutCompletionsInput>, WorkoutUncheckedUpdateWithoutCompletionsInput>
  }

  export type ExerciseLogUpdateManyWithoutWorkoutHistoryNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutWorkoutHistoryInput, ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput> | ExerciseLogCreateWithoutWorkoutHistoryInput[] | ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput | ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput[]
    upsert?: ExerciseLogUpsertWithWhereUniqueWithoutWorkoutHistoryInput | ExerciseLogUpsertWithWhereUniqueWithoutWorkoutHistoryInput[]
    createMany?: ExerciseLogCreateManyWorkoutHistoryInputEnvelope
    set?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    disconnect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    delete?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    update?: ExerciseLogUpdateWithWhereUniqueWithoutWorkoutHistoryInput | ExerciseLogUpdateWithWhereUniqueWithoutWorkoutHistoryInput[]
    updateMany?: ExerciseLogUpdateManyWithWhereWithoutWorkoutHistoryInput | ExerciseLogUpdateManyWithWhereWithoutWorkoutHistoryInput[]
    deleteMany?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
  }

  export type PersonalRecordUpdateManyWithoutWorkoutHistoryNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutWorkoutHistoryInput, PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput> | PersonalRecordCreateWithoutWorkoutHistoryInput[] | PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput | PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutWorkoutHistoryInput | PersonalRecordUpsertWithWhereUniqueWithoutWorkoutHistoryInput[]
    createMany?: PersonalRecordCreateManyWorkoutHistoryInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutWorkoutHistoryInput | PersonalRecordUpdateWithWhereUniqueWithoutWorkoutHistoryInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutWorkoutHistoryInput | PersonalRecordUpdateManyWithWhereWithoutWorkoutHistoryInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutWorkoutHistoryInput, ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput> | ExerciseLogCreateWithoutWorkoutHistoryInput[] | ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput | ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput[]
    upsert?: ExerciseLogUpsertWithWhereUniqueWithoutWorkoutHistoryInput | ExerciseLogUpsertWithWhereUniqueWithoutWorkoutHistoryInput[]
    createMany?: ExerciseLogCreateManyWorkoutHistoryInputEnvelope
    set?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    disconnect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    delete?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    connect?: ExerciseLogWhereUniqueInput | ExerciseLogWhereUniqueInput[]
    update?: ExerciseLogUpdateWithWhereUniqueWithoutWorkoutHistoryInput | ExerciseLogUpdateWithWhereUniqueWithoutWorkoutHistoryInput[]
    updateMany?: ExerciseLogUpdateManyWithWhereWithoutWorkoutHistoryInput | ExerciseLogUpdateManyWithWhereWithoutWorkoutHistoryInput[]
    deleteMany?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
  }

  export type PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutWorkoutHistoryInput, PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput> | PersonalRecordCreateWithoutWorkoutHistoryInput[] | PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput | PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutWorkoutHistoryInput | PersonalRecordUpsertWithWhereUniqueWithoutWorkoutHistoryInput[]
    createMany?: PersonalRecordCreateManyWorkoutHistoryInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutWorkoutHistoryInput | PersonalRecordUpdateWithWhereUniqueWithoutWorkoutHistoryInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutWorkoutHistoryInput | PersonalRecordUpdateManyWithWhereWithoutWorkoutHistoryInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type WorkoutHistoryCreateNestedOneWithoutExercisesInput = {
    create?: XOR<WorkoutHistoryCreateWithoutExercisesInput, WorkoutHistoryUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutExercisesInput
    connect?: WorkoutHistoryWhereUniqueInput
  }

  export type WorkoutHistoryUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<WorkoutHistoryCreateWithoutExercisesInput, WorkoutHistoryUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutExercisesInput
    upsert?: WorkoutHistoryUpsertWithoutExercisesInput
    connect?: WorkoutHistoryWhereUniqueInput
    update?: XOR<XOR<WorkoutHistoryUpdateToOneWithWhereWithoutExercisesInput, WorkoutHistoryUpdateWithoutExercisesInput>, WorkoutHistoryUncheckedUpdateWithoutExercisesInput>
  }

  export type StudentCreateNestedOneWithoutRecordsInput = {
    create?: XOR<StudentCreateWithoutRecordsInput, StudentUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkoutHistoryCreateNestedOneWithoutRecordsInput = {
    create?: XOR<WorkoutHistoryCreateWithoutRecordsInput, WorkoutHistoryUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutRecordsInput
    connect?: WorkoutHistoryWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutRecordsInput, StudentUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRecordsInput
    upsert?: StudentUpsertWithoutRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutRecordsInput, StudentUpdateWithoutRecordsInput>, StudentUncheckedUpdateWithoutRecordsInput>
  }

  export type WorkoutHistoryUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<WorkoutHistoryCreateWithoutRecordsInput, WorkoutHistoryUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: WorkoutHistoryCreateOrConnectWithoutRecordsInput
    upsert?: WorkoutHistoryUpsertWithoutRecordsInput
    disconnect?: WorkoutHistoryWhereInput | boolean
    delete?: WorkoutHistoryWhereInput | boolean
    connect?: WorkoutHistoryWhereUniqueInput
    update?: XOR<XOR<WorkoutHistoryUpdateToOneWithWhereWithoutRecordsInput, WorkoutHistoryUpdateWithoutRecordsInput>, WorkoutHistoryUncheckedUpdateWithoutRecordsInput>
  }

  export type MealCreateNestedManyWithoutDietPlanInput = {
    create?: XOR<MealCreateWithoutDietPlanInput, MealUncheckedCreateWithoutDietPlanInput> | MealCreateWithoutDietPlanInput[] | MealUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: MealCreateOrConnectWithoutDietPlanInput | MealCreateOrConnectWithoutDietPlanInput[]
    createMany?: MealCreateManyDietPlanInputEnvelope
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
  }

  export type DietPlanCompletionCreateNestedManyWithoutDietPlanInput = {
    create?: XOR<DietPlanCompletionCreateWithoutDietPlanInput, DietPlanCompletionUncheckedCreateWithoutDietPlanInput> | DietPlanCompletionCreateWithoutDietPlanInput[] | DietPlanCompletionUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutDietPlanInput | DietPlanCompletionCreateOrConnectWithoutDietPlanInput[]
    createMany?: DietPlanCompletionCreateManyDietPlanInputEnvelope
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
  }

  export type MealUncheckedCreateNestedManyWithoutDietPlanInput = {
    create?: XOR<MealCreateWithoutDietPlanInput, MealUncheckedCreateWithoutDietPlanInput> | MealCreateWithoutDietPlanInput[] | MealUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: MealCreateOrConnectWithoutDietPlanInput | MealCreateOrConnectWithoutDietPlanInput[]
    createMany?: MealCreateManyDietPlanInputEnvelope
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
  }

  export type DietPlanCompletionUncheckedCreateNestedManyWithoutDietPlanInput = {
    create?: XOR<DietPlanCompletionCreateWithoutDietPlanInput, DietPlanCompletionUncheckedCreateWithoutDietPlanInput> | DietPlanCompletionCreateWithoutDietPlanInput[] | DietPlanCompletionUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutDietPlanInput | DietPlanCompletionCreateOrConnectWithoutDietPlanInput[]
    createMany?: DietPlanCompletionCreateManyDietPlanInputEnvelope
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
  }

  export type MealUpdateManyWithoutDietPlanNestedInput = {
    create?: XOR<MealCreateWithoutDietPlanInput, MealUncheckedCreateWithoutDietPlanInput> | MealCreateWithoutDietPlanInput[] | MealUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: MealCreateOrConnectWithoutDietPlanInput | MealCreateOrConnectWithoutDietPlanInput[]
    upsert?: MealUpsertWithWhereUniqueWithoutDietPlanInput | MealUpsertWithWhereUniqueWithoutDietPlanInput[]
    createMany?: MealCreateManyDietPlanInputEnvelope
    set?: MealWhereUniqueInput | MealWhereUniqueInput[]
    disconnect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    delete?: MealWhereUniqueInput | MealWhereUniqueInput[]
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    update?: MealUpdateWithWhereUniqueWithoutDietPlanInput | MealUpdateWithWhereUniqueWithoutDietPlanInput[]
    updateMany?: MealUpdateManyWithWhereWithoutDietPlanInput | MealUpdateManyWithWhereWithoutDietPlanInput[]
    deleteMany?: MealScalarWhereInput | MealScalarWhereInput[]
  }

  export type DietPlanCompletionUpdateManyWithoutDietPlanNestedInput = {
    create?: XOR<DietPlanCompletionCreateWithoutDietPlanInput, DietPlanCompletionUncheckedCreateWithoutDietPlanInput> | DietPlanCompletionCreateWithoutDietPlanInput[] | DietPlanCompletionUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutDietPlanInput | DietPlanCompletionCreateOrConnectWithoutDietPlanInput[]
    upsert?: DietPlanCompletionUpsertWithWhereUniqueWithoutDietPlanInput | DietPlanCompletionUpsertWithWhereUniqueWithoutDietPlanInput[]
    createMany?: DietPlanCompletionCreateManyDietPlanInputEnvelope
    set?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    disconnect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    delete?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    update?: DietPlanCompletionUpdateWithWhereUniqueWithoutDietPlanInput | DietPlanCompletionUpdateWithWhereUniqueWithoutDietPlanInput[]
    updateMany?: DietPlanCompletionUpdateManyWithWhereWithoutDietPlanInput | DietPlanCompletionUpdateManyWithWhereWithoutDietPlanInput[]
    deleteMany?: DietPlanCompletionScalarWhereInput | DietPlanCompletionScalarWhereInput[]
  }

  export type MealUncheckedUpdateManyWithoutDietPlanNestedInput = {
    create?: XOR<MealCreateWithoutDietPlanInput, MealUncheckedCreateWithoutDietPlanInput> | MealCreateWithoutDietPlanInput[] | MealUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: MealCreateOrConnectWithoutDietPlanInput | MealCreateOrConnectWithoutDietPlanInput[]
    upsert?: MealUpsertWithWhereUniqueWithoutDietPlanInput | MealUpsertWithWhereUniqueWithoutDietPlanInput[]
    createMany?: MealCreateManyDietPlanInputEnvelope
    set?: MealWhereUniqueInput | MealWhereUniqueInput[]
    disconnect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    delete?: MealWhereUniqueInput | MealWhereUniqueInput[]
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    update?: MealUpdateWithWhereUniqueWithoutDietPlanInput | MealUpdateWithWhereUniqueWithoutDietPlanInput[]
    updateMany?: MealUpdateManyWithWhereWithoutDietPlanInput | MealUpdateManyWithWhereWithoutDietPlanInput[]
    deleteMany?: MealScalarWhereInput | MealScalarWhereInput[]
  }

  export type DietPlanCompletionUncheckedUpdateManyWithoutDietPlanNestedInput = {
    create?: XOR<DietPlanCompletionCreateWithoutDietPlanInput, DietPlanCompletionUncheckedCreateWithoutDietPlanInput> | DietPlanCompletionCreateWithoutDietPlanInput[] | DietPlanCompletionUncheckedCreateWithoutDietPlanInput[]
    connectOrCreate?: DietPlanCompletionCreateOrConnectWithoutDietPlanInput | DietPlanCompletionCreateOrConnectWithoutDietPlanInput[]
    upsert?: DietPlanCompletionUpsertWithWhereUniqueWithoutDietPlanInput | DietPlanCompletionUpsertWithWhereUniqueWithoutDietPlanInput[]
    createMany?: DietPlanCompletionCreateManyDietPlanInputEnvelope
    set?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    disconnect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    delete?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    connect?: DietPlanCompletionWhereUniqueInput | DietPlanCompletionWhereUniqueInput[]
    update?: DietPlanCompletionUpdateWithWhereUniqueWithoutDietPlanInput | DietPlanCompletionUpdateWithWhereUniqueWithoutDietPlanInput[]
    updateMany?: DietPlanCompletionUpdateManyWithWhereWithoutDietPlanInput | DietPlanCompletionUpdateManyWithWhereWithoutDietPlanInput[]
    deleteMany?: DietPlanCompletionScalarWhereInput | DietPlanCompletionScalarWhereInput[]
  }

  export type DietPlanCreateNestedOneWithoutMealsInput = {
    create?: XOR<DietPlanCreateWithoutMealsInput, DietPlanUncheckedCreateWithoutMealsInput>
    connectOrCreate?: DietPlanCreateOrConnectWithoutMealsInput
    connect?: DietPlanWhereUniqueInput
  }

  export type DietPlanUpdateOneRequiredWithoutMealsNestedInput = {
    create?: XOR<DietPlanCreateWithoutMealsInput, DietPlanUncheckedCreateWithoutMealsInput>
    connectOrCreate?: DietPlanCreateOrConnectWithoutMealsInput
    upsert?: DietPlanUpsertWithoutMealsInput
    connect?: DietPlanWhereUniqueInput
    update?: XOR<XOR<DietPlanUpdateToOneWithWhereWithoutMealsInput, DietPlanUpdateWithoutMealsInput>, DietPlanUncheckedUpdateWithoutMealsInput>
  }

  export type StudentCreateNestedOneWithoutDietsInput = {
    create?: XOR<StudentCreateWithoutDietsInput, StudentUncheckedCreateWithoutDietsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDietsInput
    connect?: StudentWhereUniqueInput
  }

  export type DietPlanCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<DietPlanCreateWithoutCompletionsInput, DietPlanUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: DietPlanCreateOrConnectWithoutCompletionsInput
    connect?: DietPlanWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutDietsNestedInput = {
    create?: XOR<StudentCreateWithoutDietsInput, StudentUncheckedCreateWithoutDietsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDietsInput
    upsert?: StudentUpsertWithoutDietsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutDietsInput, StudentUpdateWithoutDietsInput>, StudentUncheckedUpdateWithoutDietsInput>
  }

  export type DietPlanUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<DietPlanCreateWithoutCompletionsInput, DietPlanUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: DietPlanCreateOrConnectWithoutCompletionsInput
    upsert?: DietPlanUpsertWithoutCompletionsInput
    connect?: DietPlanWhereUniqueInput
    update?: XOR<XOR<DietPlanUpdateToOneWithWhereWithoutCompletionsInput, DietPlanUpdateWithoutCompletionsInput>, DietPlanUncheckedUpdateWithoutCompletionsInput>
  }

  export type StudentCreateNestedOneWithoutDailyNutritionInput = {
    create?: XOR<StudentCreateWithoutDailyNutritionInput, StudentUncheckedCreateWithoutDailyNutritionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDailyNutritionInput
    connect?: StudentWhereUniqueInput
  }

  export type NutritionMealCreateNestedManyWithoutDailyNutritionInput = {
    create?: XOR<NutritionMealCreateWithoutDailyNutritionInput, NutritionMealUncheckedCreateWithoutDailyNutritionInput> | NutritionMealCreateWithoutDailyNutritionInput[] | NutritionMealUncheckedCreateWithoutDailyNutritionInput[]
    connectOrCreate?: NutritionMealCreateOrConnectWithoutDailyNutritionInput | NutritionMealCreateOrConnectWithoutDailyNutritionInput[]
    createMany?: NutritionMealCreateManyDailyNutritionInputEnvelope
    connect?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
  }

  export type NutritionMealUncheckedCreateNestedManyWithoutDailyNutritionInput = {
    create?: XOR<NutritionMealCreateWithoutDailyNutritionInput, NutritionMealUncheckedCreateWithoutDailyNutritionInput> | NutritionMealCreateWithoutDailyNutritionInput[] | NutritionMealUncheckedCreateWithoutDailyNutritionInput[]
    connectOrCreate?: NutritionMealCreateOrConnectWithoutDailyNutritionInput | NutritionMealCreateOrConnectWithoutDailyNutritionInput[]
    createMany?: NutritionMealCreateManyDailyNutritionInputEnvelope
    connect?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutDailyNutritionNestedInput = {
    create?: XOR<StudentCreateWithoutDailyNutritionInput, StudentUncheckedCreateWithoutDailyNutritionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDailyNutritionInput
    upsert?: StudentUpsertWithoutDailyNutritionInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutDailyNutritionInput, StudentUpdateWithoutDailyNutritionInput>, StudentUncheckedUpdateWithoutDailyNutritionInput>
  }

  export type NutritionMealUpdateManyWithoutDailyNutritionNestedInput = {
    create?: XOR<NutritionMealCreateWithoutDailyNutritionInput, NutritionMealUncheckedCreateWithoutDailyNutritionInput> | NutritionMealCreateWithoutDailyNutritionInput[] | NutritionMealUncheckedCreateWithoutDailyNutritionInput[]
    connectOrCreate?: NutritionMealCreateOrConnectWithoutDailyNutritionInput | NutritionMealCreateOrConnectWithoutDailyNutritionInput[]
    upsert?: NutritionMealUpsertWithWhereUniqueWithoutDailyNutritionInput | NutritionMealUpsertWithWhereUniqueWithoutDailyNutritionInput[]
    createMany?: NutritionMealCreateManyDailyNutritionInputEnvelope
    set?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    disconnect?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    delete?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    connect?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    update?: NutritionMealUpdateWithWhereUniqueWithoutDailyNutritionInput | NutritionMealUpdateWithWhereUniqueWithoutDailyNutritionInput[]
    updateMany?: NutritionMealUpdateManyWithWhereWithoutDailyNutritionInput | NutritionMealUpdateManyWithWhereWithoutDailyNutritionInput[]
    deleteMany?: NutritionMealScalarWhereInput | NutritionMealScalarWhereInput[]
  }

  export type NutritionMealUncheckedUpdateManyWithoutDailyNutritionNestedInput = {
    create?: XOR<NutritionMealCreateWithoutDailyNutritionInput, NutritionMealUncheckedCreateWithoutDailyNutritionInput> | NutritionMealCreateWithoutDailyNutritionInput[] | NutritionMealUncheckedCreateWithoutDailyNutritionInput[]
    connectOrCreate?: NutritionMealCreateOrConnectWithoutDailyNutritionInput | NutritionMealCreateOrConnectWithoutDailyNutritionInput[]
    upsert?: NutritionMealUpsertWithWhereUniqueWithoutDailyNutritionInput | NutritionMealUpsertWithWhereUniqueWithoutDailyNutritionInput[]
    createMany?: NutritionMealCreateManyDailyNutritionInputEnvelope
    set?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    disconnect?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    delete?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    connect?: NutritionMealWhereUniqueInput | NutritionMealWhereUniqueInput[]
    update?: NutritionMealUpdateWithWhereUniqueWithoutDailyNutritionInput | NutritionMealUpdateWithWhereUniqueWithoutDailyNutritionInput[]
    updateMany?: NutritionMealUpdateManyWithWhereWithoutDailyNutritionInput | NutritionMealUpdateManyWithWhereWithoutDailyNutritionInput[]
    deleteMany?: NutritionMealScalarWhereInput | NutritionMealScalarWhereInput[]
  }

  export type DailyNutritionCreateNestedOneWithoutMealsInput = {
    create?: XOR<DailyNutritionCreateWithoutMealsInput, DailyNutritionUncheckedCreateWithoutMealsInput>
    connectOrCreate?: DailyNutritionCreateOrConnectWithoutMealsInput
    connect?: DailyNutritionWhereUniqueInput
  }

  export type NutritionFoodItemCreateNestedManyWithoutNutritionMealInput = {
    create?: XOR<NutritionFoodItemCreateWithoutNutritionMealInput, NutritionFoodItemUncheckedCreateWithoutNutritionMealInput> | NutritionFoodItemCreateWithoutNutritionMealInput[] | NutritionFoodItemUncheckedCreateWithoutNutritionMealInput[]
    connectOrCreate?: NutritionFoodItemCreateOrConnectWithoutNutritionMealInput | NutritionFoodItemCreateOrConnectWithoutNutritionMealInput[]
    createMany?: NutritionFoodItemCreateManyNutritionMealInputEnvelope
    connect?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
  }

  export type NutritionFoodItemUncheckedCreateNestedManyWithoutNutritionMealInput = {
    create?: XOR<NutritionFoodItemCreateWithoutNutritionMealInput, NutritionFoodItemUncheckedCreateWithoutNutritionMealInput> | NutritionFoodItemCreateWithoutNutritionMealInput[] | NutritionFoodItemUncheckedCreateWithoutNutritionMealInput[]
    connectOrCreate?: NutritionFoodItemCreateOrConnectWithoutNutritionMealInput | NutritionFoodItemCreateOrConnectWithoutNutritionMealInput[]
    createMany?: NutritionFoodItemCreateManyNutritionMealInputEnvelope
    connect?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
  }

  export type DailyNutritionUpdateOneRequiredWithoutMealsNestedInput = {
    create?: XOR<DailyNutritionCreateWithoutMealsInput, DailyNutritionUncheckedCreateWithoutMealsInput>
    connectOrCreate?: DailyNutritionCreateOrConnectWithoutMealsInput
    upsert?: DailyNutritionUpsertWithoutMealsInput
    connect?: DailyNutritionWhereUniqueInput
    update?: XOR<XOR<DailyNutritionUpdateToOneWithWhereWithoutMealsInput, DailyNutritionUpdateWithoutMealsInput>, DailyNutritionUncheckedUpdateWithoutMealsInput>
  }

  export type NutritionFoodItemUpdateManyWithoutNutritionMealNestedInput = {
    create?: XOR<NutritionFoodItemCreateWithoutNutritionMealInput, NutritionFoodItemUncheckedCreateWithoutNutritionMealInput> | NutritionFoodItemCreateWithoutNutritionMealInput[] | NutritionFoodItemUncheckedCreateWithoutNutritionMealInput[]
    connectOrCreate?: NutritionFoodItemCreateOrConnectWithoutNutritionMealInput | NutritionFoodItemCreateOrConnectWithoutNutritionMealInput[]
    upsert?: NutritionFoodItemUpsertWithWhereUniqueWithoutNutritionMealInput | NutritionFoodItemUpsertWithWhereUniqueWithoutNutritionMealInput[]
    createMany?: NutritionFoodItemCreateManyNutritionMealInputEnvelope
    set?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    disconnect?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    delete?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    connect?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    update?: NutritionFoodItemUpdateWithWhereUniqueWithoutNutritionMealInput | NutritionFoodItemUpdateWithWhereUniqueWithoutNutritionMealInput[]
    updateMany?: NutritionFoodItemUpdateManyWithWhereWithoutNutritionMealInput | NutritionFoodItemUpdateManyWithWhereWithoutNutritionMealInput[]
    deleteMany?: NutritionFoodItemScalarWhereInput | NutritionFoodItemScalarWhereInput[]
  }

  export type NutritionFoodItemUncheckedUpdateManyWithoutNutritionMealNestedInput = {
    create?: XOR<NutritionFoodItemCreateWithoutNutritionMealInput, NutritionFoodItemUncheckedCreateWithoutNutritionMealInput> | NutritionFoodItemCreateWithoutNutritionMealInput[] | NutritionFoodItemUncheckedCreateWithoutNutritionMealInput[]
    connectOrCreate?: NutritionFoodItemCreateOrConnectWithoutNutritionMealInput | NutritionFoodItemCreateOrConnectWithoutNutritionMealInput[]
    upsert?: NutritionFoodItemUpsertWithWhereUniqueWithoutNutritionMealInput | NutritionFoodItemUpsertWithWhereUniqueWithoutNutritionMealInput[]
    createMany?: NutritionFoodItemCreateManyNutritionMealInputEnvelope
    set?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    disconnect?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    delete?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    connect?: NutritionFoodItemWhereUniqueInput | NutritionFoodItemWhereUniqueInput[]
    update?: NutritionFoodItemUpdateWithWhereUniqueWithoutNutritionMealInput | NutritionFoodItemUpdateWithWhereUniqueWithoutNutritionMealInput[]
    updateMany?: NutritionFoodItemUpdateManyWithWhereWithoutNutritionMealInput | NutritionFoodItemUpdateManyWithWhereWithoutNutritionMealInput[]
    deleteMany?: NutritionFoodItemScalarWhereInput | NutritionFoodItemScalarWhereInput[]
  }

  export type NutritionMealCreateNestedOneWithoutFoodsInput = {
    create?: XOR<NutritionMealCreateWithoutFoodsInput, NutritionMealUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: NutritionMealCreateOrConnectWithoutFoodsInput
    connect?: NutritionMealWhereUniqueInput
  }

  export type NutritionMealUpdateOneRequiredWithoutFoodsNestedInput = {
    create?: XOR<NutritionMealCreateWithoutFoodsInput, NutritionMealUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: NutritionMealCreateOrConnectWithoutFoodsInput
    upsert?: NutritionMealUpsertWithoutFoodsInput
    connect?: NutritionMealWhereUniqueInput
    update?: XOR<XOR<NutritionMealUpdateToOneWithWhereWithoutFoodsInput, NutritionMealUpdateWithoutFoodsInput>, NutritionMealUncheckedUpdateWithoutFoodsInput>
  }

  export type StudentCreateNestedOneWithoutNutritionChatUsageInput = {
    create?: XOR<StudentCreateWithoutNutritionChatUsageInput, StudentUncheckedCreateWithoutNutritionChatUsageInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNutritionChatUsageInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutNutritionChatUsageNestedInput = {
    create?: XOR<StudentCreateWithoutNutritionChatUsageInput, StudentUncheckedCreateWithoutNutritionChatUsageInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNutritionChatUsageInput
    upsert?: StudentUpsertWithoutNutritionChatUsageInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutNutritionChatUsageInput, StudentUpdateWithoutNutritionChatUsageInput>, StudentUncheckedUpdateWithoutNutritionChatUsageInput>
  }

  export type AchievementUnlockCreateNestedManyWithoutAchievementInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type AchievementUnlockUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
  }

  export type AchievementUnlockUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutAchievementInput | AchievementUnlockUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput> | AchievementUnlockCreateWithoutAchievementInput[] | AchievementUnlockUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: AchievementUnlockCreateOrConnectWithoutAchievementInput | AchievementUnlockCreateOrConnectWithoutAchievementInput[]
    upsert?: AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: AchievementUnlockCreateManyAchievementInputEnvelope
    set?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    disconnect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    delete?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    connect?: AchievementUnlockWhereUniqueInput | AchievementUnlockWhereUniqueInput[]
    update?: AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput | AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: AchievementUnlockUpdateManyWithWhereWithoutAchievementInput | AchievementUnlockUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAchievementsInput
    connect?: StudentWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUnlocksInput = {
    create?: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUnlocksInput
    connect?: AchievementWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAchievementsInput
    upsert?: StudentUpsertWithoutAchievementsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAchievementsInput, StudentUpdateWithoutAchievementsInput>, StudentUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUnlocksNestedInput = {
    create?: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUnlocksInput
    upsert?: AchievementUpsertWithoutUnlocksInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUnlocksInput, AchievementUpdateWithoutUnlocksInput>, AchievementUncheckedUpdateWithoutUnlocksInput>
  }

  export type UserCreateNestedOneWithoutGymPreferenceInput = {
    create?: XOR<UserCreateWithoutGymPreferenceInput, UserUncheckedCreateWithoutGymPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutGymPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGymPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutGymPreferenceInput, UserUncheckedCreateWithoutGymPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutGymPreferenceInput
    upsert?: UserUpsertWithoutGymPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGymPreferenceInput, UserUpdateWithoutGymPreferenceInput>, UserUncheckedUpdateWithoutGymPreferenceInput>
  }

  export type GymCreateNestedOneWithoutStudentsInput = {
    create?: XOR<GymCreateWithoutStudentsInput, GymUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GymCreateOrConnectWithoutStudentsInput
    connect?: GymWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<StudentCreateWithoutMembershipsInput, StudentUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMembershipsInput
    connect?: StudentWhereUniqueInput
  }

  export type MembershipPlanCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<MembershipPlanCreateWithoutMembershipsInput, MembershipPlanUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutMembershipsInput
    connect?: MembershipPlanWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<GymCreateWithoutStudentsInput, GymUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GymCreateOrConnectWithoutStudentsInput
    upsert?: GymUpsertWithoutStudentsInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutStudentsInput, GymUpdateWithoutStudentsInput>, GymUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<StudentCreateWithoutMembershipsInput, StudentUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMembershipsInput
    upsert?: StudentUpsertWithoutMembershipsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMembershipsInput, StudentUpdateWithoutMembershipsInput>, StudentUncheckedUpdateWithoutMembershipsInput>
  }

  export type MembershipPlanUpdateOneWithoutMembershipsNestedInput = {
    create?: XOR<MembershipPlanCreateWithoutMembershipsInput, MembershipPlanUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutMembershipsInput
    upsert?: MembershipPlanUpsertWithoutMembershipsInput
    disconnect?: MembershipPlanWhereInput | boolean
    delete?: MembershipPlanWhereInput | boolean
    connect?: MembershipPlanWhereUniqueInput
    update?: XOR<XOR<MembershipPlanUpdateToOneWithWhereWithoutMembershipsInput, MembershipPlanUpdateWithoutMembershipsInput>, MembershipPlanUncheckedUpdateWithoutMembershipsInput>
  }

  export type GymCreateNestedOneWithoutPlansInput = {
    create?: XOR<GymCreateWithoutPlansInput, GymUncheckedCreateWithoutPlansInput>
    connectOrCreate?: GymCreateOrConnectWithoutPlansInput
    connect?: GymWhereUniqueInput
  }

  export type GymMembershipCreateNestedManyWithoutPlanInput = {
    create?: XOR<GymMembershipCreateWithoutPlanInput, GymMembershipUncheckedCreateWithoutPlanInput> | GymMembershipCreateWithoutPlanInput[] | GymMembershipUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutPlanInput | GymMembershipCreateOrConnectWithoutPlanInput[]
    createMany?: GymMembershipCreateManyPlanInputEnvelope
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPlanInput = {
    create?: XOR<PaymentCreateWithoutPlanInput, PaymentUncheckedCreateWithoutPlanInput> | PaymentCreateWithoutPlanInput[] | PaymentUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlanInput | PaymentCreateOrConnectWithoutPlanInput[]
    createMany?: PaymentCreateManyPlanInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type GymMembershipUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<GymMembershipCreateWithoutPlanInput, GymMembershipUncheckedCreateWithoutPlanInput> | GymMembershipCreateWithoutPlanInput[] | GymMembershipUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutPlanInput | GymMembershipCreateOrConnectWithoutPlanInput[]
    createMany?: GymMembershipCreateManyPlanInputEnvelope
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PaymentCreateWithoutPlanInput, PaymentUncheckedCreateWithoutPlanInput> | PaymentCreateWithoutPlanInput[] | PaymentUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlanInput | PaymentCreateOrConnectWithoutPlanInput[]
    createMany?: PaymentCreateManyPlanInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type GymUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<GymCreateWithoutPlansInput, GymUncheckedCreateWithoutPlansInput>
    connectOrCreate?: GymCreateOrConnectWithoutPlansInput
    upsert?: GymUpsertWithoutPlansInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutPlansInput, GymUpdateWithoutPlansInput>, GymUncheckedUpdateWithoutPlansInput>
  }

  export type GymMembershipUpdateManyWithoutPlanNestedInput = {
    create?: XOR<GymMembershipCreateWithoutPlanInput, GymMembershipUncheckedCreateWithoutPlanInput> | GymMembershipCreateWithoutPlanInput[] | GymMembershipUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutPlanInput | GymMembershipCreateOrConnectWithoutPlanInput[]
    upsert?: GymMembershipUpsertWithWhereUniqueWithoutPlanInput | GymMembershipUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: GymMembershipCreateManyPlanInputEnvelope
    set?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    disconnect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    delete?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    update?: GymMembershipUpdateWithWhereUniqueWithoutPlanInput | GymMembershipUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: GymMembershipUpdateManyWithWhereWithoutPlanInput | GymMembershipUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PaymentCreateWithoutPlanInput, PaymentUncheckedCreateWithoutPlanInput> | PaymentCreateWithoutPlanInput[] | PaymentUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlanInput | PaymentCreateOrConnectWithoutPlanInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPlanInput | PaymentUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PaymentCreateManyPlanInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPlanInput | PaymentUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPlanInput | PaymentUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type GymMembershipUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<GymMembershipCreateWithoutPlanInput, GymMembershipUncheckedCreateWithoutPlanInput> | GymMembershipCreateWithoutPlanInput[] | GymMembershipUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GymMembershipCreateOrConnectWithoutPlanInput | GymMembershipCreateOrConnectWithoutPlanInput[]
    upsert?: GymMembershipUpsertWithWhereUniqueWithoutPlanInput | GymMembershipUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: GymMembershipCreateManyPlanInputEnvelope
    set?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    disconnect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    delete?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    connect?: GymMembershipWhereUniqueInput | GymMembershipWhereUniqueInput[]
    update?: GymMembershipUpdateWithWhereUniqueWithoutPlanInput | GymMembershipUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: GymMembershipUpdateManyWithWhereWithoutPlanInput | GymMembershipUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PaymentCreateWithoutPlanInput, PaymentUncheckedCreateWithoutPlanInput> | PaymentCreateWithoutPlanInput[] | PaymentUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlanInput | PaymentCreateOrConnectWithoutPlanInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPlanInput | PaymentUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PaymentCreateManyPlanInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPlanInput | PaymentUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPlanInput | PaymentUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutDayPassesInput = {
    create?: XOR<StudentCreateWithoutDayPassesInput, StudentUncheckedCreateWithoutDayPassesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDayPassesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutDayPassesNestedInput = {
    create?: XOR<StudentCreateWithoutDayPassesInput, StudentUncheckedCreateWithoutDayPassesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDayPassesInput
    upsert?: StudentUpsertWithoutDayPassesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutDayPassesInput, StudentUpdateWithoutDayPassesInput>, StudentUncheckedUpdateWithoutDayPassesInput>
  }

  export type GymCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<GymCreateWithoutCheckInsInput, GymUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: GymCreateOrConnectWithoutCheckInsInput
    connect?: GymWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutCheckInsNestedInput = {
    create?: XOR<GymCreateWithoutCheckInsInput, GymUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: GymCreateOrConnectWithoutCheckInsInput
    upsert?: GymUpsertWithoutCheckInsInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutCheckInsInput, GymUpdateWithoutCheckInsInput>, GymUncheckedUpdateWithoutCheckInsInput>
  }

  export type GymCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<GymCreateWithoutEquipmentInput, GymUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: GymCreateOrConnectWithoutEquipmentInput
    connect?: GymWhereUniqueInput
  }

  export type MaintenanceRecordCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceRecordCreateWithoutEquipmentInput, MaintenanceRecordUncheckedCreateWithoutEquipmentInput> | MaintenanceRecordCreateWithoutEquipmentInput[] | MaintenanceRecordUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceRecordCreateOrConnectWithoutEquipmentInput | MaintenanceRecordCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceRecordCreateManyEquipmentInputEnvelope
    connect?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
  }

  export type MaintenanceRecordUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceRecordCreateWithoutEquipmentInput, MaintenanceRecordUncheckedCreateWithoutEquipmentInput> | MaintenanceRecordCreateWithoutEquipmentInput[] | MaintenanceRecordUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceRecordCreateOrConnectWithoutEquipmentInput | MaintenanceRecordCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceRecordCreateManyEquipmentInputEnvelope
    connect?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
  }

  export type GymUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<GymCreateWithoutEquipmentInput, GymUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: GymCreateOrConnectWithoutEquipmentInput
    upsert?: GymUpsertWithoutEquipmentInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutEquipmentInput, GymUpdateWithoutEquipmentInput>, GymUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceRecordUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceRecordCreateWithoutEquipmentInput, MaintenanceRecordUncheckedCreateWithoutEquipmentInput> | MaintenanceRecordCreateWithoutEquipmentInput[] | MaintenanceRecordUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceRecordCreateOrConnectWithoutEquipmentInput | MaintenanceRecordCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceRecordUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceRecordUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceRecordCreateManyEquipmentInputEnvelope
    set?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    disconnect?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    delete?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    connect?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    update?: MaintenanceRecordUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceRecordUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceRecordUpdateManyWithWhereWithoutEquipmentInput | MaintenanceRecordUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceRecordScalarWhereInput | MaintenanceRecordScalarWhereInput[]
  }

  export type MaintenanceRecordUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceRecordCreateWithoutEquipmentInput, MaintenanceRecordUncheckedCreateWithoutEquipmentInput> | MaintenanceRecordCreateWithoutEquipmentInput[] | MaintenanceRecordUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceRecordCreateOrConnectWithoutEquipmentInput | MaintenanceRecordCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceRecordUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceRecordUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceRecordCreateManyEquipmentInputEnvelope
    set?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    disconnect?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    delete?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    connect?: MaintenanceRecordWhereUniqueInput | MaintenanceRecordWhereUniqueInput[]
    update?: MaintenanceRecordUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceRecordUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceRecordUpdateManyWithWhereWithoutEquipmentInput | MaintenanceRecordUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceRecordScalarWhereInput | MaintenanceRecordScalarWhereInput[]
  }

  export type EquipmentCreateNestedOneWithoutMaintenanceHistoryInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceHistoryInput, EquipmentUncheckedCreateWithoutMaintenanceHistoryInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceHistoryInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutMaintenanceHistoryNestedInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceHistoryInput, EquipmentUncheckedCreateWithoutMaintenanceHistoryInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceHistoryInput
    upsert?: EquipmentUpsertWithoutMaintenanceHistoryInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutMaintenanceHistoryInput, EquipmentUpdateWithoutMaintenanceHistoryInput>, EquipmentUncheckedUpdateWithoutMaintenanceHistoryInput>
  }

  export type GymCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<GymCreateWithoutPaymentsInput, GymUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: GymCreateOrConnectWithoutPaymentsInput
    connect?: GymWhereUniqueInput
  }

  export type MembershipPlanCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<MembershipPlanCreateWithoutPaymentsInput, MembershipPlanUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutPaymentsInput
    connect?: MembershipPlanWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<GymCreateWithoutPaymentsInput, GymUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: GymCreateOrConnectWithoutPaymentsInput
    upsert?: GymUpsertWithoutPaymentsInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutPaymentsInput, GymUpdateWithoutPaymentsInput>, GymUncheckedUpdateWithoutPaymentsInput>
  }

  export type MembershipPlanUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<MembershipPlanCreateWithoutPaymentsInput, MembershipPlanUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutPaymentsInput
    upsert?: MembershipPlanUpsertWithoutPaymentsInput
    disconnect?: MembershipPlanWhereInput | boolean
    delete?: MembershipPlanWhereInput | boolean
    connect?: MembershipPlanWhereUniqueInput
    update?: XOR<XOR<MembershipPlanUpdateToOneWithWhereWithoutPaymentsInput, MembershipPlanUpdateWithoutPaymentsInput>, MembershipPlanUncheckedUpdateWithoutPaymentsInput>
  }

  export type GymCreateNestedOneWithoutExpensesInput = {
    create?: XOR<GymCreateWithoutExpensesInput, GymUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: GymCreateOrConnectWithoutExpensesInput
    connect?: GymWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<GymCreateWithoutExpensesInput, GymUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: GymCreateOrConnectWithoutExpensesInput
    upsert?: GymUpsertWithoutExpensesInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutExpensesInput, GymUpdateWithoutExpensesInput>, GymUncheckedUpdateWithoutExpensesInput>
  }

  export type UserCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentMethodsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentMethodsInput
    upsert?: UserUpsertWithoutPaymentMethodsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentMethodsInput, UserUpdateWithoutPaymentMethodsInput>, UserUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type StudentCreateNestedOneWithoutFriendsInput = {
    create?: XOR<StudentCreateWithoutFriendsInput, StudentUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFriendsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutFriendOfInput = {
    create?: XOR<StudentCreateWithoutFriendOfInput, StudentUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFriendOfInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutFriendsNestedInput = {
    create?: XOR<StudentCreateWithoutFriendsInput, StudentUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFriendsInput
    upsert?: StudentUpsertWithoutFriendsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFriendsInput, StudentUpdateWithoutFriendsInput>, StudentUncheckedUpdateWithoutFriendsInput>
  }

  export type StudentUpdateOneRequiredWithoutFriendOfNestedInput = {
    create?: XOR<StudentCreateWithoutFriendOfInput, StudentUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFriendOfInput
    upsert?: StudentUpsertWithoutFriendOfInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFriendOfInput, StudentUpdateWithoutFriendOfInput>, StudentUncheckedUpdateWithoutFriendOfInput>
  }

  export type StudentCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<StudentCreateWithoutSubscriptionInput, StudentUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubscriptionInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<StudentCreateWithoutSubscriptionInput, StudentUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubscriptionInput
    upsert?: StudentUpsertWithoutSubscriptionInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSubscriptionInput, StudentUpdateWithoutSubscriptionInput>, StudentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type GymCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<GymCreateWithoutSubscriptionInput, GymUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: GymCreateOrConnectWithoutSubscriptionInput
    connect?: GymWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<GymCreateWithoutSubscriptionInput, GymUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: GymCreateOrConnectWithoutSubscriptionInput
    upsert?: GymUpsertWithoutSubscriptionInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutSubscriptionInput, GymUpdateWithoutSubscriptionInput>, GymUncheckedUpdateWithoutSubscriptionInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type GymCreateWithoutUserInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutUserInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutUserInput, GymUncheckedCreateWithoutUserInput>
  }

  export type GymCreateManyUserInputEnvelope = {
    data: GymCreateManyUserInput | GymCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type?: string | null
    provider?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId?: string | null
    providerId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    idToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type?: string | null
    provider?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId?: string | null
    providerId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    idToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionToken?: string | null
    expires?: Date | string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionToken?: string | null
    expires?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GymUserPreferenceCreateWithoutUserInput = {
    id?: string
    lastActiveGymId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUserPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    lastActiveGymId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUserPreferenceCreateOrConnectWithoutUserInput = {
    where: GymUserPreferenceWhereUniqueInput
    create: XOR<GymUserPreferenceCreateWithoutUserInput, GymUserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodCreateWithoutUserInput = {
    id?: string
    type: string
    isDefault?: boolean
    cardBrand?: string | null
    last4?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    holderName?: string | null
    pixKey?: string | null
    pixKeyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    isDefault?: boolean
    cardBrand?: string | null
    last4?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    holderName?: string | null
    pixKey?: string | null
    pixKeyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodCreateManyUserInputEnvelope = {
    data: PaymentMethodCreateManyUserInput | PaymentMethodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type GymUpsertWithWhereUniqueWithoutUserInput = {
    where: GymWhereUniqueInput
    update: XOR<GymUpdateWithoutUserInput, GymUncheckedUpdateWithoutUserInput>
    create: XOR<GymCreateWithoutUserInput, GymUncheckedCreateWithoutUserInput>
  }

  export type GymUpdateWithWhereUniqueWithoutUserInput = {
    where: GymWhereUniqueInput
    data: XOR<GymUpdateWithoutUserInput, GymUncheckedUpdateWithoutUserInput>
  }

  export type GymUpdateManyWithWhereWithoutUserInput = {
    where: GymScalarWhereInput
    data: XOR<GymUpdateManyMutationInput, GymUncheckedUpdateManyWithoutUserInput>
  }

  export type GymScalarWhereInput = {
    AND?: GymScalarWhereInput | GymScalarWhereInput[]
    OR?: GymScalarWhereInput[]
    NOT?: GymScalarWhereInput | GymScalarWhereInput[]
    id?: StringFilter<"Gym"> | string
    userId?: StringFilter<"Gym"> | string
    name?: StringFilter<"Gym"> | string
    logo?: StringNullableFilter<"Gym"> | string | null
    address?: StringFilter<"Gym"> | string
    phone?: StringFilter<"Gym"> | string
    email?: StringFilter<"Gym"> | string
    cnpj?: StringNullableFilter<"Gym"> | string | null
    plan?: StringFilter<"Gym"> | string
    isActive?: BoolFilter<"Gym"> | boolean
    latitude?: FloatNullableFilter<"Gym"> | number | null
    longitude?: FloatNullableFilter<"Gym"> | number | null
    rating?: FloatNullableFilter<"Gym"> | number | null
    totalReviews?: IntFilter<"Gym"> | number
    amenities?: StringNullableFilter<"Gym"> | string | null
    openingHours?: StringNullableFilter<"Gym"> | string | null
    photos?: StringNullableFilter<"Gym"> | string | null
    isPartner?: BoolFilter<"Gym"> | boolean
    createdAt?: DateTimeFilter<"Gym"> | Date | string
    updatedAt?: DateTimeFilter<"Gym"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringNullableFilter<"Account"> | string | null
    provider?: StringNullableFilter<"Account"> | string | null
    providerAccountId?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    accountId?: StringNullableFilter<"Account"> | string | null
    providerId?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringNullableFilter<"Session"> | string | null
    expires?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type GymUserPreferenceUpsertWithoutUserInput = {
    update: XOR<GymUserPreferenceUpdateWithoutUserInput, GymUserPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<GymUserPreferenceCreateWithoutUserInput, GymUserPreferenceUncheckedCreateWithoutUserInput>
    where?: GymUserPreferenceWhereInput
  }

  export type GymUserPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: GymUserPreferenceWhereInput
    data: XOR<GymUserPreferenceUpdateWithoutUserInput, GymUserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type GymUserPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastActiveGymId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymUserPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastActiveGymId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    update: XOR<PaymentMethodUpdateWithoutUserInput, PaymentMethodUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    data: XOR<PaymentMethodUpdateWithoutUserInput, PaymentMethodUncheckedUpdateWithoutUserInput>
  }

  export type PaymentMethodUpdateManyWithWhereWithoutUserInput = {
    where: PaymentMethodScalarWhereInput
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentMethodScalarWhereInput = {
    AND?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    OR?: PaymentMethodScalarWhereInput[]
    NOT?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    cardBrand?: StringNullableFilter<"PaymentMethod"> | string | null
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    holderName?: StringNullableFilter<"PaymentMethod"> | string | null
    pixKey?: StringNullableFilter<"PaymentMethod"> | string | null
    pixKeyType?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentCreateNestedOneWithoutUserInput
    gyms?: GymCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    gyms?: GymUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutUserNestedInput
    gyms?: GymUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    gyms?: GymUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentCreateNestedOneWithoutUserInput
    gyms?: GymCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    gyms?: GymUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutUserNestedInput
    gyms?: GymUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    gyms?: GymUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    gyms?: GymCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    gyms?: GymUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type StudentProgressCreateWithoutStudentInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    workoutsCompleted?: number
    lastActivityDate?: Date | string | null
    dailyGoalXP?: number
    todayXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProgressUncheckedCreateWithoutStudentInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    workoutsCompleted?: number
    lastActivityDate?: Date | string | null
    dailyGoalXP?: number
    todayXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProgressCreateOrConnectWithoutStudentInput = {
    where: StudentProgressWhereUniqueInput
    create: XOR<StudentProgressCreateWithoutStudentInput, StudentProgressUncheckedCreateWithoutStudentInput>
  }

  export type StudentProfileCreateWithoutStudentInput = {
    id?: string
    height?: number | null
    weight?: number | null
    fitnessLevel?: string | null
    weeklyWorkoutFrequency?: number | null
    workoutDuration?: number | null
    goals?: string | null
    injuries?: string | null
    availableEquipment?: string | null
    gymType?: string | null
    preferredWorkoutTime?: string | null
    preferredSets?: number | null
    preferredRepRange?: string | null
    restTime?: string | null
    dietType?: string | null
    allergies?: string | null
    targetCalories?: number | null
    targetProtein?: number | null
    targetCarbs?: number | null
    targetFats?: number | null
    mealsPerDay?: number | null
    bmr?: number | null
    tdee?: number | null
    activityLevel?: number | null
    hormoneTreatmentDuration?: number | null
    physicalLimitations?: string | null
    motorLimitations?: string | null
    medicalConditions?: string | null
    limitationDetails?: string | null
    dailyAvailableHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUncheckedCreateWithoutStudentInput = {
    id?: string
    height?: number | null
    weight?: number | null
    fitnessLevel?: string | null
    weeklyWorkoutFrequency?: number | null
    workoutDuration?: number | null
    goals?: string | null
    injuries?: string | null
    availableEquipment?: string | null
    gymType?: string | null
    preferredWorkoutTime?: string | null
    preferredSets?: number | null
    preferredRepRange?: string | null
    restTime?: string | null
    dietType?: string | null
    allergies?: string | null
    targetCalories?: number | null
    targetProtein?: number | null
    targetCarbs?: number | null
    targetFats?: number | null
    mealsPerDay?: number | null
    bmr?: number | null
    tdee?: number | null
    activityLevel?: number | null
    hormoneTreatmentDuration?: number | null
    physicalLimitations?: string | null
    motorLimitations?: string | null
    medicalConditions?: string | null
    limitationDetails?: string | null
    dailyAvailableHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileCreateOrConnectWithoutStudentInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutStudentInput, StudentProfileUncheckedCreateWithoutStudentInput>
  }

  export type WorkoutHistoryCreateWithoutStudentInput = {
    id?: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    workout?: WorkoutCreateNestedOneWithoutCompletionsInput
    exercises?: ExerciseLogCreateNestedManyWithoutWorkoutHistoryInput
    records?: PersonalRecordCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryUncheckedCreateWithoutStudentInput = {
    id?: string
    workoutId?: string | null
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    exercises?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutHistoryInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryCreateOrConnectWithoutStudentInput = {
    where: WorkoutHistoryWhereUniqueInput
    create: XOR<WorkoutHistoryCreateWithoutStudentInput, WorkoutHistoryUncheckedCreateWithoutStudentInput>
  }

  export type WorkoutHistoryCreateManyStudentInputEnvelope = {
    data: WorkoutHistoryCreateManyStudentInput | WorkoutHistoryCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutProgressCreateWithoutStudentInput = {
    id?: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workout: WorkoutCreateNestedOneWithoutProgressInput
  }

  export type WorkoutProgressUncheckedCreateWithoutStudentInput = {
    id?: string
    workoutId: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutProgressCreateOrConnectWithoutStudentInput = {
    where: WorkoutProgressWhereUniqueInput
    create: XOR<WorkoutProgressCreateWithoutStudentInput, WorkoutProgressUncheckedCreateWithoutStudentInput>
  }

  export type WorkoutProgressCreateManyStudentInputEnvelope = {
    data: WorkoutProgressCreateManyStudentInput | WorkoutProgressCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PersonalRecordCreateWithoutStudentInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
    workoutHistory?: WorkoutHistoryCreateNestedOneWithoutRecordsInput
  }

  export type PersonalRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    workoutHistoryId?: string | null
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
  }

  export type PersonalRecordCreateOrConnectWithoutStudentInput = {
    where: PersonalRecordWhereUniqueInput
    create: XOR<PersonalRecordCreateWithoutStudentInput, PersonalRecordUncheckedCreateWithoutStudentInput>
  }

  export type PersonalRecordCreateManyStudentInputEnvelope = {
    data: PersonalRecordCreateManyStudentInput | PersonalRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type DietPlanCompletionCreateWithoutStudentInput = {
    id?: string
    date?: Date | string
    completed?: boolean
    dietPlan: DietPlanCreateNestedOneWithoutCompletionsInput
  }

  export type DietPlanCompletionUncheckedCreateWithoutStudentInput = {
    id?: string
    dietPlanId: string
    date?: Date | string
    completed?: boolean
  }

  export type DietPlanCompletionCreateOrConnectWithoutStudentInput = {
    where: DietPlanCompletionWhereUniqueInput
    create: XOR<DietPlanCompletionCreateWithoutStudentInput, DietPlanCompletionUncheckedCreateWithoutStudentInput>
  }

  export type DietPlanCompletionCreateManyStudentInputEnvelope = {
    data: DietPlanCompletionCreateManyStudentInput | DietPlanCompletionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AchievementUnlockCreateWithoutStudentInput = {
    id?: string
    progress?: number | null
    unlockedAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutUnlocksInput
  }

  export type AchievementUnlockUncheckedCreateWithoutStudentInput = {
    id?: string
    achievementId: string
    progress?: number | null
    unlockedAt?: Date | string
  }

  export type AchievementUnlockCreateOrConnectWithoutStudentInput = {
    where: AchievementUnlockWhereUniqueInput
    create: XOR<AchievementUnlockCreateWithoutStudentInput, AchievementUnlockUncheckedCreateWithoutStudentInput>
  }

  export type AchievementUnlockCreateManyStudentInputEnvelope = {
    data: AchievementUnlockCreateManyStudentInput | AchievementUnlockCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type WeightHistoryCreateWithoutStudentInput = {
    id?: string
    weight: number
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeightHistoryUncheckedCreateWithoutStudentInput = {
    id?: string
    weight: number
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeightHistoryCreateOrConnectWithoutStudentInput = {
    where: WeightHistoryWhereUniqueInput
    create: XOR<WeightHistoryCreateWithoutStudentInput, WeightHistoryUncheckedCreateWithoutStudentInput>
  }

  export type WeightHistoryCreateManyStudentInputEnvelope = {
    data: WeightHistoryCreateManyStudentInput | WeightHistoryCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type DailyNutritionCreateWithoutStudentInput = {
    id?: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: NutritionMealCreateNestedManyWithoutDailyNutritionInput
  }

  export type DailyNutritionUncheckedCreateWithoutStudentInput = {
    id?: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: NutritionMealUncheckedCreateNestedManyWithoutDailyNutritionInput
  }

  export type DailyNutritionCreateOrConnectWithoutStudentInput = {
    where: DailyNutritionWhereUniqueInput
    create: XOR<DailyNutritionCreateWithoutStudentInput, DailyNutritionUncheckedCreateWithoutStudentInput>
  }

  export type DailyNutritionCreateManyStudentInputEnvelope = {
    data: DailyNutritionCreateManyStudentInput | DailyNutritionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type NutritionChatUsageCreateWithoutStudentInput = {
    id?: string
    date?: Date | string
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionChatUsageUncheckedCreateWithoutStudentInput = {
    id?: string
    date?: Date | string
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionChatUsageCreateOrConnectWithoutStudentInput = {
    where: NutritionChatUsageWhereUniqueInput
    create: XOR<NutritionChatUsageCreateWithoutStudentInput, NutritionChatUsageUncheckedCreateWithoutStudentInput>
  }

  export type NutritionChatUsageCreateManyStudentInputEnvelope = {
    data: NutritionChatUsageCreateManyStudentInput | NutritionChatUsageCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutStudentInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workouts?: WorkoutCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutStudentInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutStudentInput, UnitUncheckedCreateWithoutStudentInput>
  }

  export type UnitCreateManyStudentInputEnvelope = {
    data: UnitCreateManyStudentInput | UnitCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type GymMembershipCreateWithoutStudentInput = {
    id?: string
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutStudentsInput
    plan?: MembershipPlanCreateNestedOneWithoutMembershipsInput
  }

  export type GymMembershipUncheckedCreateWithoutStudentInput = {
    id?: string
    gymId: string
    planId?: string | null
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipCreateOrConnectWithoutStudentInput = {
    where: GymMembershipWhereUniqueInput
    create: XOR<GymMembershipCreateWithoutStudentInput, GymMembershipUncheckedCreateWithoutStudentInput>
  }

  export type GymMembershipCreateManyStudentInputEnvelope = {
    data: GymMembershipCreateManyStudentInput | GymMembershipCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type DayPassCreateWithoutStudentInput = {
    id?: string
    gymId: string
    gymName: string
    purchaseDate?: Date | string
    validDate: Date | string
    price: number
    status?: string
    qrCode?: string | null
  }

  export type DayPassUncheckedCreateWithoutStudentInput = {
    id?: string
    gymId: string
    gymName: string
    purchaseDate?: Date | string
    validDate: Date | string
    price: number
    status?: string
    qrCode?: string | null
  }

  export type DayPassCreateOrConnectWithoutStudentInput = {
    where: DayPassWhereUniqueInput
    create: XOR<DayPassCreateWithoutStudentInput, DayPassUncheckedCreateWithoutStudentInput>
  }

  export type DayPassCreateManyStudentInputEnvelope = {
    data: DayPassCreateManyStudentInput | DayPassCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    friend: StudentCreateNestedOneWithoutFriendOfInput
  }

  export type FriendshipUncheckedCreateWithoutUserInput = {
    id?: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput>
  }

  export type FriendshipCreateManyUserInputEnvelope = {
    data: FriendshipCreateManyUserInput | FriendshipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutFriendInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    user: StudentCreateNestedOneWithoutFriendsInput
  }

  export type FriendshipUncheckedCreateWithoutFriendInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput>
  }

  export type FriendshipCreateManyFriendInputEnvelope = {
    data: FriendshipCreateManyFriendInput | FriendshipCreateManyFriendInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutStudentInput = {
    id?: string
    plan?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutStudentInput = {
    id?: string
    plan?: string
    status?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutStudentInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutStudentInput, SubscriptionUncheckedCreateWithoutStudentInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    gyms?: GymUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    gyms?: GymUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentProgressUpsertWithoutStudentInput = {
    update: XOR<StudentProgressUpdateWithoutStudentInput, StudentProgressUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentProgressCreateWithoutStudentInput, StudentProgressUncheckedCreateWithoutStudentInput>
    where?: StudentProgressWhereInput
  }

  export type StudentProgressUpdateToOneWithWhereWithoutStudentInput = {
    where?: StudentProgressWhereInput
    data: XOR<StudentProgressUpdateWithoutStudentInput, StudentProgressUncheckedUpdateWithoutStudentInput>
  }

  export type StudentProgressUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    workoutsCompleted?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyGoalXP?: IntFieldUpdateOperationsInput | number
    todayXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProgressUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    workoutsCompleted?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyGoalXP?: IntFieldUpdateOperationsInput | number
    todayXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUpsertWithoutStudentInput = {
    update: XOR<StudentProfileUpdateWithoutStudentInput, StudentProfileUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentProfileCreateWithoutStudentInput, StudentProfileUncheckedCreateWithoutStudentInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutStudentInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutStudentInput, StudentProfileUncheckedUpdateWithoutStudentInput>
  }

  export type StudentProfileUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyWorkoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: NullableStringFieldUpdateOperationsInput | string | null
    availableEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    gymType?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredSets?: NullableIntFieldUpdateOperationsInput | number | null
    preferredRepRange?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    targetProtein?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCarbs?: NullableFloatFieldUpdateOperationsInput | number | null
    targetFats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    bmr?: NullableFloatFieldUpdateOperationsInput | number | null
    tdee?: NullableFloatFieldUpdateOperationsInput | number | null
    activityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    hormoneTreatmentDuration?: NullableIntFieldUpdateOperationsInput | number | null
    physicalLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    motorLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    limitationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    dailyAvailableHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyWorkoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    injuries?: NullableStringFieldUpdateOperationsInput | string | null
    availableEquipment?: NullableStringFieldUpdateOperationsInput | string | null
    gymType?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredSets?: NullableIntFieldUpdateOperationsInput | number | null
    preferredRepRange?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    targetProtein?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCarbs?: NullableFloatFieldUpdateOperationsInput | number | null
    targetFats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    bmr?: NullableFloatFieldUpdateOperationsInput | number | null
    tdee?: NullableFloatFieldUpdateOperationsInput | number | null
    activityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    hormoneTreatmentDuration?: NullableIntFieldUpdateOperationsInput | number | null
    physicalLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    motorLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    limitationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    dailyAvailableHours?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutHistoryUpsertWithWhereUniqueWithoutStudentInput = {
    where: WorkoutHistoryWhereUniqueInput
    update: XOR<WorkoutHistoryUpdateWithoutStudentInput, WorkoutHistoryUncheckedUpdateWithoutStudentInput>
    create: XOR<WorkoutHistoryCreateWithoutStudentInput, WorkoutHistoryUncheckedCreateWithoutStudentInput>
  }

  export type WorkoutHistoryUpdateWithWhereUniqueWithoutStudentInput = {
    where: WorkoutHistoryWhereUniqueInput
    data: XOR<WorkoutHistoryUpdateWithoutStudentInput, WorkoutHistoryUncheckedUpdateWithoutStudentInput>
  }

  export type WorkoutHistoryUpdateManyWithWhereWithoutStudentInput = {
    where: WorkoutHistoryScalarWhereInput
    data: XOR<WorkoutHistoryUpdateManyMutationInput, WorkoutHistoryUncheckedUpdateManyWithoutStudentInput>
  }

  export type WorkoutHistoryScalarWhereInput = {
    AND?: WorkoutHistoryScalarWhereInput | WorkoutHistoryScalarWhereInput[]
    OR?: WorkoutHistoryScalarWhereInput[]
    NOT?: WorkoutHistoryScalarWhereInput | WorkoutHistoryScalarWhereInput[]
    id?: StringFilter<"WorkoutHistory"> | string
    studentId?: StringFilter<"WorkoutHistory"> | string
    workoutId?: StringNullableFilter<"WorkoutHistory"> | string | null
    date?: DateTimeFilter<"WorkoutHistory"> | Date | string
    duration?: IntFilter<"WorkoutHistory"> | number
    totalVolume?: FloatNullableFilter<"WorkoutHistory"> | number | null
    overallFeedback?: StringNullableFilter<"WorkoutHistory"> | string | null
    bodyPartsFatigued?: StringNullableFilter<"WorkoutHistory"> | string | null
    createdAt?: DateTimeFilter<"WorkoutHistory"> | Date | string
  }

  export type WorkoutProgressUpsertWithWhereUniqueWithoutStudentInput = {
    where: WorkoutProgressWhereUniqueInput
    update: XOR<WorkoutProgressUpdateWithoutStudentInput, WorkoutProgressUncheckedUpdateWithoutStudentInput>
    create: XOR<WorkoutProgressCreateWithoutStudentInput, WorkoutProgressUncheckedCreateWithoutStudentInput>
  }

  export type WorkoutProgressUpdateWithWhereUniqueWithoutStudentInput = {
    where: WorkoutProgressWhereUniqueInput
    data: XOR<WorkoutProgressUpdateWithoutStudentInput, WorkoutProgressUncheckedUpdateWithoutStudentInput>
  }

  export type WorkoutProgressUpdateManyWithWhereWithoutStudentInput = {
    where: WorkoutProgressScalarWhereInput
    data: XOR<WorkoutProgressUpdateManyMutationInput, WorkoutProgressUncheckedUpdateManyWithoutStudentInput>
  }

  export type WorkoutProgressScalarWhereInput = {
    AND?: WorkoutProgressScalarWhereInput | WorkoutProgressScalarWhereInput[]
    OR?: WorkoutProgressScalarWhereInput[]
    NOT?: WorkoutProgressScalarWhereInput | WorkoutProgressScalarWhereInput[]
    id?: StringFilter<"WorkoutProgress"> | string
    studentId?: StringFilter<"WorkoutProgress"> | string
    workoutId?: StringFilter<"WorkoutProgress"> | string
    currentExerciseIndex?: IntFilter<"WorkoutProgress"> | number
    exerciseLogs?: StringFilter<"WorkoutProgress"> | string
    skippedExercises?: StringNullableFilter<"WorkoutProgress"> | string | null
    selectedAlternatives?: StringNullableFilter<"WorkoutProgress"> | string | null
    xpEarned?: IntFilter<"WorkoutProgress"> | number
    totalVolume?: FloatFilter<"WorkoutProgress"> | number
    completionPercentage?: FloatFilter<"WorkoutProgress"> | number
    startTime?: DateTimeFilter<"WorkoutProgress"> | Date | string
    cardioPreference?: StringNullableFilter<"WorkoutProgress"> | string | null
    cardioDuration?: IntNullableFilter<"WorkoutProgress"> | number | null
    selectedCardioType?: StringNullableFilter<"WorkoutProgress"> | string | null
    createdAt?: DateTimeFilter<"WorkoutProgress"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutProgress"> | Date | string
  }

  export type PersonalRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: PersonalRecordWhereUniqueInput
    update: XOR<PersonalRecordUpdateWithoutStudentInput, PersonalRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<PersonalRecordCreateWithoutStudentInput, PersonalRecordUncheckedCreateWithoutStudentInput>
  }

  export type PersonalRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: PersonalRecordWhereUniqueInput
    data: XOR<PersonalRecordUpdateWithoutStudentInput, PersonalRecordUncheckedUpdateWithoutStudentInput>
  }

  export type PersonalRecordUpdateManyWithWhereWithoutStudentInput = {
    where: PersonalRecordScalarWhereInput
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type PersonalRecordScalarWhereInput = {
    AND?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
    OR?: PersonalRecordScalarWhereInput[]
    NOT?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
    id?: StringFilter<"PersonalRecord"> | string
    studentId?: StringFilter<"PersonalRecord"> | string
    workoutHistoryId?: StringNullableFilter<"PersonalRecord"> | string | null
    exerciseId?: StringFilter<"PersonalRecord"> | string
    exerciseName?: StringFilter<"PersonalRecord"> | string
    type?: StringFilter<"PersonalRecord"> | string
    value?: FloatFilter<"PersonalRecord"> | number
    date?: DateTimeFilter<"PersonalRecord"> | Date | string
    previousBest?: FloatNullableFilter<"PersonalRecord"> | number | null
  }

  export type DietPlanCompletionUpsertWithWhereUniqueWithoutStudentInput = {
    where: DietPlanCompletionWhereUniqueInput
    update: XOR<DietPlanCompletionUpdateWithoutStudentInput, DietPlanCompletionUncheckedUpdateWithoutStudentInput>
    create: XOR<DietPlanCompletionCreateWithoutStudentInput, DietPlanCompletionUncheckedCreateWithoutStudentInput>
  }

  export type DietPlanCompletionUpdateWithWhereUniqueWithoutStudentInput = {
    where: DietPlanCompletionWhereUniqueInput
    data: XOR<DietPlanCompletionUpdateWithoutStudentInput, DietPlanCompletionUncheckedUpdateWithoutStudentInput>
  }

  export type DietPlanCompletionUpdateManyWithWhereWithoutStudentInput = {
    where: DietPlanCompletionScalarWhereInput
    data: XOR<DietPlanCompletionUpdateManyMutationInput, DietPlanCompletionUncheckedUpdateManyWithoutStudentInput>
  }

  export type DietPlanCompletionScalarWhereInput = {
    AND?: DietPlanCompletionScalarWhereInput | DietPlanCompletionScalarWhereInput[]
    OR?: DietPlanCompletionScalarWhereInput[]
    NOT?: DietPlanCompletionScalarWhereInput | DietPlanCompletionScalarWhereInput[]
    id?: StringFilter<"DietPlanCompletion"> | string
    studentId?: StringFilter<"DietPlanCompletion"> | string
    dietPlanId?: StringFilter<"DietPlanCompletion"> | string
    date?: DateTimeFilter<"DietPlanCompletion"> | Date | string
    completed?: BoolFilter<"DietPlanCompletion"> | boolean
  }

  export type AchievementUnlockUpsertWithWhereUniqueWithoutStudentInput = {
    where: AchievementUnlockWhereUniqueInput
    update: XOR<AchievementUnlockUpdateWithoutStudentInput, AchievementUnlockUncheckedUpdateWithoutStudentInput>
    create: XOR<AchievementUnlockCreateWithoutStudentInput, AchievementUnlockUncheckedCreateWithoutStudentInput>
  }

  export type AchievementUnlockUpdateWithWhereUniqueWithoutStudentInput = {
    where: AchievementUnlockWhereUniqueInput
    data: XOR<AchievementUnlockUpdateWithoutStudentInput, AchievementUnlockUncheckedUpdateWithoutStudentInput>
  }

  export type AchievementUnlockUpdateManyWithWhereWithoutStudentInput = {
    where: AchievementUnlockScalarWhereInput
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyWithoutStudentInput>
  }

  export type AchievementUnlockScalarWhereInput = {
    AND?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
    OR?: AchievementUnlockScalarWhereInput[]
    NOT?: AchievementUnlockScalarWhereInput | AchievementUnlockScalarWhereInput[]
    id?: StringFilter<"AchievementUnlock"> | string
    studentId?: StringFilter<"AchievementUnlock"> | string
    achievementId?: StringFilter<"AchievementUnlock"> | string
    progress?: IntNullableFilter<"AchievementUnlock"> | number | null
    unlockedAt?: DateTimeFilter<"AchievementUnlock"> | Date | string
  }

  export type WeightHistoryUpsertWithWhereUniqueWithoutStudentInput = {
    where: WeightHistoryWhereUniqueInput
    update: XOR<WeightHistoryUpdateWithoutStudentInput, WeightHistoryUncheckedUpdateWithoutStudentInput>
    create: XOR<WeightHistoryCreateWithoutStudentInput, WeightHistoryUncheckedCreateWithoutStudentInput>
  }

  export type WeightHistoryUpdateWithWhereUniqueWithoutStudentInput = {
    where: WeightHistoryWhereUniqueInput
    data: XOR<WeightHistoryUpdateWithoutStudentInput, WeightHistoryUncheckedUpdateWithoutStudentInput>
  }

  export type WeightHistoryUpdateManyWithWhereWithoutStudentInput = {
    where: WeightHistoryScalarWhereInput
    data: XOR<WeightHistoryUpdateManyMutationInput, WeightHistoryUncheckedUpdateManyWithoutStudentInput>
  }

  export type WeightHistoryScalarWhereInput = {
    AND?: WeightHistoryScalarWhereInput | WeightHistoryScalarWhereInput[]
    OR?: WeightHistoryScalarWhereInput[]
    NOT?: WeightHistoryScalarWhereInput | WeightHistoryScalarWhereInput[]
    id?: StringFilter<"WeightHistory"> | string
    studentId?: StringFilter<"WeightHistory"> | string
    weight?: FloatFilter<"WeightHistory"> | number
    date?: DateTimeFilter<"WeightHistory"> | Date | string
    notes?: StringNullableFilter<"WeightHistory"> | string | null
    createdAt?: DateTimeFilter<"WeightHistory"> | Date | string
    updatedAt?: DateTimeFilter<"WeightHistory"> | Date | string
  }

  export type DailyNutritionUpsertWithWhereUniqueWithoutStudentInput = {
    where: DailyNutritionWhereUniqueInput
    update: XOR<DailyNutritionUpdateWithoutStudentInput, DailyNutritionUncheckedUpdateWithoutStudentInput>
    create: XOR<DailyNutritionCreateWithoutStudentInput, DailyNutritionUncheckedCreateWithoutStudentInput>
  }

  export type DailyNutritionUpdateWithWhereUniqueWithoutStudentInput = {
    where: DailyNutritionWhereUniqueInput
    data: XOR<DailyNutritionUpdateWithoutStudentInput, DailyNutritionUncheckedUpdateWithoutStudentInput>
  }

  export type DailyNutritionUpdateManyWithWhereWithoutStudentInput = {
    where: DailyNutritionScalarWhereInput
    data: XOR<DailyNutritionUpdateManyMutationInput, DailyNutritionUncheckedUpdateManyWithoutStudentInput>
  }

  export type DailyNutritionScalarWhereInput = {
    AND?: DailyNutritionScalarWhereInput | DailyNutritionScalarWhereInput[]
    OR?: DailyNutritionScalarWhereInput[]
    NOT?: DailyNutritionScalarWhereInput | DailyNutritionScalarWhereInput[]
    id?: StringFilter<"DailyNutrition"> | string
    studentId?: StringFilter<"DailyNutrition"> | string
    date?: DateTimeFilter<"DailyNutrition"> | Date | string
    waterIntake?: IntFilter<"DailyNutrition"> | number
    createdAt?: DateTimeFilter<"DailyNutrition"> | Date | string
    updatedAt?: DateTimeFilter<"DailyNutrition"> | Date | string
  }

  export type NutritionChatUsageUpsertWithWhereUniqueWithoutStudentInput = {
    where: NutritionChatUsageWhereUniqueInput
    update: XOR<NutritionChatUsageUpdateWithoutStudentInput, NutritionChatUsageUncheckedUpdateWithoutStudentInput>
    create: XOR<NutritionChatUsageCreateWithoutStudentInput, NutritionChatUsageUncheckedCreateWithoutStudentInput>
  }

  export type NutritionChatUsageUpdateWithWhereUniqueWithoutStudentInput = {
    where: NutritionChatUsageWhereUniqueInput
    data: XOR<NutritionChatUsageUpdateWithoutStudentInput, NutritionChatUsageUncheckedUpdateWithoutStudentInput>
  }

  export type NutritionChatUsageUpdateManyWithWhereWithoutStudentInput = {
    where: NutritionChatUsageScalarWhereInput
    data: XOR<NutritionChatUsageUpdateManyMutationInput, NutritionChatUsageUncheckedUpdateManyWithoutStudentInput>
  }

  export type NutritionChatUsageScalarWhereInput = {
    AND?: NutritionChatUsageScalarWhereInput | NutritionChatUsageScalarWhereInput[]
    OR?: NutritionChatUsageScalarWhereInput[]
    NOT?: NutritionChatUsageScalarWhereInput | NutritionChatUsageScalarWhereInput[]
    id?: StringFilter<"NutritionChatUsage"> | string
    studentId?: StringFilter<"NutritionChatUsage"> | string
    date?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    messageCount?: IntFilter<"NutritionChatUsage"> | number
    createdAt?: DateTimeFilter<"NutritionChatUsage"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionChatUsage"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutStudentInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutStudentInput, UnitUncheckedUpdateWithoutStudentInput>
    create: XOR<UnitCreateWithoutStudentInput, UnitUncheckedCreateWithoutStudentInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutStudentInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutStudentInput, UnitUncheckedUpdateWithoutStudentInput>
  }

  export type UnitUpdateManyWithWhereWithoutStudentInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutStudentInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    title?: StringFilter<"Unit"> | string
    description?: StringNullableFilter<"Unit"> | string | null
    color?: StringNullableFilter<"Unit"> | string | null
    icon?: StringNullableFilter<"Unit"> | string | null
    order?: IntFilter<"Unit"> | number
    studentId?: StringNullableFilter<"Unit"> | string | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type GymMembershipUpsertWithWhereUniqueWithoutStudentInput = {
    where: GymMembershipWhereUniqueInput
    update: XOR<GymMembershipUpdateWithoutStudentInput, GymMembershipUncheckedUpdateWithoutStudentInput>
    create: XOR<GymMembershipCreateWithoutStudentInput, GymMembershipUncheckedCreateWithoutStudentInput>
  }

  export type GymMembershipUpdateWithWhereUniqueWithoutStudentInput = {
    where: GymMembershipWhereUniqueInput
    data: XOR<GymMembershipUpdateWithoutStudentInput, GymMembershipUncheckedUpdateWithoutStudentInput>
  }

  export type GymMembershipUpdateManyWithWhereWithoutStudentInput = {
    where: GymMembershipScalarWhereInput
    data: XOR<GymMembershipUpdateManyMutationInput, GymMembershipUncheckedUpdateManyWithoutStudentInput>
  }

  export type GymMembershipScalarWhereInput = {
    AND?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
    OR?: GymMembershipScalarWhereInput[]
    NOT?: GymMembershipScalarWhereInput | GymMembershipScalarWhereInput[]
    id?: StringFilter<"GymMembership"> | string
    gymId?: StringFilter<"GymMembership"> | string
    studentId?: StringFilter<"GymMembership"> | string
    planId?: StringNullableFilter<"GymMembership"> | string | null
    startDate?: DateTimeFilter<"GymMembership"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"GymMembership"> | Date | string | null
    amount?: FloatFilter<"GymMembership"> | number
    status?: StringFilter<"GymMembership"> | string
    autoRenew?: BoolFilter<"GymMembership"> | boolean
    createdAt?: DateTimeFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeFilter<"GymMembership"> | Date | string
  }

  export type DayPassUpsertWithWhereUniqueWithoutStudentInput = {
    where: DayPassWhereUniqueInput
    update: XOR<DayPassUpdateWithoutStudentInput, DayPassUncheckedUpdateWithoutStudentInput>
    create: XOR<DayPassCreateWithoutStudentInput, DayPassUncheckedCreateWithoutStudentInput>
  }

  export type DayPassUpdateWithWhereUniqueWithoutStudentInput = {
    where: DayPassWhereUniqueInput
    data: XOR<DayPassUpdateWithoutStudentInput, DayPassUncheckedUpdateWithoutStudentInput>
  }

  export type DayPassUpdateManyWithWhereWithoutStudentInput = {
    where: DayPassScalarWhereInput
    data: XOR<DayPassUpdateManyMutationInput, DayPassUncheckedUpdateManyWithoutStudentInput>
  }

  export type DayPassScalarWhereInput = {
    AND?: DayPassScalarWhereInput | DayPassScalarWhereInput[]
    OR?: DayPassScalarWhereInput[]
    NOT?: DayPassScalarWhereInput | DayPassScalarWhereInput[]
    id?: StringFilter<"DayPass"> | string
    studentId?: StringFilter<"DayPass"> | string
    gymId?: StringFilter<"DayPass"> | string
    gymName?: StringFilter<"DayPass"> | string
    purchaseDate?: DateTimeFilter<"DayPass"> | Date | string
    validDate?: DateTimeFilter<"DayPass"> | Date | string
    price?: FloatFilter<"DayPass"> | number
    status?: StringFilter<"DayPass"> | string
    qrCode?: StringNullableFilter<"DayPass"> | string | null
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserInput, FriendshipUncheckedUpdateWithoutUserInput>
    create: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserInput, FriendshipUncheckedUpdateWithoutUserInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: StringFilter<"Friendship"> | string
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    status?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutFriendInput, FriendshipUncheckedUpdateWithoutFriendInput>
    create: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutFriendInput, FriendshipUncheckedUpdateWithoutFriendInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutFriendInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutFriendInput>
  }

  export type SubscriptionUpsertWithoutStudentInput = {
    update: XOR<SubscriptionUpdateWithoutStudentInput, SubscriptionUncheckedUpdateWithoutStudentInput>
    create: XOR<SubscriptionCreateWithoutStudentInput, SubscriptionUncheckedCreateWithoutStudentInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutStudentInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutStudentInput, SubscriptionUncheckedUpdateWithoutStudentInput>
  }

  export type SubscriptionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutProgressInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutProgressInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutProgressInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProgressInput, StudentUncheckedCreateWithoutProgressInput>
  }

  export type StudentUpsertWithoutProgressInput = {
    update: XOR<StudentUpdateWithoutProgressInput, StudentUncheckedUpdateWithoutProgressInput>
    create: XOR<StudentCreateWithoutProgressInput, StudentUncheckedCreateWithoutProgressInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutProgressInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutProgressInput, StudentUncheckedUpdateWithoutProgressInput>
  }

  export type StudentUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateWithoutProfileInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutProfileInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
  }

  export type StudentUpsertWithoutProfileInput = {
    update: XOR<StudentUpdateWithoutProfileInput, StudentUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutProfileInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutProfileInput, StudentUncheckedUpdateWithoutProfileInput>
  }

  export type StudentUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateWithoutWeightHistoryInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutWeightHistoryInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutWeightHistoryInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutWeightHistoryInput, StudentUncheckedCreateWithoutWeightHistoryInput>
  }

  export type StudentUpsertWithoutWeightHistoryInput = {
    update: XOR<StudentUpdateWithoutWeightHistoryInput, StudentUncheckedUpdateWithoutWeightHistoryInput>
    create: XOR<StudentCreateWithoutWeightHistoryInput, StudentUncheckedCreateWithoutWeightHistoryInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutWeightHistoryInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutWeightHistoryInput, StudentUncheckedUpdateWithoutWeightHistoryInput>
  }

  export type StudentUpdateWithoutWeightHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutWeightHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type UserCreateWithoutGymsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGymsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGymsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGymsInput, UserUncheckedCreateWithoutGymsInput>
  }

  export type GymProfileCreateWithoutGymInput = {
    id?: string
    totalStudents?: number
    activeStudents?: number
    equipmentCount?: number
    level?: number
    xp?: number
    xpToNextLevel?: number
    currentStreak?: number
    longestStreak?: number
    monthlyStudentGoal?: number | null
    avgStudentFrequency?: number | null
    equipmentUtilization?: number | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymProfileUncheckedCreateWithoutGymInput = {
    id?: string
    totalStudents?: number
    activeStudents?: number
    equipmentCount?: number
    level?: number
    xp?: number
    xpToNextLevel?: number
    currentStreak?: number
    longestStreak?: number
    monthlyStudentGoal?: number | null
    avgStudentFrequency?: number | null
    equipmentUtilization?: number | null
    ranking?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymProfileCreateOrConnectWithoutGymInput = {
    where: GymProfileWhereUniqueInput
    create: XOR<GymProfileCreateWithoutGymInput, GymProfileUncheckedCreateWithoutGymInput>
  }

  export type GymMembershipCreateWithoutGymInput = {
    id?: string
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMembershipsInput
    plan?: MembershipPlanCreateNestedOneWithoutMembershipsInput
  }

  export type GymMembershipUncheckedCreateWithoutGymInput = {
    id?: string
    studentId: string
    planId?: string | null
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipCreateOrConnectWithoutGymInput = {
    where: GymMembershipWhereUniqueInput
    create: XOR<GymMembershipCreateWithoutGymInput, GymMembershipUncheckedCreateWithoutGymInput>
  }

  export type GymMembershipCreateManyGymInputEnvelope = {
    data: GymMembershipCreateManyGymInput | GymMembershipCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutGymInput = {
    id?: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maintenanceHistory?: MaintenanceRecordCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutGymInput = {
    id?: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maintenanceHistory?: MaintenanceRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutGymInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutGymInput, EquipmentUncheckedCreateWithoutGymInput>
  }

  export type EquipmentCreateManyGymInputEnvelope = {
    data: EquipmentCreateManyGymInput | EquipmentCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type MembershipPlanCreateWithoutGymInput = {
    id?: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: GymMembershipCreateNestedManyWithoutPlanInput
    payments?: PaymentCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUncheckedCreateWithoutGymInput = {
    id?: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutPlanInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanCreateOrConnectWithoutGymInput = {
    where: MembershipPlanWhereUniqueInput
    create: XOR<MembershipPlanCreateWithoutGymInput, MembershipPlanUncheckedCreateWithoutGymInput>
  }

  export type MembershipPlanCreateManyGymInputEnvelope = {
    data: MembershipPlanCreateManyGymInput | MembershipPlanCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutGymInput = {
    id?: string
    studentId: string
    studentName: string
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: MembershipPlanCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutGymInput = {
    id?: string
    studentId: string
    studentName: string
    planId?: string | null
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutGymInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutGymInput, PaymentUncheckedCreateWithoutGymInput>
  }

  export type PaymentCreateManyGymInputEnvelope = {
    data: PaymentCreateManyGymInput | PaymentCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutGymInput = {
    id?: string
    type: string
    description?: string | null
    amount: number
    date?: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type ExpenseUncheckedCreateWithoutGymInput = {
    id?: string
    type: string
    description?: string | null
    amount: number
    date?: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutGymInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutGymInput, ExpenseUncheckedCreateWithoutGymInput>
  }

  export type ExpenseCreateManyGymInputEnvelope = {
    data: ExpenseCreateManyGymInput | ExpenseCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type CheckInCreateWithoutGymInput = {
    id?: string
    studentId: string
    studentName: string
    timestamp?: Date | string
    checkOut?: Date | string | null
    duration?: number | null
  }

  export type CheckInUncheckedCreateWithoutGymInput = {
    id?: string
    studentId: string
    studentName: string
    timestamp?: Date | string
    checkOut?: Date | string | null
    duration?: number | null
  }

  export type CheckInCreateOrConnectWithoutGymInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutGymInput, CheckInUncheckedCreateWithoutGymInput>
  }

  export type CheckInCreateManyGymInputEnvelope = {
    data: CheckInCreateManyGymInput | CheckInCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type GymStatsCreateWithoutGymInput = {
    id?: string
    todayCheckins?: number
    todayActiveStudents?: number
    todayEquipmentInUse?: number
    weekTotalCheckins?: number
    weekAvgDailyCheckins?: number
    weekNewMembers?: number
    weekCanceledMembers?: number
    monthTotalCheckins?: number
    monthRetentionRate?: number
    monthGrowthRate?: number
    updatedAt?: Date | string
  }

  export type GymStatsUncheckedCreateWithoutGymInput = {
    id?: string
    todayCheckins?: number
    todayActiveStudents?: number
    todayEquipmentInUse?: number
    weekTotalCheckins?: number
    weekAvgDailyCheckins?: number
    weekNewMembers?: number
    weekCanceledMembers?: number
    monthTotalCheckins?: number
    monthRetentionRate?: number
    monthGrowthRate?: number
    updatedAt?: Date | string
  }

  export type GymStatsCreateOrConnectWithoutGymInput = {
    where: GymStatsWhereUniqueInput
    create: XOR<GymStatsCreateWithoutGymInput, GymStatsUncheckedCreateWithoutGymInput>
  }

  export type GymSubscriptionCreateWithoutGymInput = {
    id?: string
    plan: string
    billingPeriod?: string
    status?: string
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionUncheckedCreateWithoutGymInput = {
    id?: string
    plan: string
    billingPeriod?: string
    status?: string
    basePrice: number
    pricePerStudent: number
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    abacatePayBillingId?: string | null
    abacatePayCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionCreateOrConnectWithoutGymInput = {
    where: GymSubscriptionWhereUniqueInput
    create: XOR<GymSubscriptionCreateWithoutGymInput, GymSubscriptionUncheckedCreateWithoutGymInput>
  }

  export type UserUpsertWithoutGymsInput = {
    update: XOR<UserUpdateWithoutGymsInput, UserUncheckedUpdateWithoutGymsInput>
    create: XOR<UserCreateWithoutGymsInput, UserUncheckedCreateWithoutGymsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGymsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGymsInput, UserUncheckedUpdateWithoutGymsInput>
  }

  export type UserUpdateWithoutGymsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGymsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GymProfileUpsertWithoutGymInput = {
    update: XOR<GymProfileUpdateWithoutGymInput, GymProfileUncheckedUpdateWithoutGymInput>
    create: XOR<GymProfileCreateWithoutGymInput, GymProfileUncheckedCreateWithoutGymInput>
    where?: GymProfileWhereInput
  }

  export type GymProfileUpdateToOneWithWhereWithoutGymInput = {
    where?: GymProfileWhereInput
    data: XOR<GymProfileUpdateWithoutGymInput, GymProfileUncheckedUpdateWithoutGymInput>
  }

  export type GymProfileUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    activeStudents?: IntFieldUpdateOperationsInput | number
    equipmentCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    monthlyStudentGoal?: NullableIntFieldUpdateOperationsInput | number | null
    avgStudentFrequency?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymProfileUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    activeStudents?: IntFieldUpdateOperationsInput | number
    equipmentCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    monthlyStudentGoal?: NullableIntFieldUpdateOperationsInput | number | null
    avgStudentFrequency?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUpsertWithWhereUniqueWithoutGymInput = {
    where: GymMembershipWhereUniqueInput
    update: XOR<GymMembershipUpdateWithoutGymInput, GymMembershipUncheckedUpdateWithoutGymInput>
    create: XOR<GymMembershipCreateWithoutGymInput, GymMembershipUncheckedCreateWithoutGymInput>
  }

  export type GymMembershipUpdateWithWhereUniqueWithoutGymInput = {
    where: GymMembershipWhereUniqueInput
    data: XOR<GymMembershipUpdateWithoutGymInput, GymMembershipUncheckedUpdateWithoutGymInput>
  }

  export type GymMembershipUpdateManyWithWhereWithoutGymInput = {
    where: GymMembershipScalarWhereInput
    data: XOR<GymMembershipUpdateManyMutationInput, GymMembershipUncheckedUpdateManyWithoutGymInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutGymInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutGymInput, EquipmentUncheckedUpdateWithoutGymInput>
    create: XOR<EquipmentCreateWithoutGymInput, EquipmentUncheckedCreateWithoutGymInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutGymInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutGymInput, EquipmentUncheckedUpdateWithoutGymInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutGymInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutGymInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    gymId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    brand?: StringNullableFilter<"Equipment"> | string | null
    model?: StringNullableFilter<"Equipment"> | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    status?: StringFilter<"Equipment"> | string
    currentUserId?: StringNullableFilter<"Equipment"> | string | null
    currentUserName?: StringNullableFilter<"Equipment"> | string | null
    currentStartTime?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    qrCode?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
  }

  export type MembershipPlanUpsertWithWhereUniqueWithoutGymInput = {
    where: MembershipPlanWhereUniqueInput
    update: XOR<MembershipPlanUpdateWithoutGymInput, MembershipPlanUncheckedUpdateWithoutGymInput>
    create: XOR<MembershipPlanCreateWithoutGymInput, MembershipPlanUncheckedCreateWithoutGymInput>
  }

  export type MembershipPlanUpdateWithWhereUniqueWithoutGymInput = {
    where: MembershipPlanWhereUniqueInput
    data: XOR<MembershipPlanUpdateWithoutGymInput, MembershipPlanUncheckedUpdateWithoutGymInput>
  }

  export type MembershipPlanUpdateManyWithWhereWithoutGymInput = {
    where: MembershipPlanScalarWhereInput
    data: XOR<MembershipPlanUpdateManyMutationInput, MembershipPlanUncheckedUpdateManyWithoutGymInput>
  }

  export type MembershipPlanScalarWhereInput = {
    AND?: MembershipPlanScalarWhereInput | MembershipPlanScalarWhereInput[]
    OR?: MembershipPlanScalarWhereInput[]
    NOT?: MembershipPlanScalarWhereInput | MembershipPlanScalarWhereInput[]
    id?: StringFilter<"MembershipPlan"> | string
    gymId?: StringFilter<"MembershipPlan"> | string
    name?: StringFilter<"MembershipPlan"> | string
    type?: StringFilter<"MembershipPlan"> | string
    price?: FloatFilter<"MembershipPlan"> | number
    duration?: IntFilter<"MembershipPlan"> | number
    benefits?: StringNullableFilter<"MembershipPlan"> | string | null
    isActive?: BoolFilter<"MembershipPlan"> | boolean
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutGymInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutGymInput, PaymentUncheckedUpdateWithoutGymInput>
    create: XOR<PaymentCreateWithoutGymInput, PaymentUncheckedCreateWithoutGymInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutGymInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutGymInput, PaymentUncheckedUpdateWithoutGymInput>
  }

  export type PaymentUpdateManyWithWhereWithoutGymInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutGymInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    gymId?: StringFilter<"Payment"> | string
    studentId?: StringFilter<"Payment"> | string
    studentName?: StringFilter<"Payment"> | string
    planId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    date?: DateTimeFilter<"Payment"> | Date | string
    dueDate?: DateTimeFilter<"Payment"> | Date | string
    status?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutGymInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutGymInput, ExpenseUncheckedUpdateWithoutGymInput>
    create: XOR<ExpenseCreateWithoutGymInput, ExpenseUncheckedCreateWithoutGymInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutGymInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutGymInput, ExpenseUncheckedUpdateWithoutGymInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutGymInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutGymInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    gymId?: StringFilter<"Expense"> | string
    type?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    category?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type CheckInUpsertWithWhereUniqueWithoutGymInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutGymInput, CheckInUncheckedUpdateWithoutGymInput>
    create: XOR<CheckInCreateWithoutGymInput, CheckInUncheckedCreateWithoutGymInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutGymInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutGymInput, CheckInUncheckedUpdateWithoutGymInput>
  }

  export type CheckInUpdateManyWithWhereWithoutGymInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutGymInput>
  }

  export type CheckInScalarWhereInput = {
    AND?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
    OR?: CheckInScalarWhereInput[]
    NOT?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
    id?: StringFilter<"CheckIn"> | string
    gymId?: StringFilter<"CheckIn"> | string
    studentId?: StringFilter<"CheckIn"> | string
    studentName?: StringFilter<"CheckIn"> | string
    timestamp?: DateTimeFilter<"CheckIn"> | Date | string
    checkOut?: DateTimeNullableFilter<"CheckIn"> | Date | string | null
    duration?: IntNullableFilter<"CheckIn"> | number | null
  }

  export type GymStatsUpsertWithoutGymInput = {
    update: XOR<GymStatsUpdateWithoutGymInput, GymStatsUncheckedUpdateWithoutGymInput>
    create: XOR<GymStatsCreateWithoutGymInput, GymStatsUncheckedCreateWithoutGymInput>
    where?: GymStatsWhereInput
  }

  export type GymStatsUpdateToOneWithWhereWithoutGymInput = {
    where?: GymStatsWhereInput
    data: XOR<GymStatsUpdateWithoutGymInput, GymStatsUncheckedUpdateWithoutGymInput>
  }

  export type GymStatsUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    todayCheckins?: IntFieldUpdateOperationsInput | number
    todayActiveStudents?: IntFieldUpdateOperationsInput | number
    todayEquipmentInUse?: IntFieldUpdateOperationsInput | number
    weekTotalCheckins?: IntFieldUpdateOperationsInput | number
    weekAvgDailyCheckins?: FloatFieldUpdateOperationsInput | number
    weekNewMembers?: IntFieldUpdateOperationsInput | number
    weekCanceledMembers?: IntFieldUpdateOperationsInput | number
    monthTotalCheckins?: IntFieldUpdateOperationsInput | number
    monthRetentionRate?: FloatFieldUpdateOperationsInput | number
    monthGrowthRate?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymStatsUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    todayCheckins?: IntFieldUpdateOperationsInput | number
    todayActiveStudents?: IntFieldUpdateOperationsInput | number
    todayEquipmentInUse?: IntFieldUpdateOperationsInput | number
    weekTotalCheckins?: IntFieldUpdateOperationsInput | number
    weekAvgDailyCheckins?: FloatFieldUpdateOperationsInput | number
    weekNewMembers?: IntFieldUpdateOperationsInput | number
    weekCanceledMembers?: IntFieldUpdateOperationsInput | number
    monthTotalCheckins?: IntFieldUpdateOperationsInput | number
    monthRetentionRate?: FloatFieldUpdateOperationsInput | number
    monthGrowthRate?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionUpsertWithoutGymInput = {
    update: XOR<GymSubscriptionUpdateWithoutGymInput, GymSubscriptionUncheckedUpdateWithoutGymInput>
    create: XOR<GymSubscriptionCreateWithoutGymInput, GymSubscriptionUncheckedCreateWithoutGymInput>
    where?: GymSubscriptionWhereInput
  }

  export type GymSubscriptionUpdateToOneWithWhereWithoutGymInput = {
    where?: GymSubscriptionWhereInput
    data: XOR<GymSubscriptionUpdateWithoutGymInput, GymSubscriptionUncheckedUpdateWithoutGymInput>
  }

  export type GymSubscriptionUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    pricePerStudent?: FloatFieldUpdateOperationsInput | number
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingPeriod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    pricePerStudent?: FloatFieldUpdateOperationsInput | number
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abacatePayBillingId?: NullableStringFieldUpdateOperationsInput | string | null
    abacatePayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCreateWithoutProfileInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutProfileInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutProfileInput, GymUncheckedCreateWithoutProfileInput>
  }

  export type GymUpsertWithoutProfileInput = {
    update: XOR<GymUpdateWithoutProfileInput, GymUncheckedUpdateWithoutProfileInput>
    create: XOR<GymCreateWithoutProfileInput, GymUncheckedCreateWithoutProfileInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutProfileInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutProfileInput, GymUncheckedUpdateWithoutProfileInput>
  }

  export type GymUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type GymCreateWithoutStatsInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutStatsInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutStatsInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutStatsInput, GymUncheckedCreateWithoutStatsInput>
  }

  export type GymUpsertWithoutStatsInput = {
    update: XOR<GymUpdateWithoutStatsInput, GymUncheckedUpdateWithoutStatsInput>
    create: XOR<GymCreateWithoutStatsInput, GymUncheckedCreateWithoutStatsInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutStatsInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutStatsInput, GymUncheckedUpdateWithoutStatsInput>
  }

  export type GymUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type StudentCreateWithoutUnitsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUnitsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUnitsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUnitsInput, StudentUncheckedCreateWithoutUnitsInput>
  }

  export type WorkoutCreateWithoutUnitInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
    completions?: WorkoutHistoryCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutUnitInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    completions?: WorkoutHistoryUncheckedCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutUnitInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutUnitInput, WorkoutUncheckedCreateWithoutUnitInput>
  }

  export type WorkoutCreateManyUnitInputEnvelope = {
    data: WorkoutCreateManyUnitInput | WorkoutCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutUnitsInput = {
    update: XOR<StudentUpdateWithoutUnitsInput, StudentUncheckedUpdateWithoutUnitsInput>
    create: XOR<StudentCreateWithoutUnitsInput, StudentUncheckedCreateWithoutUnitsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUnitsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUnitsInput, StudentUncheckedUpdateWithoutUnitsInput>
  }

  export type StudentUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type WorkoutUpsertWithWhereUniqueWithoutUnitInput = {
    where: WorkoutWhereUniqueInput
    update: XOR<WorkoutUpdateWithoutUnitInput, WorkoutUncheckedUpdateWithoutUnitInput>
    create: XOR<WorkoutCreateWithoutUnitInput, WorkoutUncheckedCreateWithoutUnitInput>
  }

  export type WorkoutUpdateWithWhereUniqueWithoutUnitInput = {
    where: WorkoutWhereUniqueInput
    data: XOR<WorkoutUpdateWithoutUnitInput, WorkoutUncheckedUpdateWithoutUnitInput>
  }

  export type WorkoutUpdateManyWithWhereWithoutUnitInput = {
    where: WorkoutScalarWhereInput
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyWithoutUnitInput>
  }

  export type WorkoutScalarWhereInput = {
    AND?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
    OR?: WorkoutScalarWhereInput[]
    NOT?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
    id?: StringFilter<"Workout"> | string
    unitId?: StringNullableFilter<"Workout"> | string | null
    title?: StringFilter<"Workout"> | string
    description?: StringNullableFilter<"Workout"> | string | null
    type?: StringFilter<"Workout"> | string
    muscleGroup?: StringFilter<"Workout"> | string
    difficulty?: StringFilter<"Workout"> | string
    xpReward?: IntFilter<"Workout"> | number
    estimatedTime?: IntFilter<"Workout"> | number
    order?: IntFilter<"Workout"> | number
    locked?: BoolFilter<"Workout"> | boolean
    createdAt?: DateTimeFilter<"Workout"> | Date | string
    updatedAt?: DateTimeFilter<"Workout"> | Date | string
  }

  export type UnitCreateWithoutWorkoutsInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUnitsInput
  }

  export type UnitUncheckedCreateWithoutWorkoutsInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateOrConnectWithoutWorkoutsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutWorkoutsInput, UnitUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutExerciseCreateWithoutWorkoutInput = {
    id?: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeExerciseCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutWorkoutInput = {
    id?: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeExerciseUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutExerciseCreateManyWorkoutInputEnvelope = {
    data: WorkoutExerciseCreateManyWorkoutInput | WorkoutExerciseCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutHistoryCreateWithoutWorkoutInput = {
    id?: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutWorkoutsInput
    exercises?: ExerciseLogCreateNestedManyWithoutWorkoutHistoryInput
    records?: PersonalRecordCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryUncheckedCreateWithoutWorkoutInput = {
    id?: string
    studentId: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    exercises?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutHistoryInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutHistoryWhereUniqueInput
    create: XOR<WorkoutHistoryCreateWithoutWorkoutInput, WorkoutHistoryUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutHistoryCreateManyWorkoutInputEnvelope = {
    data: WorkoutHistoryCreateManyWorkoutInput | WorkoutHistoryCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutProgressCreateWithoutWorkoutInput = {
    id?: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutWorkoutProgressInput
  }

  export type WorkoutProgressUncheckedCreateWithoutWorkoutInput = {
    id?: string
    studentId: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutProgressCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutProgressWhereUniqueInput
    create: XOR<WorkoutProgressCreateWithoutWorkoutInput, WorkoutProgressUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutProgressCreateManyWorkoutInputEnvelope = {
    data: WorkoutProgressCreateManyWorkoutInput | WorkoutProgressCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutWorkoutsInput = {
    update: XOR<UnitUpdateWithoutWorkoutsInput, UnitUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<UnitCreateWithoutWorkoutsInput, UnitUncheckedCreateWithoutWorkoutsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutWorkoutsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutWorkoutsInput, UnitUncheckedUpdateWithoutWorkoutsInput>
  }

  export type UnitUpdateWithoutWorkoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateWithoutWorkoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    update: XOR<WorkoutExerciseUpdateWithoutWorkoutInput, WorkoutExerciseUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    data: XOR<WorkoutExerciseUpdateWithoutWorkoutInput, WorkoutExerciseUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutExerciseScalarWhereInput
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type WorkoutExerciseScalarWhereInput = {
    AND?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
    OR?: WorkoutExerciseScalarWhereInput[]
    NOT?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
    id?: StringFilter<"WorkoutExercise"> | string
    workoutId?: StringFilter<"WorkoutExercise"> | string
    name?: StringFilter<"WorkoutExercise"> | string
    sets?: IntFilter<"WorkoutExercise"> | number
    reps?: StringFilter<"WorkoutExercise"> | string
    rest?: IntFilter<"WorkoutExercise"> | number
    notes?: StringNullableFilter<"WorkoutExercise"> | string | null
    videoUrl?: StringNullableFilter<"WorkoutExercise"> | string | null
    educationalId?: StringNullableFilter<"WorkoutExercise"> | string | null
    order?: IntFilter<"WorkoutExercise"> | number
    primaryMuscles?: StringNullableFilter<"WorkoutExercise"> | string | null
    secondaryMuscles?: StringNullableFilter<"WorkoutExercise"> | string | null
    difficulty?: StringNullableFilter<"WorkoutExercise"> | string | null
    equipment?: StringNullableFilter<"WorkoutExercise"> | string | null
    instructions?: StringNullableFilter<"WorkoutExercise"> | string | null
    tips?: StringNullableFilter<"WorkoutExercise"> | string | null
    commonMistakes?: StringNullableFilter<"WorkoutExercise"> | string | null
    benefits?: StringNullableFilter<"WorkoutExercise"> | string | null
    scientificEvidence?: StringNullableFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
  }

  export type WorkoutHistoryUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutHistoryWhereUniqueInput
    update: XOR<WorkoutHistoryUpdateWithoutWorkoutInput, WorkoutHistoryUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutHistoryCreateWithoutWorkoutInput, WorkoutHistoryUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutHistoryUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutHistoryWhereUniqueInput
    data: XOR<WorkoutHistoryUpdateWithoutWorkoutInput, WorkoutHistoryUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutHistoryUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutHistoryScalarWhereInput
    data: XOR<WorkoutHistoryUpdateManyMutationInput, WorkoutHistoryUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type WorkoutProgressUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutProgressWhereUniqueInput
    update: XOR<WorkoutProgressUpdateWithoutWorkoutInput, WorkoutProgressUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutProgressCreateWithoutWorkoutInput, WorkoutProgressUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutProgressUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutProgressWhereUniqueInput
    data: XOR<WorkoutProgressUpdateWithoutWorkoutInput, WorkoutProgressUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutProgressUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutProgressScalarWhereInput
    data: XOR<WorkoutProgressUpdateManyMutationInput, WorkoutProgressUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type WorkoutCreateWithoutExercisesInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit?: UnitCreateNestedOneWithoutWorkoutsInput
    completions?: WorkoutHistoryCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutExercisesInput = {
    id?: string
    unitId?: string | null
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: WorkoutHistoryUncheckedCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutExercisesInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
  }

  export type AlternativeExerciseCreateWithoutWorkoutExerciseInput = {
    id?: string
    name: string
    reason: string
    educationalId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput = {
    id?: string
    name: string
    reason: string
    educationalId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeExerciseCreateOrConnectWithoutWorkoutExerciseInput = {
    where: AlternativeExerciseWhereUniqueInput
    create: XOR<AlternativeExerciseCreateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput>
  }

  export type AlternativeExerciseCreateManyWorkoutExerciseInputEnvelope = {
    data: AlternativeExerciseCreateManyWorkoutExerciseInput | AlternativeExerciseCreateManyWorkoutExerciseInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutUpsertWithoutExercisesInput = {
    update: XOR<WorkoutUpdateWithoutExercisesInput, WorkoutUncheckedUpdateWithoutExercisesInput>
    create: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutExercisesInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutExercisesInput, WorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type WorkoutUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutWorkoutsNestedInput
    completions?: WorkoutHistoryUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: WorkoutHistoryUncheckedUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type AlternativeExerciseUpsertWithWhereUniqueWithoutWorkoutExerciseInput = {
    where: AlternativeExerciseWhereUniqueInput
    update: XOR<AlternativeExerciseUpdateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedUpdateWithoutWorkoutExerciseInput>
    create: XOR<AlternativeExerciseCreateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedCreateWithoutWorkoutExerciseInput>
  }

  export type AlternativeExerciseUpdateWithWhereUniqueWithoutWorkoutExerciseInput = {
    where: AlternativeExerciseWhereUniqueInput
    data: XOR<AlternativeExerciseUpdateWithoutWorkoutExerciseInput, AlternativeExerciseUncheckedUpdateWithoutWorkoutExerciseInput>
  }

  export type AlternativeExerciseUpdateManyWithWhereWithoutWorkoutExerciseInput = {
    where: AlternativeExerciseScalarWhereInput
    data: XOR<AlternativeExerciseUpdateManyMutationInput, AlternativeExerciseUncheckedUpdateManyWithoutWorkoutExerciseInput>
  }

  export type AlternativeExerciseScalarWhereInput = {
    AND?: AlternativeExerciseScalarWhereInput | AlternativeExerciseScalarWhereInput[]
    OR?: AlternativeExerciseScalarWhereInput[]
    NOT?: AlternativeExerciseScalarWhereInput | AlternativeExerciseScalarWhereInput[]
    id?: StringFilter<"AlternativeExercise"> | string
    workoutExerciseId?: StringFilter<"AlternativeExercise"> | string
    name?: StringFilter<"AlternativeExercise"> | string
    reason?: StringFilter<"AlternativeExercise"> | string
    educationalId?: StringNullableFilter<"AlternativeExercise"> | string | null
    order?: IntFilter<"AlternativeExercise"> | number
    createdAt?: DateTimeFilter<"AlternativeExercise"> | Date | string
    updatedAt?: DateTimeFilter<"AlternativeExercise"> | Date | string
  }

  export type WorkoutExerciseCreateWithoutAlternativesInput = {
    id?: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workout: WorkoutCreateNestedOneWithoutExercisesInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutAlternativesInput = {
    id?: string
    workoutId: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutExerciseCreateOrConnectWithoutAlternativesInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutAlternativesInput, WorkoutExerciseUncheckedCreateWithoutAlternativesInput>
  }

  export type WorkoutExerciseUpsertWithoutAlternativesInput = {
    update: XOR<WorkoutExerciseUpdateWithoutAlternativesInput, WorkoutExerciseUncheckedUpdateWithoutAlternativesInput>
    create: XOR<WorkoutExerciseCreateWithoutAlternativesInput, WorkoutExerciseUncheckedCreateWithoutAlternativesInput>
    where?: WorkoutExerciseWhereInput
  }

  export type WorkoutExerciseUpdateToOneWithWhereWithoutAlternativesInput = {
    where?: WorkoutExerciseWhereInput
    data: XOR<WorkoutExerciseUpdateWithoutAlternativesInput, WorkoutExerciseUncheckedUpdateWithoutAlternativesInput>
  }

  export type WorkoutExerciseUpdateWithoutAlternativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutAlternativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutWorkoutProgressInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutWorkoutProgressInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutWorkoutProgressInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutWorkoutProgressInput, StudentUncheckedCreateWithoutWorkoutProgressInput>
  }

  export type WorkoutCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit?: UnitCreateNestedOneWithoutWorkoutsInput
    exercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
    completions?: WorkoutHistoryCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutProgressInput = {
    id?: string
    unitId?: string | null
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    completions?: WorkoutHistoryUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutProgressInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutProgressInput, WorkoutUncheckedCreateWithoutProgressInput>
  }

  export type StudentUpsertWithoutWorkoutProgressInput = {
    update: XOR<StudentUpdateWithoutWorkoutProgressInput, StudentUncheckedUpdateWithoutWorkoutProgressInput>
    create: XOR<StudentCreateWithoutWorkoutProgressInput, StudentUncheckedCreateWithoutWorkoutProgressInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutWorkoutProgressInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutWorkoutProgressInput, StudentUncheckedUpdateWithoutWorkoutProgressInput>
  }

  export type StudentUpdateWithoutWorkoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutWorkoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type WorkoutUpsertWithoutProgressInput = {
    update: XOR<WorkoutUpdateWithoutProgressInput, WorkoutUncheckedUpdateWithoutProgressInput>
    create: XOR<WorkoutCreateWithoutProgressInput, WorkoutUncheckedCreateWithoutProgressInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutProgressInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutProgressInput, WorkoutUncheckedUpdateWithoutProgressInput>
  }

  export type WorkoutUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutWorkoutsNestedInput
    exercises?: WorkoutExerciseUpdateManyWithoutWorkoutNestedInput
    completions?: WorkoutHistoryUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    completions?: WorkoutHistoryUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type StudentCreateWithoutWorkoutsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutWorkoutsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutWorkoutsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutWorkoutsInput, StudentUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutCreateWithoutCompletionsInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit?: UnitCreateNestedOneWithoutWorkoutsInput
    exercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutCompletionsInput = {
    id?: string
    unitId?: string | null
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    progress?: WorkoutProgressUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutCompletionsInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutCompletionsInput, WorkoutUncheckedCreateWithoutCompletionsInput>
  }

  export type ExerciseLogCreateWithoutWorkoutHistoryInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes?: string | null
    formCheckScore?: number | null
    difficulty?: string | null
  }

  export type ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes?: string | null
    formCheckScore?: number | null
    difficulty?: string | null
  }

  export type ExerciseLogCreateOrConnectWithoutWorkoutHistoryInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutWorkoutHistoryInput, ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput>
  }

  export type ExerciseLogCreateManyWorkoutHistoryInputEnvelope = {
    data: ExerciseLogCreateManyWorkoutHistoryInput | ExerciseLogCreateManyWorkoutHistoryInput[]
    skipDuplicates?: boolean
  }

  export type PersonalRecordCreateWithoutWorkoutHistoryInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
    student: StudentCreateNestedOneWithoutRecordsInput
  }

  export type PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput = {
    id?: string
    studentId: string
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
  }

  export type PersonalRecordCreateOrConnectWithoutWorkoutHistoryInput = {
    where: PersonalRecordWhereUniqueInput
    create: XOR<PersonalRecordCreateWithoutWorkoutHistoryInput, PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput>
  }

  export type PersonalRecordCreateManyWorkoutHistoryInputEnvelope = {
    data: PersonalRecordCreateManyWorkoutHistoryInput | PersonalRecordCreateManyWorkoutHistoryInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutWorkoutsInput = {
    update: XOR<StudentUpdateWithoutWorkoutsInput, StudentUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<StudentCreateWithoutWorkoutsInput, StudentUncheckedCreateWithoutWorkoutsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutWorkoutsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutWorkoutsInput, StudentUncheckedUpdateWithoutWorkoutsInput>
  }

  export type StudentUpdateWithoutWorkoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutWorkoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type WorkoutUpsertWithoutCompletionsInput = {
    update: XOR<WorkoutUpdateWithoutCompletionsInput, WorkoutUncheckedUpdateWithoutCompletionsInput>
    create: XOR<WorkoutCreateWithoutCompletionsInput, WorkoutUncheckedCreateWithoutCompletionsInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutCompletionsInput, WorkoutUncheckedUpdateWithoutCompletionsInput>
  }

  export type WorkoutUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutWorkoutsNestedInput
    exercises?: WorkoutExerciseUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type ExerciseLogUpsertWithWhereUniqueWithoutWorkoutHistoryInput = {
    where: ExerciseLogWhereUniqueInput
    update: XOR<ExerciseLogUpdateWithoutWorkoutHistoryInput, ExerciseLogUncheckedUpdateWithoutWorkoutHistoryInput>
    create: XOR<ExerciseLogCreateWithoutWorkoutHistoryInput, ExerciseLogUncheckedCreateWithoutWorkoutHistoryInput>
  }

  export type ExerciseLogUpdateWithWhereUniqueWithoutWorkoutHistoryInput = {
    where: ExerciseLogWhereUniqueInput
    data: XOR<ExerciseLogUpdateWithoutWorkoutHistoryInput, ExerciseLogUncheckedUpdateWithoutWorkoutHistoryInput>
  }

  export type ExerciseLogUpdateManyWithWhereWithoutWorkoutHistoryInput = {
    where: ExerciseLogScalarWhereInput
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryInput>
  }

  export type ExerciseLogScalarWhereInput = {
    AND?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
    OR?: ExerciseLogScalarWhereInput[]
    NOT?: ExerciseLogScalarWhereInput | ExerciseLogScalarWhereInput[]
    id?: StringFilter<"ExerciseLog"> | string
    workoutHistoryId?: StringFilter<"ExerciseLog"> | string
    exerciseId?: StringFilter<"ExerciseLog"> | string
    exerciseName?: StringFilter<"ExerciseLog"> | string
    sets?: StringFilter<"ExerciseLog"> | string
    notes?: StringNullableFilter<"ExerciseLog"> | string | null
    formCheckScore?: IntNullableFilter<"ExerciseLog"> | number | null
    difficulty?: StringNullableFilter<"ExerciseLog"> | string | null
  }

  export type PersonalRecordUpsertWithWhereUniqueWithoutWorkoutHistoryInput = {
    where: PersonalRecordWhereUniqueInput
    update: XOR<PersonalRecordUpdateWithoutWorkoutHistoryInput, PersonalRecordUncheckedUpdateWithoutWorkoutHistoryInput>
    create: XOR<PersonalRecordCreateWithoutWorkoutHistoryInput, PersonalRecordUncheckedCreateWithoutWorkoutHistoryInput>
  }

  export type PersonalRecordUpdateWithWhereUniqueWithoutWorkoutHistoryInput = {
    where: PersonalRecordWhereUniqueInput
    data: XOR<PersonalRecordUpdateWithoutWorkoutHistoryInput, PersonalRecordUncheckedUpdateWithoutWorkoutHistoryInput>
  }

  export type PersonalRecordUpdateManyWithWhereWithoutWorkoutHistoryInput = {
    where: PersonalRecordScalarWhereInput
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryInput>
  }

  export type WorkoutHistoryCreateWithoutExercisesInput = {
    id?: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutWorkoutsInput
    workout?: WorkoutCreateNestedOneWithoutCompletionsInput
    records?: PersonalRecordCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryUncheckedCreateWithoutExercisesInput = {
    id?: string
    studentId: string
    workoutId?: string | null
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    records?: PersonalRecordUncheckedCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryCreateOrConnectWithoutExercisesInput = {
    where: WorkoutHistoryWhereUniqueInput
    create: XOR<WorkoutHistoryCreateWithoutExercisesInput, WorkoutHistoryUncheckedCreateWithoutExercisesInput>
  }

  export type WorkoutHistoryUpsertWithoutExercisesInput = {
    update: XOR<WorkoutHistoryUpdateWithoutExercisesInput, WorkoutHistoryUncheckedUpdateWithoutExercisesInput>
    create: XOR<WorkoutHistoryCreateWithoutExercisesInput, WorkoutHistoryUncheckedCreateWithoutExercisesInput>
    where?: WorkoutHistoryWhereInput
  }

  export type WorkoutHistoryUpdateToOneWithWhereWithoutExercisesInput = {
    where?: WorkoutHistoryWhereInput
    data: XOR<WorkoutHistoryUpdateWithoutExercisesInput, WorkoutHistoryUncheckedUpdateWithoutExercisesInput>
  }

  export type WorkoutHistoryUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWorkoutsNestedInput
    workout?: WorkoutUpdateOneWithoutCompletionsNestedInput
    records?: PersonalRecordUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type StudentCreateWithoutRecordsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutRecordsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutRecordsInput, StudentUncheckedCreateWithoutRecordsInput>
  }

  export type WorkoutHistoryCreateWithoutRecordsInput = {
    id?: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutWorkoutsInput
    workout?: WorkoutCreateNestedOneWithoutCompletionsInput
    exercises?: ExerciseLogCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryUncheckedCreateWithoutRecordsInput = {
    id?: string
    studentId: string
    workoutId?: string | null
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
    exercises?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutHistoryInput
  }

  export type WorkoutHistoryCreateOrConnectWithoutRecordsInput = {
    where: WorkoutHistoryWhereUniqueInput
    create: XOR<WorkoutHistoryCreateWithoutRecordsInput, WorkoutHistoryUncheckedCreateWithoutRecordsInput>
  }

  export type StudentUpsertWithoutRecordsInput = {
    update: XOR<StudentUpdateWithoutRecordsInput, StudentUncheckedUpdateWithoutRecordsInput>
    create: XOR<StudentCreateWithoutRecordsInput, StudentUncheckedCreateWithoutRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutRecordsInput, StudentUncheckedUpdateWithoutRecordsInput>
  }

  export type StudentUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type WorkoutHistoryUpsertWithoutRecordsInput = {
    update: XOR<WorkoutHistoryUpdateWithoutRecordsInput, WorkoutHistoryUncheckedUpdateWithoutRecordsInput>
    create: XOR<WorkoutHistoryCreateWithoutRecordsInput, WorkoutHistoryUncheckedCreateWithoutRecordsInput>
    where?: WorkoutHistoryWhereInput
  }

  export type WorkoutHistoryUpdateToOneWithWhereWithoutRecordsInput = {
    where?: WorkoutHistoryWhereInput
    data: XOR<WorkoutHistoryUpdateWithoutRecordsInput, WorkoutHistoryUncheckedUpdateWithoutRecordsInput>
  }

  export type WorkoutHistoryUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWorkoutsNestedInput
    workout?: WorkoutUpdateOneWithoutCompletionsNestedInput
    exercises?: ExerciseLogUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type MealCreateWithoutDietPlanInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    image?: string | null
    ingredients?: string | null
    order?: number
  }

  export type MealUncheckedCreateWithoutDietPlanInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    image?: string | null
    ingredients?: string | null
    order?: number
  }

  export type MealCreateOrConnectWithoutDietPlanInput = {
    where: MealWhereUniqueInput
    create: XOR<MealCreateWithoutDietPlanInput, MealUncheckedCreateWithoutDietPlanInput>
  }

  export type MealCreateManyDietPlanInputEnvelope = {
    data: MealCreateManyDietPlanInput | MealCreateManyDietPlanInput[]
    skipDuplicates?: boolean
  }

  export type DietPlanCompletionCreateWithoutDietPlanInput = {
    id?: string
    date?: Date | string
    completed?: boolean
    student: StudentCreateNestedOneWithoutDietsInput
  }

  export type DietPlanCompletionUncheckedCreateWithoutDietPlanInput = {
    id?: string
    studentId: string
    date?: Date | string
    completed?: boolean
  }

  export type DietPlanCompletionCreateOrConnectWithoutDietPlanInput = {
    where: DietPlanCompletionWhereUniqueInput
    create: XOR<DietPlanCompletionCreateWithoutDietPlanInput, DietPlanCompletionUncheckedCreateWithoutDietPlanInput>
  }

  export type DietPlanCompletionCreateManyDietPlanInputEnvelope = {
    data: DietPlanCompletionCreateManyDietPlanInput | DietPlanCompletionCreateManyDietPlanInput[]
    skipDuplicates?: boolean
  }

  export type MealUpsertWithWhereUniqueWithoutDietPlanInput = {
    where: MealWhereUniqueInput
    update: XOR<MealUpdateWithoutDietPlanInput, MealUncheckedUpdateWithoutDietPlanInput>
    create: XOR<MealCreateWithoutDietPlanInput, MealUncheckedCreateWithoutDietPlanInput>
  }

  export type MealUpdateWithWhereUniqueWithoutDietPlanInput = {
    where: MealWhereUniqueInput
    data: XOR<MealUpdateWithoutDietPlanInput, MealUncheckedUpdateWithoutDietPlanInput>
  }

  export type MealUpdateManyWithWhereWithoutDietPlanInput = {
    where: MealScalarWhereInput
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyWithoutDietPlanInput>
  }

  export type MealScalarWhereInput = {
    AND?: MealScalarWhereInput | MealScalarWhereInput[]
    OR?: MealScalarWhereInput[]
    NOT?: MealScalarWhereInput | MealScalarWhereInput[]
    id?: StringFilter<"Meal"> | string
    dietPlanId?: StringFilter<"Meal"> | string
    name?: StringFilter<"Meal"> | string
    type?: StringFilter<"Meal"> | string
    calories?: IntFilter<"Meal"> | number
    protein?: FloatFilter<"Meal"> | number
    carbs?: FloatFilter<"Meal"> | number
    fats?: FloatFilter<"Meal"> | number
    time?: StringNullableFilter<"Meal"> | string | null
    image?: StringNullableFilter<"Meal"> | string | null
    ingredients?: StringNullableFilter<"Meal"> | string | null
    order?: IntFilter<"Meal"> | number
  }

  export type DietPlanCompletionUpsertWithWhereUniqueWithoutDietPlanInput = {
    where: DietPlanCompletionWhereUniqueInput
    update: XOR<DietPlanCompletionUpdateWithoutDietPlanInput, DietPlanCompletionUncheckedUpdateWithoutDietPlanInput>
    create: XOR<DietPlanCompletionCreateWithoutDietPlanInput, DietPlanCompletionUncheckedCreateWithoutDietPlanInput>
  }

  export type DietPlanCompletionUpdateWithWhereUniqueWithoutDietPlanInput = {
    where: DietPlanCompletionWhereUniqueInput
    data: XOR<DietPlanCompletionUpdateWithoutDietPlanInput, DietPlanCompletionUncheckedUpdateWithoutDietPlanInput>
  }

  export type DietPlanCompletionUpdateManyWithWhereWithoutDietPlanInput = {
    where: DietPlanCompletionScalarWhereInput
    data: XOR<DietPlanCompletionUpdateManyMutationInput, DietPlanCompletionUncheckedUpdateManyWithoutDietPlanInput>
  }

  export type DietPlanCreateWithoutMealsInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: DietPlanCompletionCreateNestedManyWithoutDietPlanInput
  }

  export type DietPlanUncheckedCreateWithoutMealsInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: DietPlanCompletionUncheckedCreateNestedManyWithoutDietPlanInput
  }

  export type DietPlanCreateOrConnectWithoutMealsInput = {
    where: DietPlanWhereUniqueInput
    create: XOR<DietPlanCreateWithoutMealsInput, DietPlanUncheckedCreateWithoutMealsInput>
  }

  export type DietPlanUpsertWithoutMealsInput = {
    update: XOR<DietPlanUpdateWithoutMealsInput, DietPlanUncheckedUpdateWithoutMealsInput>
    create: XOR<DietPlanCreateWithoutMealsInput, DietPlanUncheckedCreateWithoutMealsInput>
    where?: DietPlanWhereInput
  }

  export type DietPlanUpdateToOneWithWhereWithoutMealsInput = {
    where?: DietPlanWhereInput
    data: XOR<DietPlanUpdateWithoutMealsInput, DietPlanUncheckedUpdateWithoutMealsInput>
  }

  export type DietPlanUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: DietPlanCompletionUpdateManyWithoutDietPlanNestedInput
  }

  export type DietPlanUncheckedUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: DietPlanCompletionUncheckedUpdateManyWithoutDietPlanNestedInput
  }

  export type StudentCreateWithoutDietsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDietsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDietsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDietsInput, StudentUncheckedCreateWithoutDietsInput>
  }

  export type DietPlanCreateWithoutCompletionsInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealCreateNestedManyWithoutDietPlanInput
  }

  export type DietPlanUncheckedCreateWithoutCompletionsInput = {
    id?: string
    title: string
    description?: string | null
    totalCalories: number
    targetProtein: number
    targetCarbs: number
    targetFats: number
    xpReward?: number
    locked?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealUncheckedCreateNestedManyWithoutDietPlanInput
  }

  export type DietPlanCreateOrConnectWithoutCompletionsInput = {
    where: DietPlanWhereUniqueInput
    create: XOR<DietPlanCreateWithoutCompletionsInput, DietPlanUncheckedCreateWithoutCompletionsInput>
  }

  export type StudentUpsertWithoutDietsInput = {
    update: XOR<StudentUpdateWithoutDietsInput, StudentUncheckedUpdateWithoutDietsInput>
    create: XOR<StudentCreateWithoutDietsInput, StudentUncheckedCreateWithoutDietsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutDietsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutDietsInput, StudentUncheckedUpdateWithoutDietsInput>
  }

  export type StudentUpdateWithoutDietsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDietsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type DietPlanUpsertWithoutCompletionsInput = {
    update: XOR<DietPlanUpdateWithoutCompletionsInput, DietPlanUncheckedUpdateWithoutCompletionsInput>
    create: XOR<DietPlanCreateWithoutCompletionsInput, DietPlanUncheckedCreateWithoutCompletionsInput>
    where?: DietPlanWhereInput
  }

  export type DietPlanUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: DietPlanWhereInput
    data: XOR<DietPlanUpdateWithoutCompletionsInput, DietPlanUncheckedUpdateWithoutCompletionsInput>
  }

  export type DietPlanUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealUpdateManyWithoutDietPlanNestedInput
  }

  export type DietPlanUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalCalories?: IntFieldUpdateOperationsInput | number
    targetProtein?: FloatFieldUpdateOperationsInput | number
    targetCarbs?: FloatFieldUpdateOperationsInput | number
    targetFats?: FloatFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealUncheckedUpdateManyWithoutDietPlanNestedInput
  }

  export type StudentCreateWithoutDailyNutritionInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDailyNutritionInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDailyNutritionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDailyNutritionInput, StudentUncheckedCreateWithoutDailyNutritionInput>
  }

  export type NutritionMealCreateWithoutDailyNutritionInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foods?: NutritionFoodItemCreateNestedManyWithoutNutritionMealInput
  }

  export type NutritionMealUncheckedCreateWithoutDailyNutritionInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foods?: NutritionFoodItemUncheckedCreateNestedManyWithoutNutritionMealInput
  }

  export type NutritionMealCreateOrConnectWithoutDailyNutritionInput = {
    where: NutritionMealWhereUniqueInput
    create: XOR<NutritionMealCreateWithoutDailyNutritionInput, NutritionMealUncheckedCreateWithoutDailyNutritionInput>
  }

  export type NutritionMealCreateManyDailyNutritionInputEnvelope = {
    data: NutritionMealCreateManyDailyNutritionInput | NutritionMealCreateManyDailyNutritionInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutDailyNutritionInput = {
    update: XOR<StudentUpdateWithoutDailyNutritionInput, StudentUncheckedUpdateWithoutDailyNutritionInput>
    create: XOR<StudentCreateWithoutDailyNutritionInput, StudentUncheckedCreateWithoutDailyNutritionInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutDailyNutritionInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutDailyNutritionInput, StudentUncheckedUpdateWithoutDailyNutritionInput>
  }

  export type StudentUpdateWithoutDailyNutritionInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDailyNutritionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type NutritionMealUpsertWithWhereUniqueWithoutDailyNutritionInput = {
    where: NutritionMealWhereUniqueInput
    update: XOR<NutritionMealUpdateWithoutDailyNutritionInput, NutritionMealUncheckedUpdateWithoutDailyNutritionInput>
    create: XOR<NutritionMealCreateWithoutDailyNutritionInput, NutritionMealUncheckedCreateWithoutDailyNutritionInput>
  }

  export type NutritionMealUpdateWithWhereUniqueWithoutDailyNutritionInput = {
    where: NutritionMealWhereUniqueInput
    data: XOR<NutritionMealUpdateWithoutDailyNutritionInput, NutritionMealUncheckedUpdateWithoutDailyNutritionInput>
  }

  export type NutritionMealUpdateManyWithWhereWithoutDailyNutritionInput = {
    where: NutritionMealScalarWhereInput
    data: XOR<NutritionMealUpdateManyMutationInput, NutritionMealUncheckedUpdateManyWithoutDailyNutritionInput>
  }

  export type NutritionMealScalarWhereInput = {
    AND?: NutritionMealScalarWhereInput | NutritionMealScalarWhereInput[]
    OR?: NutritionMealScalarWhereInput[]
    NOT?: NutritionMealScalarWhereInput | NutritionMealScalarWhereInput[]
    id?: StringFilter<"NutritionMeal"> | string
    dailyNutritionId?: StringFilter<"NutritionMeal"> | string
    name?: StringFilter<"NutritionMeal"> | string
    type?: StringFilter<"NutritionMeal"> | string
    calories?: IntFilter<"NutritionMeal"> | number
    protein?: FloatFilter<"NutritionMeal"> | number
    carbs?: FloatFilter<"NutritionMeal"> | number
    fats?: FloatFilter<"NutritionMeal"> | number
    time?: StringNullableFilter<"NutritionMeal"> | string | null
    completed?: BoolFilter<"NutritionMeal"> | boolean
    order?: IntFilter<"NutritionMeal"> | number
    createdAt?: DateTimeFilter<"NutritionMeal"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionMeal"> | Date | string
  }

  export type DailyNutritionCreateWithoutMealsInput = {
    id?: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutDailyNutritionInput
  }

  export type DailyNutritionUncheckedCreateWithoutMealsInput = {
    id?: string
    studentId: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyNutritionCreateOrConnectWithoutMealsInput = {
    where: DailyNutritionWhereUniqueInput
    create: XOR<DailyNutritionCreateWithoutMealsInput, DailyNutritionUncheckedCreateWithoutMealsInput>
  }

  export type NutritionFoodItemCreateWithoutNutritionMealInput = {
    id?: string
    foodId?: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt?: Date | string
  }

  export type NutritionFoodItemUncheckedCreateWithoutNutritionMealInput = {
    id?: string
    foodId?: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt?: Date | string
  }

  export type NutritionFoodItemCreateOrConnectWithoutNutritionMealInput = {
    where: NutritionFoodItemWhereUniqueInput
    create: XOR<NutritionFoodItemCreateWithoutNutritionMealInput, NutritionFoodItemUncheckedCreateWithoutNutritionMealInput>
  }

  export type NutritionFoodItemCreateManyNutritionMealInputEnvelope = {
    data: NutritionFoodItemCreateManyNutritionMealInput | NutritionFoodItemCreateManyNutritionMealInput[]
    skipDuplicates?: boolean
  }

  export type DailyNutritionUpsertWithoutMealsInput = {
    update: XOR<DailyNutritionUpdateWithoutMealsInput, DailyNutritionUncheckedUpdateWithoutMealsInput>
    create: XOR<DailyNutritionCreateWithoutMealsInput, DailyNutritionUncheckedCreateWithoutMealsInput>
    where?: DailyNutritionWhereInput
  }

  export type DailyNutritionUpdateToOneWithWhereWithoutMealsInput = {
    where?: DailyNutritionWhereInput
    data: XOR<DailyNutritionUpdateWithoutMealsInput, DailyNutritionUncheckedUpdateWithoutMealsInput>
  }

  export type DailyNutritionUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutDailyNutritionNestedInput
  }

  export type DailyNutritionUncheckedUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemUpsertWithWhereUniqueWithoutNutritionMealInput = {
    where: NutritionFoodItemWhereUniqueInput
    update: XOR<NutritionFoodItemUpdateWithoutNutritionMealInput, NutritionFoodItemUncheckedUpdateWithoutNutritionMealInput>
    create: XOR<NutritionFoodItemCreateWithoutNutritionMealInput, NutritionFoodItemUncheckedCreateWithoutNutritionMealInput>
  }

  export type NutritionFoodItemUpdateWithWhereUniqueWithoutNutritionMealInput = {
    where: NutritionFoodItemWhereUniqueInput
    data: XOR<NutritionFoodItemUpdateWithoutNutritionMealInput, NutritionFoodItemUncheckedUpdateWithoutNutritionMealInput>
  }

  export type NutritionFoodItemUpdateManyWithWhereWithoutNutritionMealInput = {
    where: NutritionFoodItemScalarWhereInput
    data: XOR<NutritionFoodItemUpdateManyMutationInput, NutritionFoodItemUncheckedUpdateManyWithoutNutritionMealInput>
  }

  export type NutritionFoodItemScalarWhereInput = {
    AND?: NutritionFoodItemScalarWhereInput | NutritionFoodItemScalarWhereInput[]
    OR?: NutritionFoodItemScalarWhereInput[]
    NOT?: NutritionFoodItemScalarWhereInput | NutritionFoodItemScalarWhereInput[]
    id?: StringFilter<"NutritionFoodItem"> | string
    nutritionMealId?: StringFilter<"NutritionFoodItem"> | string
    foodId?: StringNullableFilter<"NutritionFoodItem"> | string | null
    foodName?: StringFilter<"NutritionFoodItem"> | string
    servings?: FloatFilter<"NutritionFoodItem"> | number
    calories?: IntFilter<"NutritionFoodItem"> | number
    protein?: FloatFilter<"NutritionFoodItem"> | number
    carbs?: FloatFilter<"NutritionFoodItem"> | number
    fats?: FloatFilter<"NutritionFoodItem"> | number
    servingSize?: StringFilter<"NutritionFoodItem"> | string
    createdAt?: DateTimeFilter<"NutritionFoodItem"> | Date | string
  }

  export type NutritionMealCreateWithoutFoodsInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dailyNutrition: DailyNutritionCreateNestedOneWithoutMealsInput
  }

  export type NutritionMealUncheckedCreateWithoutFoodsInput = {
    id?: string
    dailyNutritionId: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionMealCreateOrConnectWithoutFoodsInput = {
    where: NutritionMealWhereUniqueInput
    create: XOR<NutritionMealCreateWithoutFoodsInput, NutritionMealUncheckedCreateWithoutFoodsInput>
  }

  export type NutritionMealUpsertWithoutFoodsInput = {
    update: XOR<NutritionMealUpdateWithoutFoodsInput, NutritionMealUncheckedUpdateWithoutFoodsInput>
    create: XOR<NutritionMealCreateWithoutFoodsInput, NutritionMealUncheckedCreateWithoutFoodsInput>
    where?: NutritionMealWhereInput
  }

  export type NutritionMealUpdateToOneWithWhereWithoutFoodsInput = {
    where?: NutritionMealWhereInput
    data: XOR<NutritionMealUpdateWithoutFoodsInput, NutritionMealUncheckedUpdateWithoutFoodsInput>
  }

  export type NutritionMealUpdateWithoutFoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyNutrition?: DailyNutritionUpdateOneRequiredWithoutMealsNestedInput
  }

  export type NutritionMealUncheckedUpdateWithoutFoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dailyNutritionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutNutritionChatUsageInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutNutritionChatUsageInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutNutritionChatUsageInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNutritionChatUsageInput, StudentUncheckedCreateWithoutNutritionChatUsageInput>
  }

  export type StudentUpsertWithoutNutritionChatUsageInput = {
    update: XOR<StudentUpdateWithoutNutritionChatUsageInput, StudentUncheckedUpdateWithoutNutritionChatUsageInput>
    create: XOR<StudentCreateWithoutNutritionChatUsageInput, StudentUncheckedCreateWithoutNutritionChatUsageInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutNutritionChatUsageInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutNutritionChatUsageInput, StudentUncheckedUpdateWithoutNutritionChatUsageInput>
  }

  export type StudentUpdateWithoutNutritionChatUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutNutritionChatUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type AchievementUnlockCreateWithoutAchievementInput = {
    id?: string
    progress?: number | null
    unlockedAt?: Date | string
    student: StudentCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUnlockUncheckedCreateWithoutAchievementInput = {
    id?: string
    studentId: string
    progress?: number | null
    unlockedAt?: Date | string
  }

  export type AchievementUnlockCreateOrConnectWithoutAchievementInput = {
    where: AchievementUnlockWhereUniqueInput
    create: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput>
  }

  export type AchievementUnlockCreateManyAchievementInputEnvelope = {
    data: AchievementUnlockCreateManyAchievementInput | AchievementUnlockCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type AchievementUnlockUpsertWithWhereUniqueWithoutAchievementInput = {
    where: AchievementUnlockWhereUniqueInput
    update: XOR<AchievementUnlockUpdateWithoutAchievementInput, AchievementUnlockUncheckedUpdateWithoutAchievementInput>
    create: XOR<AchievementUnlockCreateWithoutAchievementInput, AchievementUnlockUncheckedCreateWithoutAchievementInput>
  }

  export type AchievementUnlockUpdateWithWhereUniqueWithoutAchievementInput = {
    where: AchievementUnlockWhereUniqueInput
    data: XOR<AchievementUnlockUpdateWithoutAchievementInput, AchievementUnlockUncheckedUpdateWithoutAchievementInput>
  }

  export type AchievementUnlockUpdateManyWithWhereWithoutAchievementInput = {
    where: AchievementUnlockScalarWhereInput
    data: XOR<AchievementUnlockUpdateManyMutationInput, AchievementUnlockUncheckedUpdateManyWithoutAchievementInput>
  }

  export type StudentCreateWithoutAchievementsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAchievementsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUnlocksInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    category: string
    level?: number | null
    color?: string | null
    target?: number | null
    xpReward?: number
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUnlocksInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    category: string
    level?: number | null
    color?: string | null
    target?: number | null
    xpReward?: number
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUnlocksInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
  }

  export type StudentUpsertWithoutAchievementsInput = {
    update: XOR<StudentUpdateWithoutAchievementsInput, StudentUncheckedUpdateWithoutAchievementsInput>
    create: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAchievementsInput, StudentUncheckedUpdateWithoutAchievementsInput>
  }

  export type StudentUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type AchievementUpsertWithoutUnlocksInput = {
    update: XOR<AchievementUpdateWithoutUnlocksInput, AchievementUncheckedUpdateWithoutUnlocksInput>
    create: XOR<AchievementCreateWithoutUnlocksInput, AchievementUncheckedCreateWithoutUnlocksInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUnlocksInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUnlocksInput, AchievementUncheckedUpdateWithoutUnlocksInput>
  }

  export type AchievementUpdateWithoutUnlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    xpReward?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUnlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    xpReward?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutGymPreferenceInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentCreateNestedOneWithoutUserInput
    gyms?: GymCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGymPreferenceInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    gyms?: GymUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGymPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGymPreferenceInput, UserUncheckedCreateWithoutGymPreferenceInput>
  }

  export type UserUpsertWithoutGymPreferenceInput = {
    update: XOR<UserUpdateWithoutGymPreferenceInput, UserUncheckedUpdateWithoutGymPreferenceInput>
    create: XOR<UserCreateWithoutGymPreferenceInput, UserUncheckedCreateWithoutGymPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGymPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGymPreferenceInput, UserUncheckedUpdateWithoutGymPreferenceInput>
  }

  export type UserUpdateWithoutGymPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutUserNestedInput
    gyms?: GymUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGymPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    gyms?: GymUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GymCreateWithoutStudentsInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutStudentsInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutStudentsInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutStudentsInput, GymUncheckedCreateWithoutStudentsInput>
  }

  export type StudentCreateWithoutMembershipsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMembershipsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMembershipsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMembershipsInput, StudentUncheckedCreateWithoutMembershipsInput>
  }

  export type MembershipPlanCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutPlansInput
    payments?: PaymentCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUncheckedCreateWithoutMembershipsInput = {
    id?: string
    gymId: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanCreateOrConnectWithoutMembershipsInput = {
    where: MembershipPlanWhereUniqueInput
    create: XOR<MembershipPlanCreateWithoutMembershipsInput, MembershipPlanUncheckedCreateWithoutMembershipsInput>
  }

  export type GymUpsertWithoutStudentsInput = {
    update: XOR<GymUpdateWithoutStudentsInput, GymUncheckedUpdateWithoutStudentsInput>
    create: XOR<GymCreateWithoutStudentsInput, GymUncheckedCreateWithoutStudentsInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutStudentsInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutStudentsInput, GymUncheckedUpdateWithoutStudentsInput>
  }

  export type GymUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type StudentUpsertWithoutMembershipsInput = {
    update: XOR<StudentUpdateWithoutMembershipsInput, StudentUncheckedUpdateWithoutMembershipsInput>
    create: XOR<StudentCreateWithoutMembershipsInput, StudentUncheckedCreateWithoutMembershipsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMembershipsInput, StudentUncheckedUpdateWithoutMembershipsInput>
  }

  export type StudentUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type MembershipPlanUpsertWithoutMembershipsInput = {
    update: XOR<MembershipPlanUpdateWithoutMembershipsInput, MembershipPlanUncheckedUpdateWithoutMembershipsInput>
    create: XOR<MembershipPlanCreateWithoutMembershipsInput, MembershipPlanUncheckedCreateWithoutMembershipsInput>
    where?: MembershipPlanWhereInput
  }

  export type MembershipPlanUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: MembershipPlanWhereInput
    data: XOR<MembershipPlanUpdateWithoutMembershipsInput, MembershipPlanUncheckedUpdateWithoutMembershipsInput>
  }

  export type MembershipPlanUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutPlansNestedInput
    payments?: PaymentUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type GymCreateWithoutPlansInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutPlansInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutPlansInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutPlansInput, GymUncheckedCreateWithoutPlansInput>
  }

  export type GymMembershipCreateWithoutPlanInput = {
    id?: string
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutStudentsInput
    student: StudentCreateNestedOneWithoutMembershipsInput
  }

  export type GymMembershipUncheckedCreateWithoutPlanInput = {
    id?: string
    gymId: string
    studentId: string
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipCreateOrConnectWithoutPlanInput = {
    where: GymMembershipWhereUniqueInput
    create: XOR<GymMembershipCreateWithoutPlanInput, GymMembershipUncheckedCreateWithoutPlanInput>
  }

  export type GymMembershipCreateManyPlanInputEnvelope = {
    data: GymMembershipCreateManyPlanInput | GymMembershipCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPlanInput = {
    id?: string
    studentId: string
    studentName: string
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPlanInput = {
    id?: string
    gymId: string
    studentId: string
    studentName: string
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPlanInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPlanInput, PaymentUncheckedCreateWithoutPlanInput>
  }

  export type PaymentCreateManyPlanInputEnvelope = {
    data: PaymentCreateManyPlanInput | PaymentCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type GymUpsertWithoutPlansInput = {
    update: XOR<GymUpdateWithoutPlansInput, GymUncheckedUpdateWithoutPlansInput>
    create: XOR<GymCreateWithoutPlansInput, GymUncheckedCreateWithoutPlansInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutPlansInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutPlansInput, GymUncheckedUpdateWithoutPlansInput>
  }

  export type GymUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type GymMembershipUpsertWithWhereUniqueWithoutPlanInput = {
    where: GymMembershipWhereUniqueInput
    update: XOR<GymMembershipUpdateWithoutPlanInput, GymMembershipUncheckedUpdateWithoutPlanInput>
    create: XOR<GymMembershipCreateWithoutPlanInput, GymMembershipUncheckedCreateWithoutPlanInput>
  }

  export type GymMembershipUpdateWithWhereUniqueWithoutPlanInput = {
    where: GymMembershipWhereUniqueInput
    data: XOR<GymMembershipUpdateWithoutPlanInput, GymMembershipUncheckedUpdateWithoutPlanInput>
  }

  export type GymMembershipUpdateManyWithWhereWithoutPlanInput = {
    where: GymMembershipScalarWhereInput
    data: XOR<GymMembershipUpdateManyMutationInput, GymMembershipUncheckedUpdateManyWithoutPlanInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutPlanInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPlanInput, PaymentUncheckedUpdateWithoutPlanInput>
    create: XOR<PaymentCreateWithoutPlanInput, PaymentUncheckedCreateWithoutPlanInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPlanInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPlanInput, PaymentUncheckedUpdateWithoutPlanInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPlanInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPlanInput>
  }

  export type StudentCreateWithoutDayPassesInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDayPassesInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDayPassesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDayPassesInput, StudentUncheckedCreateWithoutDayPassesInput>
  }

  export type StudentUpsertWithoutDayPassesInput = {
    update: XOR<StudentUpdateWithoutDayPassesInput, StudentUncheckedUpdateWithoutDayPassesInput>
    create: XOR<StudentCreateWithoutDayPassesInput, StudentUncheckedCreateWithoutDayPassesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutDayPassesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutDayPassesInput, StudentUncheckedUpdateWithoutDayPassesInput>
  }

  export type StudentUpdateWithoutDayPassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDayPassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type GymCreateWithoutCheckInsInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutCheckInsInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutCheckInsInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutCheckInsInput, GymUncheckedCreateWithoutCheckInsInput>
  }

  export type GymUpsertWithoutCheckInsInput = {
    update: XOR<GymUpdateWithoutCheckInsInput, GymUncheckedUpdateWithoutCheckInsInput>
    create: XOR<GymCreateWithoutCheckInsInput, GymUncheckedCreateWithoutCheckInsInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutCheckInsInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutCheckInsInput, GymUncheckedUpdateWithoutCheckInsInput>
  }

  export type GymUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type GymCreateWithoutEquipmentInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutEquipmentInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutEquipmentInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutEquipmentInput, GymUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceRecordCreateWithoutEquipmentInput = {
    id?: string
    date?: Date | string
    type: string
    description?: string | null
    performedBy?: string | null
    cost?: number | null
    nextScheduled?: Date | string | null
  }

  export type MaintenanceRecordUncheckedCreateWithoutEquipmentInput = {
    id?: string
    date?: Date | string
    type: string
    description?: string | null
    performedBy?: string | null
    cost?: number | null
    nextScheduled?: Date | string | null
  }

  export type MaintenanceRecordCreateOrConnectWithoutEquipmentInput = {
    where: MaintenanceRecordWhereUniqueInput
    create: XOR<MaintenanceRecordCreateWithoutEquipmentInput, MaintenanceRecordUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceRecordCreateManyEquipmentInputEnvelope = {
    data: MaintenanceRecordCreateManyEquipmentInput | MaintenanceRecordCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type GymUpsertWithoutEquipmentInput = {
    update: XOR<GymUpdateWithoutEquipmentInput, GymUncheckedUpdateWithoutEquipmentInput>
    create: XOR<GymCreateWithoutEquipmentInput, GymUncheckedCreateWithoutEquipmentInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutEquipmentInput, GymUncheckedUpdateWithoutEquipmentInput>
  }

  export type GymUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type MaintenanceRecordUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceRecordWhereUniqueInput
    update: XOR<MaintenanceRecordUpdateWithoutEquipmentInput, MaintenanceRecordUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MaintenanceRecordCreateWithoutEquipmentInput, MaintenanceRecordUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceRecordUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceRecordWhereUniqueInput
    data: XOR<MaintenanceRecordUpdateWithoutEquipmentInput, MaintenanceRecordUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceRecordUpdateManyWithWhereWithoutEquipmentInput = {
    where: MaintenanceRecordScalarWhereInput
    data: XOR<MaintenanceRecordUpdateManyMutationInput, MaintenanceRecordUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type MaintenanceRecordScalarWhereInput = {
    AND?: MaintenanceRecordScalarWhereInput | MaintenanceRecordScalarWhereInput[]
    OR?: MaintenanceRecordScalarWhereInput[]
    NOT?: MaintenanceRecordScalarWhereInput | MaintenanceRecordScalarWhereInput[]
    id?: StringFilter<"MaintenanceRecord"> | string
    equipmentId?: StringFilter<"MaintenanceRecord"> | string
    date?: DateTimeFilter<"MaintenanceRecord"> | Date | string
    type?: StringFilter<"MaintenanceRecord"> | string
    description?: StringNullableFilter<"MaintenanceRecord"> | string | null
    performedBy?: StringNullableFilter<"MaintenanceRecord"> | string | null
    cost?: FloatNullableFilter<"MaintenanceRecord"> | number | null
    nextScheduled?: DateTimeNullableFilter<"MaintenanceRecord"> | Date | string | null
  }

  export type EquipmentCreateWithoutMaintenanceHistoryInput = {
    id?: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutMaintenanceHistoryInput = {
    id?: string
    gymId: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutMaintenanceHistoryInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMaintenanceHistoryInput, EquipmentUncheckedCreateWithoutMaintenanceHistoryInput>
  }

  export type EquipmentUpsertWithoutMaintenanceHistoryInput = {
    update: XOR<EquipmentUpdateWithoutMaintenanceHistoryInput, EquipmentUncheckedUpdateWithoutMaintenanceHistoryInput>
    create: XOR<EquipmentCreateWithoutMaintenanceHistoryInput, EquipmentUncheckedCreateWithoutMaintenanceHistoryInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutMaintenanceHistoryInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutMaintenanceHistoryInput, EquipmentUncheckedUpdateWithoutMaintenanceHistoryInput>
  }

  export type EquipmentUpdateWithoutMaintenanceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMaintenanceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCreateWithoutPaymentsInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutPaymentsInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutPaymentsInput, GymUncheckedCreateWithoutPaymentsInput>
  }

  export type MembershipPlanCreateWithoutPaymentsInput = {
    id?: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutPlansInput
    memberships?: GymMembershipCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUncheckedCreateWithoutPaymentsInput = {
    id?: string
    gymId: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanCreateOrConnectWithoutPaymentsInput = {
    where: MembershipPlanWhereUniqueInput
    create: XOR<MembershipPlanCreateWithoutPaymentsInput, MembershipPlanUncheckedCreateWithoutPaymentsInput>
  }

  export type GymUpsertWithoutPaymentsInput = {
    update: XOR<GymUpdateWithoutPaymentsInput, GymUncheckedUpdateWithoutPaymentsInput>
    create: XOR<GymCreateWithoutPaymentsInput, GymUncheckedCreateWithoutPaymentsInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutPaymentsInput, GymUncheckedUpdateWithoutPaymentsInput>
  }

  export type GymUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type MembershipPlanUpsertWithoutPaymentsInput = {
    update: XOR<MembershipPlanUpdateWithoutPaymentsInput, MembershipPlanUncheckedUpdateWithoutPaymentsInput>
    create: XOR<MembershipPlanCreateWithoutPaymentsInput, MembershipPlanUncheckedCreateWithoutPaymentsInput>
    where?: MembershipPlanWhereInput
  }

  export type MembershipPlanUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: MembershipPlanWhereInput
    data: XOR<MembershipPlanUpdateWithoutPaymentsInput, MembershipPlanUncheckedUpdateWithoutPaymentsInput>
  }

  export type MembershipPlanUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutPlansNestedInput
    memberships?: GymMembershipUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: GymMembershipUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type GymCreateWithoutExpensesInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutExpensesInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
    subscription?: GymSubscriptionUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutExpensesInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutExpensesInput, GymUncheckedCreateWithoutExpensesInput>
  }

  export type GymUpsertWithoutExpensesInput = {
    update: XOR<GymUpdateWithoutExpensesInput, GymUncheckedUpdateWithoutExpensesInput>
    create: XOR<GymCreateWithoutExpensesInput, GymUncheckedCreateWithoutExpensesInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutExpensesInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutExpensesInput, GymUncheckedUpdateWithoutExpensesInput>
  }

  export type GymUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type UserCreateWithoutPaymentMethodsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentCreateNestedOneWithoutUserInput
    gyms?: GymCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    emailVerified?: boolean | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    activeGymId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    gyms?: GymUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    gymPreference?: GymUserPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentMethodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type UserUpsertWithoutPaymentMethodsInput = {
    update: XOR<UserUpdateWithoutPaymentMethodsInput, UserUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentMethodsInput, UserUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type UserUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutUserNestedInput
    gyms?: GymUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeGymId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    gyms?: GymUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    gymPreference?: GymUserPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StudentCreateWithoutFriendsInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFriendsInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFriendsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFriendsInput, StudentUncheckedCreateWithoutFriendsInput>
  }

  export type StudentCreateWithoutFriendOfInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFriendOfInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFriendOfInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFriendOfInput, StudentUncheckedCreateWithoutFriendOfInput>
  }

  export type StudentUpsertWithoutFriendsInput = {
    update: XOR<StudentUpdateWithoutFriendsInput, StudentUncheckedUpdateWithoutFriendsInput>
    create: XOR<StudentCreateWithoutFriendsInput, StudentUncheckedCreateWithoutFriendsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFriendsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFriendsInput, StudentUncheckedUpdateWithoutFriendsInput>
  }

  export type StudentUpdateWithoutFriendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFriendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentUpsertWithoutFriendOfInput = {
    update: XOR<StudentUpdateWithoutFriendOfInput, StudentUncheckedUpdateWithoutFriendOfInput>
    create: XOR<StudentCreateWithoutFriendOfInput, StudentUncheckedCreateWithoutFriendOfInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFriendOfInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFriendOfInput, StudentUncheckedUpdateWithoutFriendOfInput>
  }

  export type StudentUpdateWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateWithoutSubscriptionInput = {
    id?: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    progress?: StudentProgressCreateNestedOneWithoutStudentInput
    profile?: StudentProfileCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressCreateNestedManyWithoutStudentInput
    records?: PersonalRecordCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageCreateNestedManyWithoutStudentInput
    units?: UnitCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassCreateNestedManyWithoutStudentInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
  }

  export type StudentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    age?: number | null
    gender?: string | null
    phone?: string | null
    avatar?: string | null
    isTrans?: boolean | null
    usesHormones?: boolean | null
    hormoneType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: StudentProgressUncheckedCreateNestedOneWithoutStudentInput
    profile?: StudentProfileUncheckedCreateNestedOneWithoutStudentInput
    workouts?: WorkoutHistoryUncheckedCreateNestedManyWithoutStudentInput
    workoutProgress?: WorkoutProgressUncheckedCreateNestedManyWithoutStudentInput
    records?: PersonalRecordUncheckedCreateNestedManyWithoutStudentInput
    diets?: DietPlanCompletionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: AchievementUnlockUncheckedCreateNestedManyWithoutStudentInput
    weightHistory?: WeightHistoryUncheckedCreateNestedManyWithoutStudentInput
    dailyNutrition?: DailyNutritionUncheckedCreateNestedManyWithoutStudentInput
    nutritionChatUsage?: NutritionChatUsageUncheckedCreateNestedManyWithoutStudentInput
    units?: UnitUncheckedCreateNestedManyWithoutStudentInput
    memberships?: GymMembershipUncheckedCreateNestedManyWithoutStudentInput
    dayPasses?: DayPassUncheckedCreateNestedManyWithoutStudentInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
  }

  export type StudentCreateOrConnectWithoutSubscriptionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSubscriptionInput, StudentUncheckedCreateWithoutSubscriptionInput>
  }

  export type StudentUpsertWithoutSubscriptionInput = {
    update: XOR<StudentUpdateWithoutSubscriptionInput, StudentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<StudentCreateWithoutSubscriptionInput, StudentUncheckedCreateWithoutSubscriptionInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSubscriptionInput, StudentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type StudentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    progress?: StudentProgressUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUpdateManyWithoutStudentNestedInput
    units?: UnitUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
  }

  export type StudentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isTrans?: NullableBoolFieldUpdateOperationsInput | boolean | null
    usesHormones?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hormoneType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StudentProgressUncheckedUpdateOneWithoutStudentNestedInput
    profile?: StudentProfileUncheckedUpdateOneWithoutStudentNestedInput
    workouts?: WorkoutHistoryUncheckedUpdateManyWithoutStudentNestedInput
    workoutProgress?: WorkoutProgressUncheckedUpdateManyWithoutStudentNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutStudentNestedInput
    diets?: DietPlanCompletionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: AchievementUnlockUncheckedUpdateManyWithoutStudentNestedInput
    weightHistory?: WeightHistoryUncheckedUpdateManyWithoutStudentNestedInput
    dailyNutrition?: DailyNutritionUncheckedUpdateManyWithoutStudentNestedInput
    nutritionChatUsage?: NutritionChatUsageUncheckedUpdateManyWithoutStudentNestedInput
    units?: UnitUncheckedUpdateManyWithoutStudentNestedInput
    memberships?: GymMembershipUncheckedUpdateManyWithoutStudentNestedInput
    dayPasses?: DayPassUncheckedUpdateManyWithoutStudentNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
  }

  export type GymCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGymsInput
    profile?: GymProfileCreateNestedOneWithoutGymInput
    students?: GymMembershipCreateNestedManyWithoutGymInput
    equipment?: EquipmentCreateNestedManyWithoutGymInput
    plans?: MembershipPlanCreateNestedManyWithoutGymInput
    payments?: PaymentCreateNestedManyWithoutGymInput
    expenses?: ExpenseCreateNestedManyWithoutGymInput
    checkIns?: CheckInCreateNestedManyWithoutGymInput
    stats?: GymStatsCreateNestedOneWithoutGymInput
  }

  export type GymUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: GymProfileUncheckedCreateNestedOneWithoutGymInput
    students?: GymMembershipUncheckedCreateNestedManyWithoutGymInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutGymInput
    plans?: MembershipPlanUncheckedCreateNestedManyWithoutGymInput
    payments?: PaymentUncheckedCreateNestedManyWithoutGymInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutGymInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutGymInput
    stats?: GymStatsUncheckedCreateNestedOneWithoutGymInput
  }

  export type GymCreateOrConnectWithoutSubscriptionInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutSubscriptionInput, GymUncheckedCreateWithoutSubscriptionInput>
  }

  export type GymUpsertWithoutSubscriptionInput = {
    update: XOR<GymUpdateWithoutSubscriptionInput, GymUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<GymCreateWithoutSubscriptionInput, GymUncheckedCreateWithoutSubscriptionInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutSubscriptionInput, GymUncheckedUpdateWithoutSubscriptionInput>
  }

  export type GymUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGymsNestedInput
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
  }

  export type GymCreateManyUserInput = {
    id?: string
    name: string
    logo?: string | null
    address: string
    phone: string
    email: string
    cnpj?: string | null
    plan?: string
    isActive?: boolean
    latitude?: number | null
    longitude?: number | null
    rating?: number | null
    totalReviews?: number
    amenities?: string | null
    openingHours?: string | null
    photos?: string | null
    isPartner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type?: string | null
    provider?: string | null
    providerAccountId?: string | null
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    accountId?: string | null
    providerId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    idToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionToken?: string | null
    expires?: Date | string | null
  }

  export type PaymentMethodCreateManyUserInput = {
    id?: string
    type: string
    isDefault?: boolean
    cardBrand?: string | null
    last4?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    holderName?: string | null
    pixKey?: string | null
    pixKeyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUpdateOneWithoutGymNestedInput
    students?: GymMembershipUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUpdateManyWithoutGymNestedInput
    payments?: PaymentUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUpdateManyWithoutGymNestedInput
    stats?: GymStatsUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: GymProfileUncheckedUpdateOneWithoutGymNestedInput
    students?: GymMembershipUncheckedUpdateManyWithoutGymNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutGymNestedInput
    plans?: MembershipPlanUncheckedUpdateManyWithoutGymNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutGymNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutGymNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutGymNestedInput
    stats?: GymStatsUncheckedUpdateOneWithoutGymNestedInput
    subscription?: GymSubscriptionUncheckedUpdateOneWithoutGymNestedInput
  }

  export type GymUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    pixKeyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutHistoryCreateManyStudentInput = {
    id?: string
    workoutId?: string | null
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
  }

  export type WorkoutProgressCreateManyStudentInput = {
    id?: string
    workoutId: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalRecordCreateManyStudentInput = {
    id?: string
    workoutHistoryId?: string | null
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
  }

  export type DietPlanCompletionCreateManyStudentInput = {
    id?: string
    dietPlanId: string
    date?: Date | string
    completed?: boolean
  }

  export type AchievementUnlockCreateManyStudentInput = {
    id?: string
    achievementId: string
    progress?: number | null
    unlockedAt?: Date | string
  }

  export type WeightHistoryCreateManyStudentInput = {
    id?: string
    weight: number
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyNutritionCreateManyStudentInput = {
    id?: string
    date?: Date | string
    waterIntake?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionChatUsageCreateManyStudentInput = {
    id?: string
    date?: Date | string
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyStudentInput = {
    id?: string
    title: string
    description?: string | null
    color?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipCreateManyStudentInput = {
    id?: string
    gymId: string
    planId?: string | null
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayPassCreateManyStudentInput = {
    id?: string
    gymId: string
    gymName: string
    purchaseDate?: Date | string
    validDate: Date | string
    price: number
    status?: string
    qrCode?: string | null
  }

  export type FriendshipCreateManyUserInput = {
    id?: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipCreateManyFriendInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type WorkoutHistoryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneWithoutCompletionsNestedInput
    exercises?: ExerciseLogUpdateManyWithoutWorkoutHistoryNestedInput
    records?: PersonalRecordUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: WorkoutUpdateOneRequiredWithoutProgressNestedInput
  }

  export type WorkoutProgressUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
    workoutHistory?: WorkoutHistoryUpdateOneWithoutRecordsNestedInput
  }

  export type PersonalRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutHistoryId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PersonalRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutHistoryId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DietPlanCompletionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    dietPlan?: DietPlanUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type DietPlanCompletionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DietPlanCompletionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietPlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUnlockUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUnlocksNestedInput
  }

  export type AchievementUnlockUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightHistoryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightHistoryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightHistoryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyNutritionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: NutritionMealUpdateManyWithoutDailyNutritionNestedInput
  }

  export type DailyNutritionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: NutritionMealUncheckedUpdateManyWithoutDailyNutritionNestedInput
  }

  export type DailyNutritionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    waterIntake?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionChatUsageUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionChatUsageUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionChatUsageUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workouts?: WorkoutUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workouts?: WorkoutUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutStudentsNestedInput
    plan?: MembershipPlanUpdateOneWithoutMembershipsNestedInput
  }

  export type GymMembershipUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayPassUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DayPassUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DayPassUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    gymName?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FriendshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friend?: StudentUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: StudentUpdateOneRequiredWithoutFriendsNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipCreateManyGymInput = {
    id?: string
    studentId: string
    planId?: string | null
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyGymInput = {
    id?: string
    name: string
    type: string
    brand?: string | null
    model?: string | null
    serialNumber?: string | null
    purchaseDate?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    status?: string
    currentUserId?: string | null
    currentUserName?: string | null
    currentStartTime?: Date | string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanCreateManyGymInput = {
    id?: string
    name: string
    type: string
    price: number
    duration: number
    benefits?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyGymInput = {
    id?: string
    studentId: string
    studentName: string
    planId?: string | null
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyGymInput = {
    id?: string
    type: string
    description?: string | null
    amount: number
    date?: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type CheckInCreateManyGymInput = {
    id?: string
    studentId: string
    studentName: string
    timestamp?: Date | string
    checkOut?: Date | string | null
    duration?: number | null
  }

  export type GymMembershipUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMembershipsNestedInput
    plan?: MembershipPlanUpdateOneWithoutMembershipsNestedInput
  }

  export type GymMembershipUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceHistory?: MaintenanceRecordUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceHistory?: MaintenanceRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
    currentUserName?: NullableStringFieldUpdateOperationsInput | string | null
    currentStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: GymMembershipUpdateManyWithoutPlanNestedInput
    payments?: PaymentUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: GymMembershipUncheckedUpdateManyWithoutPlanNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: MembershipPlanUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckInUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckInUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutCreateManyUnitInput = {
    id?: string
    title: string
    description?: string | null
    type?: string
    muscleGroup: string
    difficulty: string
    xpReward?: number
    estimatedTime: number
    order?: number
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUpdateManyWithoutWorkoutNestedInput
    completions?: WorkoutHistoryUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    completions?: WorkoutHistoryUncheckedUpdateManyWithoutWorkoutNestedInput
    progress?: WorkoutProgressUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    muscleGroup?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseCreateManyWorkoutInput = {
    id?: string
    name: string
    sets: number
    reps: string
    rest: number
    notes?: string | null
    videoUrl?: string | null
    educationalId?: string | null
    order?: number
    primaryMuscles?: string | null
    secondaryMuscles?: string | null
    difficulty?: string | null
    equipment?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    benefits?: string | null
    scientificEvidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutHistoryCreateManyWorkoutInput = {
    id?: string
    studentId: string
    date?: Date | string
    duration: number
    totalVolume?: number | null
    overallFeedback?: string | null
    bodyPartsFatigued?: string | null
    createdAt?: Date | string
  }

  export type WorkoutProgressCreateManyWorkoutInput = {
    id?: string
    studentId: string
    currentExerciseIndex?: number
    exerciseLogs: string
    skippedExercises?: string | null
    selectedAlternatives?: string | null
    xpEarned?: number
    totalVolume?: number
    completionPercentage?: number
    startTime?: Date | string
    cardioPreference?: string | null
    cardioDuration?: number | null
    selectedCardioType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutExerciseUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeExerciseUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeExerciseUncheckedUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sets?: IntFieldUpdateOperationsInput | number
    reps?: StringFieldUpdateOperationsInput | string
    rest?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    primaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    scientificEvidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutHistoryUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWorkoutsNestedInput
    exercises?: ExerciseLogUpdateManyWithoutWorkoutHistoryNestedInput
    records?: PersonalRecordUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
    records?: PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryNestedInput
  }

  export type WorkoutHistoryUncheckedUpdateManyWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    overallFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartsFatigued?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutWorkoutProgressNestedInput
  }

  export type WorkoutProgressUncheckedUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutProgressUncheckedUpdateManyWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currentExerciseIndex?: IntFieldUpdateOperationsInput | number
    exerciseLogs?: StringFieldUpdateOperationsInput | string
    skippedExercises?: NullableStringFieldUpdateOperationsInput | string | null
    selectedAlternatives?: NullableStringFieldUpdateOperationsInput | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    cardioPreference?: NullableStringFieldUpdateOperationsInput | string | null
    cardioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    selectedCardioType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeExerciseCreateManyWorkoutExerciseInput = {
    id?: string
    name: string
    reason: string
    educationalId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeExerciseUpdateWithoutWorkoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeExerciseUncheckedUpdateWithoutWorkoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeExerciseUncheckedUpdateManyWithoutWorkoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    educationalId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseLogCreateManyWorkoutHistoryInput = {
    id?: string
    exerciseId: string
    exerciseName: string
    sets: string
    notes?: string | null
    formCheckScore?: number | null
    difficulty?: string | null
  }

  export type PersonalRecordCreateManyWorkoutHistoryInput = {
    id?: string
    studentId: string
    exerciseId: string
    exerciseName: string
    type: string
    value: number
    date?: Date | string
    previousBest?: number | null
  }

  export type ExerciseLogUpdateWithoutWorkoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExerciseLogUncheckedUpdateWithoutWorkoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExerciseLogUncheckedUpdateManyWithoutWorkoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    sets?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    formCheckScore?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalRecordUpdateWithoutWorkoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type PersonalRecordUncheckedUpdateWithoutWorkoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PersonalRecordUncheckedUpdateManyWithoutWorkoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    exerciseName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    previousBest?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MealCreateManyDietPlanInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    image?: string | null
    ingredients?: string | null
    order?: number
  }

  export type DietPlanCompletionCreateManyDietPlanInput = {
    id?: string
    studentId: string
    date?: Date | string
    completed?: boolean
  }

  export type MealUpdateWithoutDietPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MealUncheckedUpdateWithoutDietPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MealUncheckedUpdateManyWithoutDietPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DietPlanCompletionUpdateWithoutDietPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutDietsNestedInput
  }

  export type DietPlanCompletionUncheckedUpdateWithoutDietPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DietPlanCompletionUncheckedUpdateManyWithoutDietPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NutritionMealCreateManyDailyNutritionInput = {
    id?: string
    name: string
    type: string
    calories: number
    protein: number
    carbs: number
    fats: number
    time?: string | null
    completed?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionMealUpdateWithoutDailyNutritionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foods?: NutritionFoodItemUpdateManyWithoutNutritionMealNestedInput
  }

  export type NutritionMealUncheckedUpdateWithoutDailyNutritionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foods?: NutritionFoodItemUncheckedUpdateManyWithoutNutritionMealNestedInput
  }

  export type NutritionMealUncheckedUpdateManyWithoutDailyNutritionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemCreateManyNutritionMealInput = {
    id?: string
    foodId?: string | null
    foodName: string
    servings: number
    calories: number
    protein: number
    carbs: number
    fats: number
    servingSize: string
    createdAt?: Date | string
  }

  export type NutritionFoodItemUpdateWithoutNutritionMealInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemUncheckedUpdateWithoutNutritionMealInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionFoodItemUncheckedUpdateManyWithoutNutritionMealInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: NullableStringFieldUpdateOperationsInput | string | null
    foodName?: StringFieldUpdateOperationsInput | string
    servings?: FloatFieldUpdateOperationsInput | number
    calories?: IntFieldUpdateOperationsInput | number
    protein?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    servingSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockCreateManyAchievementInput = {
    id?: string
    studentId: string
    progress?: number | null
    unlockedAt?: Date | string
  }

  export type AchievementUnlockUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUnlockUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUnlockUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipCreateManyPlanInput = {
    id?: string
    gymId: string
    studentId: string
    startDate?: Date | string
    nextBillingDate?: Date | string | null
    amount: number
    status?: string
    autoRenew?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyPlanInput = {
    id?: string
    gymId: string
    studentId: string
    studentName: string
    amount: number
    date?: Date | string
    dueDate: Date | string
    status?: string
    paymentMethod?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutStudentsNestedInput
    student?: StudentUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type GymMembershipUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRecordCreateManyEquipmentInput = {
    id?: string
    date?: Date | string
    type: string
    description?: string | null
    performedBy?: string | null
    cost?: number | null
    nextScheduled?: Date | string | null
  }

  export type MaintenanceRecordUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceRecordUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceRecordUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    nextScheduled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}